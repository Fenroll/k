// ============================================
// COMPLETE CHAT SYSTEM - ONE FILE
// Firebase REST API + UI + User Management
// ============================================

// (Chat system initialized)

// ============================================
// PART 1: USER INITIALIZATION
// ============================================

// The `currentUser` object is now created in `js/user-identity.js` and is globally available.
// This file assumes `user-identity.js` has been loaded.

// ============================================
// PART 2: FIREBASE REST API
// ============================================

class ChatFirebaseREST {
  constructor(documentId) {
    this.documentId = documentId || 'default';
    this.messages = [];
    this.listeners = [];
    this.isPolling = false;
    this.unsubscribers = [];
    this.heartbeatInterval = null;
    
    // –í–ê–ñ–ù–û: –¢—É–∫ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –ø–æ–ø—ä–ª–Ω—è—Ç –≤–∞—à–∏—Ç–µ –¥–∞–Ω–Ω–∏ –æ—Ç Firebase Console!
    this.firebaseConfig = {
      apiKey: "API_KEY", // –ó–∞–º–µ–Ω–∏ —Å —Ç–≤–æ—è API Key
      authDomain: "med-student-chat.firebaseapp.com",
      databaseURL: "https://med-student-chat-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "med-student-chat",
      storageBucket: "med-student-chat.appspot.com",
      messagingSenderId: "SENDER_ID",
      appId: "APP_ID"
    };

    console.log('Using Firebase SDK Wrapper');
    this.initSDK();
  }

  async initSDK() {
    if (window.firebaseSDK) {
      this.sdk = window.firebaseSDK;
      this.initApp();
      return;
    }

    try {
      // Dynamic loads require modern browser support
      const { initializeApp, getApps, getApp } = await import("https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js");
      const dbModule = await import("https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js");
      
      this.sdk = { initializeApp, getApps, getApp, ...dbModule };
      window.firebaseSDK = this.sdk;
      this.initApp();
    } catch (e) {
      console.error("Failed to load Firebase SDK:", e);
    }
  }

  initApp() {
    try {
      const { initializeApp, getDatabase, getApps } = this.sdk;
      // Check if app already exists to avoid errors on page reload/navigation
      const app = getApps().length === 0 ? initializeApp(this.firebaseConfig) : getApps()[0];
      this.db = getDatabase(app);
      console.log('‚úì Firebase SDK Initialized');
    } catch (e) {
      console.error("Firebase Init Error:", e);
    }
  }

  async _ensureInit() {
    if (this.db) return;
    await this.initSDK();
    // Wait a bit if still initializing?
    while (!this.db) {
        await new Promise(r => setTimeout(r, 100));
        // Add timeout break to avoid infinite loop?
        if (!this.sdk) break; 
    }
  }

  async sendMessage(text, replyTo = null, replyAuthor = null) {
    if (!text.trim()) return false;
    await this._ensureInit();

    const { ref, push, set, serverTimestamp } = this.sdk;
    const messagesRef = ref(this.db, `messages/${this.documentId}`);
    
    const message = {
      userId: currentUser.userId,
      userName: currentUser.userName,
      userColor: currentUser.color,
      text: text.trim(),
      timestamp: serverTimestamp(),
      // id will be generated by key
    };

    if (replyTo && replyAuthor) {
      message.replyTo = replyTo;
      message.replyAuthor = replyAuthor;
    }

    try {
      const newMessageRef = push(messagesRef);
      await set(newMessageRef, message);
      return true;
    } catch (error) {
      console.error('SDK Send error:', error);
      return false;
    }
  }

  async loadMessages() {
    // –í SDK —Ä–µ–∂–∏–º, —Ç–æ–≤–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Ä—è–¥–∫–æ, –∑–∞—â–æ—Ç–æ startPolling –ø–æ–¥–¥—ä—Ä–∂–∞ –≤—Å–∏—á–∫–æ
    await this._ensureInit();
    const { ref, get, query, orderByChild, limitToLast } = this.sdk;
    
    try {
      const messagesRef = ref(this.db, `messages/${this.documentId}`);
      // Limit to last 500 to prevent lagging
      const q = query(messagesRef, orderByChild('timestamp'), limitToLast(500));
      
      const snapshot = await get(q);
      if (!snapshot.exists()) return [];
      
      const data = snapshot.val();
      const messages = Object.keys(data).map(key => ({
        ...data[key],
        key: key,
        id: key
      }));

      // Sort
      messages.sort((a, b) => a.timestamp - b.timestamp);
      this.messages = messages;
      return messages;
    } catch (error) {
      console.error('SDK Load error:', error);
      return [];
    }
  }

  async bulkUpdate(updates) {
    await this._ensureInit();
    const { ref, update } = this.sdk;
    try {
        await update(ref(this.db), updates);
        return true;
    } catch (error) {
        console.error('SDK Bulk Update error:', error);
        return false;
    }
  }

  async updateNameMapping(oldName, newName) {
    await this._ensureInit();
    const { ref, set } = this.sdk;
    const mappingRef = ref(this.db, `name_mappings/${oldName}`);
    try {
        await set(mappingRef, newName);
        return true;
    } catch (error) {
        console.error('SDK updateNameMapping error:', error);
        return false;
    }
  }

  async getNameMappings() {
    await this._ensureInit();
    const { ref, get } = this.sdk;
    try {
        const snapshot = await get(ref(this.db, `name_mappings`));
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  startNameMappingsPolling(callback) {
    this._ensureInit().then(() => {
        const { ref, onValue } = this.sdk;
        const mappingsRef = ref(this.db, `name_mappings`);

        const unsubscribe = onValue(mappingsRef, (snapshot) => {
            const mappings = snapshot.val() || {};
            callback(mappings);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getProtectedNames() {
    await this._ensureInit();
    const { ref, get } = this.sdk;
    try {
        const snapshot = await get(ref(this.db, `protected_names`));
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  async protectName(name, password) {
    await this._ensureInit();
    const { ref, set } = this.sdk;
    const protectedNameRef = ref(this.db, `protected_names/${name}`);
    try {
        await set(protectedNameRef, password); // In a real app, hash the password
        return true;
    } catch (error) {
        console.error('SDK protectName error:', error);
        return false;
    }
  }

  startPolling(callback, interval = 2000) {
    if (this.isPolling) return;
    this.isPolling = true;

    this._ensureInit().then(() => {
        const { ref, onValue, query, orderByChild, limitToLast } = this.sdk;
        const messagesRef = ref(this.db, `messages/${this.documentId}`);
        // Realtime Listener
        const q = query(messagesRef, orderByChild('timestamp'), limitToLast(500));

        const unsubscribe = onValue(q, (snapshot) => {
            const messages = [];
            snapshot.forEach((child) => {
                const val = child.val();
                messages.push({
                    ...val,
                    key: child.key,
                    id: child.key,
                    // Handle serverTimestamp properly if it's still processing (can be null briefly)
                    timestamp: val.timestamp || Date.now()
                });
            });
            
            // Check for new messages for notifications
            if (messages.length > this.messages.length && this.messages.length > 0) {
                 const newMessage = messages[messages.length - 1];
                 this.listeners.forEach(listener => listener(newMessage));
            }

            this.messages = messages;
            callback(messages);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  addMessageListener(callback) {
    this.listeners.push(callback);
  }

  async updateColorForAllSessions(newColor) {
    // –û–±–Ω–æ–≤–∏ —Ü–≤–µ—Ç–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏ —Å–µ—Å–∏–∏ —Å —Ç–µ–∫—É—â–æ—Ç–æ –∏–º–µ
    await this._ensureInit();
    const { ref, get, update } = this.sdk;
    const activeUsersRef = ref(this.db, `active_users/${this.documentId}`);
    
    try {
      const snapshot = await get(activeUsersRef);
      if (!snapshot.exists()) return;
      
      const users = snapshot.val();
      const updates = {};
      
      // –ù–∞–º–µ—Ä–∏ –≤—Å–∏—á–∫–∏ —Å–µ—Å–∏–∏ —Å —Ç–µ–∫—É—â–æ—Ç–æ –∏–º–µ
      Object.keys(users).forEach(userId => {
        if (users[userId].userName === currentUser.userName) {
          updates[`active_users/${this.documentId}/${userId}/color`] = newColor;
        }
      });
      
      if (Object.keys(updates).length > 0) {
        await update(ref(this.db), updates);
        console.log(`‚úì –û–±–Ω–æ–≤–µ–Ω–∏ ${Object.keys(updates).length} —Å–µ—Å–∏–∏ —Å –Ω–æ–≤ —Ü–≤—è—Ç`);
      }
    } catch (error) {
      console.error('Update color error:', error);
    }
  }

  async markUserActive() {
    await this._ensureInit();
    const { ref, set, update, onDisconnect, serverTimestamp, onValue } = this.sdk;
    const userRef = ref(this.db, `active_users/${this.documentId}/${currentUser.userId}`);
    const connectedRef = ref(this.db, '.info/connected');

    try {
        // –ü–æ-–¥–æ–±—Ä–∞ –¥–µ—Ç–µ–∫—Ü–∏—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
        const isMobile = window.innerWidth <= 768 || 
                        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        console.log('Mobile detection:', isMobile, 'Window width:', window.innerWidth);

        onValue(connectedRef, (snap) => {
            if (snap.val() === true) {
                const userData = {
                    userId: currentUser.userId,
                    userName: currentUser.userName,
                    color: currentUser.color,
                    device: isMobile ? 'mobile' : 'desktop',
                    lastSeen: serverTimestamp(),
                    isActive: true
                };
                onDisconnect(userRef).remove();
                set(userRef, userData);
            }
        });

        // Function to force update presence
        const forceUpdate = () => {
             if (this.db) {
                 const currentIsMobile = window.innerWidth <= 768 || 
                               /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                 
                 // Use set() or merge with all info to resurrect if missing
                 const userData = {
                    userId: currentUser.userId,
                    userName: currentUser.userName,
                    color: currentUser.color,
                    device: currentIsMobile ? 'mobile' : 'desktop',
                    lastSeen: serverTimestamp(),
                    isActive: true
                };
                
                // We use update if we just want to touch timestamp, but if checking for absence...
                // Let's uset update() but with core fields to ensure display works even if resurrected
                update(userRef, userData).catch(e => console.error("Heartbeat error", e));
             }
        };

        // Heartbeat: Updated every 25 sec to be safe (client side), server might have timeouts
        // But to be robust against "disappearing", we include full user info
        if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = setInterval(forceUpdate, 25000);

        // Also trigger when tab becomes visible
        document.addEventListener("visibilitychange", () => {
             if (document.visibilityState === 'visible') {
                 forceUpdate();
             }
        });

        // Hook into user interaction to keep alive actively
        ['mousedown', 'keydown', 'touchstart'].forEach(evt => {
            window.addEventListener(evt, () => {
                // Throttle this? Maybe once every minute of activity?
                // For now relying on interval is enough
            }, { passive: true });
        });

        console.log('‚úì –ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –º–∞—Ä–∫–∏—Ä–∞–Ω –∞–∫—Ç–∏–≤–µ–Ω (SDK Presence + Heartbeat + Device)');
        return true;
    } catch (error) {
        console.error('Mark active error:', error);
        return false;
    }
  }

  async getActiveUsers() {
    await this._ensureInit();
    const { ref, get } = this.sdk;
    try {
        const snapshot = await get(ref(this.db, `active_users/${this.documentId}`));
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  async deleteMessage(messageKey) {
    await this._ensureInit();
    const { ref, remove } = this.sdk;
    try {
        const messageRef = ref(this.db, `messages/${this.documentId}/${messageKey}`);
        await remove(messageRef);
        return true;
    } catch (e) {
        console.error("SDK deleteMessage error:", e);
        return false;
    }
  }

  async setLastRead(userName, messageId) {
    if (!userName || !messageId) return false;
    // Note: Firebase keys can't contain ., $, #, [, ], /, or ASCII control chars 0-31 or 127.
    // Sanitize userName to be a safe key.
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    await this._ensureInit();
    const { ref, set } = this.sdk;
    const lastReadRef = ref(this.db, `last_read/${this.documentId}/${safeUserName}`);
    try {
        await set(lastReadRef, messageId);
        return true;
    } catch (error) {
        console.error('SDK setLastRead error:', error);
        return false;
    }
  }

  startLastReadPolling(userName, callback) {
    if (!userName) return;
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    this._ensureInit().then(() => {
        const { ref, onValue } = this.sdk;
        const lastReadRef = ref(this.db, `last_read/${this.documentId}/${safeUserName}`);

        const unsubscribe = onValue(lastReadRef, (snapshot) => {
            const lastReadId = snapshot.val();
            if (lastReadId) {
                callback(lastReadId);
            }
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getReactions(messageId) {
    await this._ensureInit();
    const { ref, get } = this.sdk;
    try {
      const snapshot = await get(ref(this.db, `reactions/${this.documentId}/${messageId}`));
      return snapshot.exists() ? snapshot.val() : null;
    } catch (e) {
      console.error("SDK getReactions error:", e);
      return null;
    }
  }

  async addReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, true);
  }

  async removeReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, false);
  }

  async setReaction(messageId, emoji, value) {
    await this._ensureInit();
    const { ref, set } = this.sdk;
    try {
      // Use set with false to "remove" (logically) or null/remove to physically remove?
      // The original code used PUT with true/false, establishing a schema where key=userId, value=true/false
      // path: reactions/docId/msgId/emoji/userId = true/false
      const reactionRef = ref(this.db, `reactions/${this.documentId}/${messageId}/${emoji}/${currentUser.userId}`);
      
      // If value is false, maybe we should remove the node to keep DB clean, 
      // but original code sent 'false'. Let's stick to user logic or improve it.
      // Actually, removing it is better for counting.
      if (value) {
          await set(reactionRef, true);
      } else {
          await set(reactionRef, null); // Remove the node
      }
      return true;
    } catch (e) {
      console.error("SDK setReaction error:", e);
      return false;
    }
  }

  async bulkRemoveReactions(messageId, emoji, userIds) {
    if (!userIds || userIds.length === 0) return true;
    await this._ensureInit();
    const { ref, update } = this.sdk;
    const updates = {};
    userIds.forEach(id => {
        updates[`reactions/${this.documentId}/${messageId}/${emoji}/${id}`] = null;
    });
    try {
        await update(ref(this.db), updates);
        return true;
    } catch (e) {
        console.error("SDK bulkRemoveReactions error:", e);
        return false;
    }
  }

  startReactionsPolling(callback) {
    this._ensureInit().then(() => {
        const { ref, onValue } = this.sdk;
        const reactionsRef = ref(this.db, `reactions/${this.documentId}`);

        const unsubscribe = onValue(reactionsRef, (snapshot) => {
            const reactions = snapshot.val() || {};
            callback(reactions);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  startActiveUsersPolling(callback, interval = 5000) {
    this._ensureInit().then(() => {
        const { ref, onValue } = this.sdk;

        const unsubscribe = onValue(ref(this.db, `active_users/${this.documentId}`), (snapshot) => {
            const usersRaw = snapshot.val() || {};
            const finalUsers = {};

            // Filter out any invalid or malformed user entries, just in case.
            // This makes the list reflect the database state directly and instantly.
            Object.keys(usersRaw).forEach(key => {
                const u = usersRaw[key];
                if (u && typeof u === 'object' && u.userName) {
                    finalUsers[key] = u;
                }
            });
            
            callback({
                count: Object.keys(finalUsers).length,
                users: finalUsers,
                usersList: Object.keys(finalUsers)
            });
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  stop() {
    this.isPolling = false;
    this.listeners = [];

    // Unsubscribe from all listeners
    this.unsubscribers.forEach(unsub => unsub());
    this.unsubscribers = [];

    // Clear heartbeat
    if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
    }

    console.log('üõë ChatFirebaseREST —Å–ø—Ä—è–Ω.');
  }
}

// ============================================
// PART 3: CHAT UI MANAGER
// ============================================

class ChatUIManager {
  constructor(containerId, documentId) {
    console.log('üí¨ ChatUIManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º...');
    this.container = document.getElementById(containerId);
    if (!this.container) {
      console.error('Container –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω:', containerId);
      return;
    }
    
    this.documentId = documentId || 'default';
    this.chatFirebase = new ChatFirebaseREST(this.documentId);
    this.isOpen = false;
    this.autoScroll = true;
    this.lastReadMessageId = localStorage.getItem(`lastReadMessage_${documentId}`) || null;
    this.notificationsDisabled = localStorage.getItem(`notificationsDisabled_${documentId}`) !== 'false';
    this.unreadCount = 0;
    this.lastMessages = [];  // –°—ä—Ö—Ä–∞–Ω—è–≤–∞–º –ø—Ä–µ–¥–∏—à–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
    this.userNameMappings = {}; // –ö–∞—Ä—Ç–∞ –∑–∞ —Å—Ç–∞—Ä–∏ –∫—ä–º –Ω–æ–≤–∏ –∏–º–µ–Ω–∞
    this.reactionsCache = {}; // –ö–µ—à –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    this.activeUsers = {}; // –°–ø–∏—Å—ä–∫ —Å –∞–∫—Ç–∏–≤–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –∑–∞ –ª–æ–≥–∏–∫–∞ —Å —Ä–µ–∞–∫—Ü–∏–∏

    this.init();
  }

  _getMyUserIds() {
    if (!this.activeUsers || !currentUser.userName) return [currentUser.userId];
    
    const myName = currentUser.userName;
    const myIds = new Set([currentUser.userId]); // Always include current ID

    // Find all other userIds with the same name from the active list
    for (const userId in this.activeUsers) {
        const user = this.activeUsers[userId];
        if (user && user.userName === myName) {
            myIds.add(userId);
        }
    }
    return Array.from(myIds);
  }

  resolveName(originalName) {
    if (!this.userNameMappings || !originalName) return originalName;
    let currentName = originalName;
    let resolvedName = this.userNameMappings[currentName];
    let depth = 0; // safety break for circular dependencies
    while (resolvedName && depth < 10) {
        currentName = resolvedName;
        // Check for the next name in the chain
        resolvedName = this.userNameMappings[currentName];
        depth++;
    }
    return currentName;
  }

  fixInputLayout() {
    const inputArea = this.container.querySelector('.chat-input-area');
    if (!inputArea) return;

    // 1. Inject CSS for Column Layout if not present
    if (!document.getElementById('chat-layout-fix')) {
        const style = document.createElement('style');
        style.id = 'chat-layout-fix';
        style.textContent = `
            .chat-input-area {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 0 !important;
            }
            .chat-controls-row {
                display: flex !important;
                align-items: center !important;
                width: 100% !important;
                padding-top: 6px;
                position: relative;
                gap: 12px !important;
            }
            .reply-indicator {
                width: 100%;
                box-sizing: border-box;
                margin-bottom: 4px;
            }
            .message-actions {
                position: absolute;
                top: 3px;
                right: 3px;
                display: none;
                background: white;
                border-radius: 6px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                padding: 2px;
                gap: 2px;
            }
            .chat-message:hover .message-actions {
                display: flex;
            }
            .message-actions button {
                transition: background 0.2s;
            }
            .message-actions button:hover {
                background: #dbeafe !important;
            }
        `;
        document.head.appendChild(style);
    }

    // 2. Restructure DOM: Move controls into a row if they aren't already
    const inputField = inputArea.querySelector('.chat-input');
    
    // Only proceed if inputField is direct child of inputArea (meaning not wrapped yet)
    if (inputField && inputField.parentElement === inputArea) {
        const row = document.createElement('div');
        row.className = 'chat-controls-row';
        
        // Find elements to move
        const uploadInput = inputArea.querySelector('#image-upload-input');
        const uploadBtn = inputArea.querySelector('#image-upload-btn');
        const sendBtn = inputArea.querySelector('.chat-send-btn');
        
        // Move them to row
        if (uploadInput) row.appendChild(uploadInput);
        if (uploadBtn) row.appendChild(uploadBtn);
        row.appendChild(inputField); // Input
        if (sendBtn) row.appendChild(sendBtn);
        
        // Append row to inputArea
        inputArea.appendChild(row);
    }
  }

  async init() {
    try {
      this.fixInputLayout();
      // –ú–∞—Ä–∫–∏—Ä–∞–π –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∞–∫—Ç–∏–≤–µ–Ω
      await this.chatFirebase.markUserActive();

      // –ó–∞—Ä–µ–¥–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è - –æ—Ç localStorage –∏–ª–∏ Firebase
      let messages = this.loadFromCache();
      if (!messages || messages.length === 0) {
        messages = await this.chatFirebase.loadMessages();
      }
      
      // –ó–∞—Ä–µ–¥–∏ –º–∞–ø–∏–Ω–≥–∏ –Ω–∞ –∏–º–µ–Ω–∞
      this.protectedNames = await this.chatFirebase.getProtectedNames();

      this.chatFirebase.startNameMappingsPolling((mappings) => {
          this.userNameMappings = mappings;
          if (this.lastMessages.length > 0) {
              this.renderMessages(this.lastMessages);
          }
      });
      
      this.saveToCache(messages);
      this.renderMessages(messages);

      // Polling –∑–∞ –Ω–æ–≤–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startPolling((messages) => {
        this.saveToCache(messages);
        this.renderMessages(messages);
      }, 2500);

      // Real-time —Å–ª—É—à–∞—Ç–µ–ª –∑–∞ –í–°–ò–ß–ö–ò —Ä–µ–∞–∫—Ü–∏–∏
      this.chatFirebase.startReactionsPolling((reactions) => {
        this.reactionsCache = reactions;
        this.renderAllReactions();
      });

      // Polling –∑–∞ –∞–∫—Ç–∏–≤–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
      this.chatFirebase.startActiveUsersPolling((data) => {
        this.activeUsers = data.users || {}; // –ó–∞–ø–∞–∑–∏ —Å–ø–∏—Å—ä–∫–∞ —Å –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
        this.updateNotificationButton(data);
        this.updateHeaderOnlineCount(data.count);
      }, 5000);

      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startLastReadPolling(currentUser.userName, (lastReadId) => {
        if (lastReadId && lastReadId !== this.lastReadMessageId) {
          console.log(`üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞–Ω –Ω–æ–≤ lastReadId: ${lastReadId}`);
          this.lastReadMessageId = lastReadId;
          localStorage.setItem(`lastReadMessage_${this.documentId}`, lastReadId);
          
          // –ü—Ä–µ–∏–∑—á–∏—Å–ª–∏ –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏—Ç–µ –∏ –æ–±–Ω–æ–≤–∏ –±—Ä–æ—è—á–∞
          this.recalculateUnreadCount(this.chatFirebase.messages);
          this.updateActiveCount();
        }
      });

      // Listener –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      this.chatFirebase.addMessageListener((newMessage) => {
        // Check if the message is from the current user
        const isMyMessage = (currentUser.userId && newMessage.userId === currentUser.userId) ||
                            (currentUser.legacyChatId && newMessage.userId === currentUser.legacyChatId);

        // Trigger notification only if chat is closed and message is not from self
        if (!this.isOpen && !isMyMessage) {
            this.showNotification();
        }
      });

      this.attachEventListeners();
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–π –±—É—Ç–æ–Ω –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ–¥–∏–Ω –ø—ä—Ç
      this.initNotificationButton();
      
      console.log('‚úì‚úì‚úì ChatUIManager –≥–æ—Ç–æ–≤');
    } catch (error) {
      console.error('Init error:', error);
    }
  }

  loadFromCache() {
    try {
      const key = `chatMessages_${this.documentId}`;
      const cached = localStorage.getItem(key);
      if (cached) {
        return JSON.parse(cached);
      }
    } catch (error) {
      console.error('Cache load error:', error);
    }
    return null;
  }

  saveToCache(messages) {
    try {
      const key = `chatMessages_${this.documentId}`;
      localStorage.setItem(key, JSON.stringify(messages));
    } catch (error) {
      console.error('Cache save error:', error);
    }
  }

  attachEventListeners() {
    const sendBtn = this.container.querySelector('.chat-send-btn');
    const input = this.container.querySelector('.chat-input'); // This is now a textarea

    if (sendBtn && input) {
      sendBtn.addEventListener('click', () => this.handleSendMessage());
      
      // Handle Enter (Send) vs Shift+Enter (New Line)
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSendMessage();
        }
      });
      
      // Auto-resize textarea
      input.addEventListener('input', () => {
         input.style.height = 'auto';
         input.style.height = (input.scrollHeight) + 'px';
         // Cap max height if needed via CSS max-height
      });
    }

    const messagesContainer = this.container.querySelector('.chat-messages');
    if (messagesContainer) {
      messagesContainer.addEventListener('scroll', () => {
        const isAtBottom =
          messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 50;
        this.autoScroll = isAtBottom;
      });
    }
  }

  initNotificationButton() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–π –±—É—Ç–æ–Ω –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ–¥–∏–Ω –ø—ä—Ç
    const sidebarEl = this.container.querySelector('.chat-active-users');
    if (!sidebarEl) {
      console.error('Sidebar –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }

    sidebarEl.innerHTML = `
      <div style="padding: 8px;">
        <button id="toggle-notifications" style="width: 100%; padding: 10px; background: ${this.notificationsDisabled ? '#ff6b6b' : '#4ade80'}; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 6px;">
          <img src="svg/${this.notificationsDisabled ? 'bell-slash-svgrepo-com.svg' : 'bell-alt-svgrepo-com.svg'}" alt="–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è" style="width: 16px; height: 16px; filter: invert(1);">
          <span>${this.notificationsDisabled ? '–ò–∑–∫–ª—é—á–µ–Ω–∏' : '–í–∫–ª—é—á–µ–Ω–∏'}</span>
        </button>
        <div id="active-users-list" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280;"></div>
      </div>
    `;

    // –î–æ–±–∞–≤–∏ listener –µ–¥–∏–Ω –ø—ä—Ç
    const toggleBtn = sidebarEl.querySelector('#toggle-notifications');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => {
        this.notificationsDisabled = !this.notificationsDisabled;
        localStorage.setItem(`notificationsDisabled_${this.documentId}`, this.notificationsDisabled);
        // –û–±–Ω–æ–≤–∏ —Ü–≤–µ—Ç–∞ –±–µ–∑ –¥–∞ –ø—Ä–µ–∑–∞–ø–∏—Å–≤–∞—à HTML
        this.updateNotificationButtonColor();
        // –û–±–Ω–æ–≤–∏ –∏–∫–æ–Ω–∫–∞—Ç–∞ (—Å–∫—Ä–∏–π/–ø–æ–∫–∞–∂–∏ —á–∏—Å–ª–æ—Ç–æ –Ω–∞ –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏)
        this.updateActiveCount();
      });
    } else {
      console.error('–ë—É—Ç–æ–Ω –ù–ï –µ –Ω–∞–º–µ—Ä–µ–Ω!');
    }
  }

  updateNotificationButtonColor() {
    // –û–±–Ω–æ–≤–∏ —Å–∞–º–æ —Ü–≤–µ—Ç–∞ –∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –±—É—Ç–æ–Ω–∞ –±–µ–∑ –¥–∞ –ø—Ä–µ–∑–∞–ø–∏—Å–≤–∞—à HTML
    const toggleBtn = document.querySelector('#toggle-notifications');
    if (toggleBtn) {
      toggleBtn.style.background = this.notificationsDisabled ? '#ff6b6b' : '#4ade80';
      const img = toggleBtn.querySelector('img');
      if (img) {
        img.src = `svg/${this.notificationsDisabled ? 'bell-slash-svgrepo-com.svg' : 'bell-alt-svgrepo-com.svg'}`;
      }
      const span = toggleBtn.querySelector('span');
      if (span) {
        span.textContent = this.notificationsDisabled ? '–ò–∑–∫–ª—é—á–µ–Ω–∏' : '–í–∫–ª—é—á–µ–Ω–∏';
      }
    }
  }

  updateNotificationButton(data) {
    // –û–±–Ω–æ–≤–∏ –∞–∫—Ç–∏–≤–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –≤ —Å–ø–∏—Å—ä–∫–∞ (–±–µ–∑ –¥–∞ –ø—Ä–µ–∑–∞–ø–∏—Å–≤–∞—à –±—É—Ç–æ–Ω–∞)
    const usersList = document.getElementById('active-users-list');
    if (!usersList) return;

    // Ensure current user is always in the list
    const remoteUsers = data.users || {};
    const allUsers = { ...remoteUsers };
    
    // Add current user if missing (using currentUser global)
    if (typeof currentUser !== 'undefined' && currentUser.userId) {
        if (!allUsers[currentUser.userId]) {
             allUsers[currentUser.userId] = {
                 userId: currentUser.userId,
                 userName: currentUser.userName,
                 color: currentUser.color,
                 device: window.innerWidth <= 768 ? 'mobile' : 'desktop',
                 isActive: true
             };
        }
    }

    // --- –ù–û–í–ê –õ–û–ì–ò–ö–ê –ó–ê –ì–†–£–ü–ò–†–ê–ù–ï ---
    const groupedUsers = {};
    const myId = (typeof currentUser !== 'undefined' && currentUser.userId) ? String(currentUser.userId) : null;

    Object.values(allUsers).forEach(user => {
        let name = user.userName;
        // Resolve mapping if available
        if (this.userNameMappings && this.userNameMappings[name]) {
            name = this.userNameMappings[name];
        }
        
        // Normalize name (trim spaces) to ensure identical names group together
        const finalName = name ? name.toString().trim() : 'Anonymous';
        
        if (!groupedUsers[finalName]) {
            groupedUsers[finalName] = {
                ...user,
                userName: finalName,
                isMe: false,
                hasMobile: false
            };
        }
        
        // Check if *this* instance of the user is Me
        if (String(user.userId) === myId) {
            groupedUsers[finalName].isMe = true;
        }
        
        // Check for mobile
        if (user.device === 'mobile') {
             groupedUsers[finalName].hasMobile = true;
        }
    });

    const users = Object.values(groupedUsers);
    const count = Object.keys(groupedUsers).length;

    // Sort: current user first, then alphabetically
    users.sort((a, b) => {
      if (a.isMe) return -1;
      if (b.isMe) return 1;
      return a.userName.localeCompare(b.userName);
    });

    usersList.innerHTML = `
      <strong>–ê–∫—Ç–∏–≤–Ω–∏ (${count}):</strong><br>
      ${users.map(user => {
          const isMe = user.isMe;
          
          const mobileIcon = user.hasMobile
            ? `<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="margin-left: 4px; vertical-align: middle;" title="Mobile device"> <path d="M11.5,0h-7C3.675,0,3,0.675,3,1.5v13C3,15.325,3.675,16,4.5,16h7c0.825,0,1.5-0.675,1.5-1.5v-13C13,0.675,12.325,0,11.5,0z M8,15c-0.553,0-1-0.447-1-1s0.447-1,1-1s1,0.447,1,1S8.553,15,8,15z M12,12H4V2h8V12z" /> </svg>`
            : '';
            
          return `
        <div style="display: flex; align-items: center; gap: 6px; margin: 4px 0;">
          <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${user.color};"></div>
          <span style="font-size: 10px; flex: 1; word-break: break-all; display: flex; align-items: center; ${isMe ? 'font-weight: bold; color: var(--fg);' : ''}">
            ${user.userName} ${isMe ? ' (–ê–∑)' : ''}
            ${mobileIcon}
          </span>
        </div>
      `}).join('')}
    `;

    // Also update header count to be consistent
    if (this.updateHeaderOnlineCount) {
        this.updateHeaderOnlineCount(count);
    }
  }

  async handleAdminCommand(commandObj) {
      const cmd = commandObj.substring(7).trim(); // Remove "/admin "

      if (cmd === 'deletechat') {
          if(confirm("‚ö† WARNING: This will delete ALL chat history globally! Are you sure?")) {
              await window.deleteAllChatMessages('admin');
          }
      }
  }

  async handleSendMessage() {
    const input = this.container.querySelector('.chat-input');
    const text = input.value;

    if (!text.trim()) return;

    // --- ADMIN COMMANDS ---
    if (text.startsWith('/admin ')) {
       await this.handleAdminCommand(text);
       input.value = '';
       return;
    }
    // ----------------------

    // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –∏–º–∞ reply
    const replyTo = input.dataset.replyTo;
    const replyAuthor = input.dataset.replyAuthor;

    const success = await this.chatFirebase.sendMessage(text, replyTo, replyAuthor);
    if (success) {
      input.value = '';
      input.dataset.replyTo = '';
      input.dataset.replyAuthor = '';
      
      // Reset textarea height after sending
      input.style.height = 'auto';
      
      input.focus();
      
      // –ü—Ä–µ–º–∞—Ö–Ω–∏ reply indicator
      const replyIndicator = this.container.querySelector('.reply-indicator');
      if (replyIndicator) replyIndicator.remove();
      
      // Realtime listener —â–µ —Å–µ –ø–æ–≥—Ä–∏–∂–∏ –∑–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ—Ç–æ (startPolling)
      // –ü—Ä–µ–º–∞—Ö–Ω–∞—Ö–º–µ —Ä—ä—á–Ω–æ—Ç–æ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º race conditions
    }
  }

  recalculateUnreadCount(messages) {
    // Helper to check if a message is from the current user
    const isMyMessage = (msg) => {
        return msg.userId === currentUser.userId || (currentUser.legacyChatId && msg.userId === currentUser.legacyChatId);
    };

    if (!this.lastReadMessageId) {
        // On first load, count all messages that are not from the current user.
        this.unreadCount = messages.filter(m => !isMyMessage(m)).length;
        return;
    }

    let readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
    
    // If marker is gone (deleted), try to recover using previous history
    if (readIndex === -1 && this.lastMessages.length > 0) {
        const oldIndex = this.lastMessages.findIndex(m => m.id === this.lastReadMessageId);
        if (oldIndex !== -1) {
            // Find a survivor preceding the deleted marker
            // Iterate backwards from oldIndex to find a survivor
            for (let i = oldIndex - 1; i >= 0; i--) {
                const predecessor = this.lastMessages[i];
                if (messages.find(m => m.id === predecessor.id)) {
                    this.lastReadMessageId = predecessor.id;
                    localStorage.setItem(`lastReadMessage_${this.documentId}`, this.lastReadMessageId);
                    readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
                    break;
                }
            }
        }
        
        // If still not found (e.g. all preceding messages deleted too, or never found), reset to 0
        // Because if the marker is gone, we assume the user was up to date.
        if (readIndex === -1) {
             this.unreadCount = 0;
             return;
        }
    }
    
    // Calculate unread
    if (readIndex !== -1) {
        const newMessages = messages.slice(readIndex + 1);
        // Count only new messages that are not from the current user
        this.unreadCount = newMessages.filter(m => !isMyMessage(m)).length;
    } else {
        // Fallback: count all messages not from the current user
        this.unreadCount = messages.filter(m => !isMyMessage(m)).length;
    }
  }

  renderMessages(messages) {
    const messagesContainer = this.container.querySelector('.chat-messages');
    if (!messagesContainer) return;

    const scrollWasAtBottom = this.autoScroll ||
      messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 50;

    // Always do a full re-render to ensure all data (like names) is up-to-date.
    // This is simpler and more reliable than complex diffing, matching the working logic from notes-init.js.
    this.fullRenderMessages(messages, messagesContainer);

    this.recalculateUnreadCount(messages);
    this.updateActiveCount();
    this.lastMessages = messages;

    if (scrollWasAtBottom) {
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 0);
    }
  }

  fullRenderMessages(messages, messagesContainer) {
    messagesContainer.innerHTML = '';
    
    // –î–æ–±–∞–≤–∏ –≤—Å–∏—á–∫–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –µ–¥–∏–Ω –ø–æ –µ–¥–∏–Ω (incremental)
    messages.forEach(msg => {
      const messageEl = this.createMessageElement(msg, messages);
      messagesContainer.appendChild(messageEl);
      this.attachMessageListeners(messageEl);
    });

    // –°–ª–µ–¥ –∫–∞—Ç–æ –≤—Å–∏—á–∫–∏ —Å–∞ –≤ DOM, —Ä–µ–Ω–¥–∏—Ä–∞–π —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ –æ—Ç –∫–µ—à–∞
    this.renderAllReactions();
  }

  createMessageElement(msg, messagesMap) {
    const messagesMapObj = {};
    (messagesMap || []).forEach(m => {
      messagesMapObj[m.id] = m;
    });

    // –ê–∫–æ –∏–º–∞ reply, –Ω–∞–º–µ—Ä–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–æ—Ç–æ —Å—ä–æ–±—â–µ–Ω–∏–µ
    let replyHTML = '';
    if (msg.replyTo && messagesMapObj[msg.replyTo]) {
      const originalMsg = messagesMapObj[msg.replyTo];
      replyHTML = `
         <div style="background: #f1f5f9; border-left: 3px solid #cbd5e1; padding: 4px 8px; margin-bottom: 4px; font-size: 11px; border-radius: 4px; opacity: 0.8;">
           <b>${this.escapeHtml(msg.replyAuthor || 'Someone')}:</b> ${this.linkifyText(originalMsg.text.substring(0, 50))}...
         </div>
      `;
    }

    const resolvedName = this.resolveName(msg.userName);

    const isCurrentUser = (currentUser.userId && msg.userId === currentUser.userId) || (currentUser.legacyChatId && msg.userId === currentUser.legacyChatId);
    const messageBgColor = isCurrentUser ? '#e0f2fe' : 'var(--chat-secondary)'; // Keep visual distinction

    // Reactions are now rendered from cache, so the initial div is populated
    const reactionsHTML = this.getReactionsHTML(msg.id);

    const htmlString = `
      <div class="chat-message" data-user-id="${msg.userId}" data-message-id="${msg.id}" data-message-key="${msg.key}" style="position: relative;">
        <div class="message-content">
          <div class="message-header">
            <span class="message-author">${this.escapeHtml(resolvedName)}</span>
            <span class="message-time">${this.formatTime(msg.timestamp)}</span>
          </div>
          ${replyHTML}
          <div class="message-text" style="background-color: ${messageBgColor};">${this.linkifyText(msg.text)}</div>
          <div class="message-reactions" data-message-id="${msg.id}">${reactionsHTML}</div>
        </div>
        <div class="message-actions">
         <button class="message-reply-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–û—Ç–≥–æ–≤–æ—Ä–∏">
            <img src="svg/reply-svgrepo-com.svg" alt="Reply" style="width: 100%; height: 100%; opacity: 0.7; filter: invert(0.3);">
          </button>
           <button class="message-reaction-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–î–æ–±–∞–≤–∏ —Ä–µ–∞–∫—Ü–∏—è">
            <img src="svg/reaction-emoji-add-svgrepo-com.svg" alt="Reaction" style="width: 100%; height: 100%; opacity: 0.7;">
          </button>
          ${isCurrentUser ? `<button class="message-delete-btn" data-message-key="${msg.key}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–ò–∑—Ç—Ä–∏–π —Å—ä–æ–±—â–µ–Ω–∏–µ">
            <img src="svg/trash-blank-alt-svgrepo-com.svg" alt="Delete" style="width: 100%; height: 100%; opacity: 0.6;">
          </button>` : ''}
        </div>
      </div>
    `;

    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    // Attach listeners to reaction badges immediately after creation
    this.attachReactionBadgeListeners(temp.firstElementChild);
    return temp.firstElementChild;
  }

  attachMessageListeners(msgEl) {
    // Hover effect now handled by CSS (.chat-message:hover .message-actions)

    // –î–æ–±–∞–≤–∏ listener –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    const reactionBtn = msgEl.querySelector('.message-reaction-btn');
    if (reactionBtn) {
      reactionBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.showReactionPicker(msgEl.dataset.messageId);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ reply
    const replyBtn = msgEl.querySelector('.message-reply-btn');
    if (replyBtn) {
      replyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.startReply(msgEl.dataset.messageId, msgEl);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ delete
    const deleteBtn = msgEl.querySelector('.message-delete-btn');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const messageKey = deleteBtn.dataset.messageKey;
        this.deleteMessage(messageKey);
      });
    }
  }

  updateHeaderOnlineCount(count) {
    const onlineCountEl = this.container.querySelector('.chat-online-count');
    if (onlineCountEl) {
        onlineCountEl.textContent = `üü¢ ${count || 1} Online`;
    }
  }

  updateActiveCount(data) {
    const badgeEl = document.querySelector('.chat-badge-count');
    
    // –ü–æ–∫–∞–∑–∏ –±—Ä–æ–π –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –°–ê–ú–û –∞–∫–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ç–∞ —Å–∞ –≤–∫–ª—é—á–µ–Ω–∏ –ò —á–∞—Ç—ä—Ç –µ –∑–∞—Ç–≤–æ—Ä–µ–Ω
    if (badgeEl) {
      if (this.notificationsDisabled || this.isOpen) {
        badgeEl.style.display = 'none';
      } else {
        badgeEl.textContent = this.unreadCount;
        badgeEl.style.display = this.unreadCount > 0 ? 'flex' : 'none';
      }
    }
  }

  // updateNotificationButton removed (duplicate logic)


  updateActiveSidebar(users) {
    const sidebarEl = this.container.querySelector('.chat-active-users');
    if (!sidebarEl) return;

    const usersList = Object.values(users).slice(0, 5);
    sidebarEl.innerHTML = `
      <div class="active-users-header">–ê–∫—Ç–∏–≤–Ω–∏ —Å–µ–≥–∞:</div>
      ${usersList.map(user => `
        <div class="active-user" title="${user.userName}">
          <div class="active-user-badge" style="background-color: ${user.color}">
            ${user.userName.charAt(0)}
          </div>
          <span>${user.userName}</span>
        </div>
      `).join('')}
    `;
  }

  showNotification() {
    const icon = document.querySelector('.chat-icon');
    if (icon) {
      icon.classList.add('has-notification');
      setTimeout(() => {
        icon.classList.remove('has-notification');
      }, 3000);
    }
  }

  markAsRead() {
    const messages = this.chatFirebase.messages;
    if (messages.length > 0) {
      const lastMessage = messages[messages.length - 1];
      const newLastReadId = lastMessage.id;

      // –ê–∫–æ –≤–µ—á–µ –µ –º–∞—Ä–∫–∏—Ä–∞–Ω–æ –∫–∞—Ç–æ –ø—Ä–æ—á–µ—Ç–µ–Ω–æ, –Ω–µ –ø—Ä–∞–≤–∏ –Ω–∏—â–æ
      if (this.lastReadMessageId === newLastReadId) return;

      this.lastReadMessageId = newLastReadId;
      localStorage.setItem(`lastReadMessage_${this.documentId}`, newLastReadId);
      this.unreadCount = 0;
      this.updateActiveCount();
      
      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞–π —Å Firebase, –∑–∞ –¥–∞ –∑–Ω–∞—è—Ç –∏ –¥—Ä—É–≥–∏—Ç–µ —Å–µ—Å–∏–∏
      this.chatFirebase.setLastRead(currentUser.userName, newLastReadId);
    }
  }

  showReactionPicker(messageId) {
    // –ü—Ä–µ–º–∞—Ö–Ω–∏ —Å—Ç–∞—Ä picker –∞–∫–æ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
    const oldPicker = document.querySelector('.reaction-picker');
    if (oldPicker) oldPicker.remove();

    const emojis1 = ['üëç', 'üëé', 'üòÇ', '‚ù§Ô∏è', 'üòÆ', 'üêê'];
    const emojis2 = ['–ê', '–ë', '–í', '–ì', '–î', '–ï'];
    
    const picker = document.createElement('div');
    picker.className = 'reaction-picker';
    picker.style.cssText = `
      position: fixed;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 10000;
    `;

    const addEmojiButton = (emoji, messageId) => {
      const btn = document.createElement('button');
      btn.textContent = emoji;
      btn.style.cssText = `
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 2px 4px;
      `;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.addReaction(messageId, emoji);
        picker.remove();
        document.removeEventListener('click', closePicker);
      });
      return btn;
    };

    // –ü—ä—Ä–≤–∏ —Ä–µ–¥ –µ–º–æ–¥–∂–∏
    const row1 = document.createElement('div');
    row1.style.cssText = 'display: flex; gap: 4px; justify-content: space-around;';
    emojis1.forEach(emoji => {
      row1.appendChild(addEmojiButton(emoji, messageId));
    });
    picker.appendChild(row1);

    // –í—Ç–æ—Ä–∏ —Ä–µ–¥ –±—É–∫–≤–∏
    const row2 = document.createElement('div');
    row2.style.cssText = 'display: flex; gap: 4px; justify-content: space-around;';
    emojis2.forEach(emoji => {
      row2.appendChild(addEmojiButton(emoji, messageId));
    });
    picker.appendChild(row2);

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π picker –¥–æ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
    const msgEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (msgEl) {
      const rect = msgEl.getBoundingClientRect();
      picker.style.left = (rect.left + 50) + 'px';
      picker.style.top = (rect.top - 60) + 'px';
      document.body.appendChild(picker);
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ picker
    const closePicker = (e) => {
      // –ê–∫–æ –∫–ª–∏–∫–Ω–µ—à –∏–∑–≤—ä–Ω picker-–∞ - –∑–∞—Ç–≤–æ—Ä–∏
      if (!picker.contains(e.target) && !e.target.closest('[data-message-id]')) {
        picker.remove();
        document.removeEventListener('click', closePicker);
      }
    };
    
    // –î–æ–±–∞–≤–∏ listener –∑–∞ –≤—Å–µ–∫–∏ –∫–ª–∏–∫
    document.addEventListener('click', closePicker);
  }

  async addReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.addReaction(messageId, emoji);
  }

  renderAllReactions() {
    if (!this.reactionsCache) return;
    
    const messageElements = this.container.querySelectorAll('.chat-message[data-message-id]');
    messageElements.forEach(msgEl => {
        const messageId = msgEl.dataset.messageId;
        const reactionsContainer = msgEl.querySelector('.message-reactions');
        if (reactionsContainer) {
            reactionsContainer.innerHTML = this.getReactionsHTML(messageId);
            this.attachReactionBadgeListeners(msgEl);
        }
    });
  }

  getReactionsHTML(messageId) {
    const reactionsForMessage = this.reactionsCache ? this.reactionsCache[messageId] : null;
    if (!reactionsForMessage) return '';

    const reactionCounts = {};
    const myReactions = {};
    
    const myUserIds = this._getMyUserIds(); // –í–∑–µ–º–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ userId-—Ç–∞

    Object.keys(reactionsForMessage).forEach(emoji => {
        const usersObj = reactionsForMessage[emoji] || {};
        const userIdsWhoReacted = Object.keys(usersObj).filter(userId => usersObj[userId] === true);
        const count = userIdsWhoReacted.length;
        
        if (count > 0) {
            reactionCounts[emoji] = count;
            // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –Ω—è–∫–æ–µ –æ—Ç –º–æ–∏—Ç–µ userId-—Ç–∞ –µ —Ä–µ–∞–≥–∏—Ä–∞–ª–æ
            if (userIdsWhoReacted.some(id => myUserIds.includes(id))) {
                myReactions[emoji] = true;
            }
        }
    });
      
    if (Object.keys(reactionCounts).length === 0) {
        return '';
    }

    return Object.keys(reactionCounts).map(emoji => `
        <button class="reaction-badge" data-emoji="${emoji}" data-message-id="${messageId}" 
          style="background: ${myReactions[emoji] ? '#93c5fd' : '#f0f0f0'}; border: none; border-radius: 12px; padding: 4px 8px; margin-right: 4px; cursor: pointer; font-size: 12px; font-weight: ${myReactions[emoji] ? 'bold' : 'normal'};">
          ${emoji} <span>${reactionCounts[emoji]}</span>
        </button>
      `).join('');
  }

  attachReactionBadgeListeners(element) {
    const container = element.querySelector('.message-reactions');
    if (!container) return;

    container.querySelectorAll('.reaction-badge').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const emoji = btn.dataset.emoji;
        const msgId = btn.dataset.messageId;
        
        const reactionsForMessage = this.reactionsCache ? this.reactionsCache[msgId] : null;
        if (!reactionsForMessage) {
            this.addReaction(msgId, emoji);
            return;
        }

        const myUserIds = this._getMyUserIds();
        const reactorsForEmoji = reactionsForMessage[emoji] || {};
        
        const myReactingIds = myUserIds.filter(id => reactorsForEmoji[id] === true);

        if (myReactingIds.length > 0) {
          // –ü—Ä–µ–º–∞—Ö–Ω–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ —Ä–µ–∞–∫—Ü–∏–∏ –∑–∞ —Ç–æ–≤–∞ –µ–º–æ–¥–∂–∏
          this.chatFirebase.bulkRemoveReactions(msgId, emoji, myReactingIds);
        } else {
          // –î–æ–±–∞–≤–∏ –Ω–æ–≤–∞ —Ä–µ–∞–∫—Ü–∏—è
          this.addReaction(msgId, emoji);
        }
      });
    });
  }

  async removeReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.removeReaction(messageId, emoji);
  }

  startReply(messageId, messageEl) {
    // –ù–∞–º–µ—Ä–∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
    const textEl = messageEl.querySelector('.message-text');
    const authorEl = messageEl.querySelector('.message-author');
    
    if (!textEl || !authorEl) return;

    const author = authorEl.textContent;
    const text = textEl.textContent;

    // –ü–æ—Å—Ç–∞–≤–∏ reply –∏–Ω—Ñ–æ –≤ input –ø–æ–ª–µ
    const input = this.container.querySelector('.chat-input');
    if (input) {
      input.dataset.replyTo = messageId;
      input.dataset.replyAuthor = author;
      input.dataset.replyText = text;
      
      // –î–æ–±–∞–≤—è–π –≤–∏–∑—É–∞–ª–Ω–∞ –∏–Ω–¥–∏–∫–∞—Ü–∏—è
      const inputArea = this.container.querySelector('.chat-input-area');
      // Ensure layout is fixed before adding indicator
      this.fixInputLayout();
      
      let replyIndicator = inputArea.querySelector('.reply-indicator');
      
      if (!replyIndicator) {
        replyIndicator = document.createElement('div');
        replyIndicator.className = 'reply-indicator';
        inputArea.prepend(replyIndicator);
      }

      replyIndicator.style.cssText = `
        background: #f1f5f9; border-left: 3px solid #3b82f6;
        padding: 8px; margin-bottom: 8px; border-radius: 4px;
        font-size: 12px; display: flex; justify-content: space-between; align-items: center;
      `;

      replyIndicator.innerHTML = `
        <span>–û—Ç–≥–æ–≤–∞—Ä—è—à –Ω–∞ <b>${this.escapeHtml(author)}</b></span>
        <button onclick="const input = this.closest('.chat-input-area').querySelector('.chat-input'); if(input) { input.dataset.replyTo=''; input.dataset.replyAuthor=''; } this.closest('.reply-indicator').remove();" style="border:none;background:none;cursor:pointer;font-size:14px;color:#64748b;">‚úñ</button>
      `;

      input.focus();
    }
  }

  toggleChat() {
    if (!this.container) {
      console.error('Container –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }
    this.isOpen = !this.isOpen;
    const chatPanel = this.container.querySelector('.chat-panel');
    if (chatPanel) {
      chatPanel.classList.toggle('open', this.isOpen);
      if (this.isOpen) {
        const input = this.container.querySelector('.chat-input');
        if (input) input.focus();
        
        // –ú–∞—Ä–∫–∏—Ä–∞–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞ –∫–∞—Ç–æ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏
        this.markAsRead();
      }
    }
  }

  formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  linkifyText(text) {
    // –†–∞–∑–ø–æ–∑–Ω–∞–∏ URL-–∏ –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–π –≥–∏ –≤ –ª–∏–Ω–∫–æ–≤–µ
    const escaped = this.escapeHtml(text);
    // –ü—ä—Ä–≤–æ –∑–∞–º–µ–Ω–∏ –Ω–æ–≤–∏—Ç–µ —Ä–µ–¥–æ–≤–µ —Å <br>
    const withBreaks = escaped.replace(/\n/g, '<br>');
    // –°–ª–µ–¥ —Ç–æ–≤–∞ –¥–æ–±–∞–≤–∏ –ª–∏–Ω–∫–æ–≤–µ—Ç–µ
    const urlRegex = /(https?:\/\/[^\s<>\[\]{}|\\^`"]*)/g;
    return withBreaks.replace(urlRegex, (url) => {
      return `<a href="${url}" target="_blank" style="color: #4ade80; text-decoration: underline; cursor: pointer;">${url}</a>`;
    });
  }

  async deleteMessage(messageKey) {
        if (await this.chatFirebase.deleteMessage(messageKey)) {
            // –ü—Ä–µ–º–∞—Ö–Ω–∏ –ª–æ–∫–∞–ª–Ω–æ –≤–µ–¥–Ω–∞–≥–∞ —Å –∞–Ω–∏–º–∞—Ü–∏—è
            const messagesContainer = this.container.querySelector('.chat-messages');
            const messageEl = messagesContainer.querySelector(`[data-message-key="${messageKey}"]`);
            if (messageEl) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    messageEl.remove();
                }, 300);
            }
        } else {
            console.error('Failed to delete message via SDK');
        }
  }

  destroy() {
    this.chatFirebase.stop();
  }
}

// ============================================
// PART 4: INITIALIZATION
// ============================================

(async function initializeChat() {
  console.log('Chat init...');

  // Wait for the user identity to be resolved before doing anything else
  await window.currentUserPromise;
  
  let attempts = 0;
  const maxAttempts = 20;

  function tryInit() {
    attempts++;

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initChat);
    } else if (attempts < maxAttempts) {
      if (document.getElementById('chat-widget')) {
        initChat();
      } else {
        // Keep trying if widget is not yet in DOM
        setTimeout(tryInit, 100);
      }
    }
  }

  function initChat() {
    console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º Chat UI...');
    
    const chatWidget = document.getElementById('chat-widget');
    if (!chatWidget) {
      console.error('Chat widget –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }

    // –ì–õ–û–ë–ê–õ–ï–ù –ß–ê–¢ –ó–ê –í–°–ò–ß–ö–ò –°–ê–ô–¢–û–í–ï
    const documentId = 'global-chat';

    let chatManager;
    try {
      chatManager = new ChatUIManager('chat-widget', documentId);
      window.chatManager = chatManager;
      console.log('‚úì‚úì‚úì Chat —Å–∏—Å—Ç–µ–º–∞ –ì–û–¢–û–í–ê!');
    } catch (error) {
      console.error('Chat init error:', error);
      return;
    }

    const chatIcon = document.getElementById('chat-toggle');
    if (chatIcon) {
      chatIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üí¨ Click');
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const chatCloseBtn = document.getElementById('chat-close');
    if (chatCloseBtn) {
      chatCloseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const currentUserNameEl = document.getElementById('current-user-name');
    if (currentUserNameEl && window.currentUser) {
      currentUserNameEl.textContent = window.currentUser.userName;
    }

    console.log('–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª:', window.currentUser.userName);
  }

  tryInit();
})();

// ============================================
// GLOBAL RESET FUNCTION - –¥–æ—Å—Ç—ä–ø–Ω–∞ –æ—Ç–≤—Å—è–∫—ä–¥–µ
// ============================================

window.resetChat = function() {
  localStorage.removeItem('userId');
  localStorage.removeItem('userName');
  localStorage.removeItem('userColor');
  console.log('‚úÖ –†–µ—Å–µ—Ç –∑–∞–≤—ä—Ä—à–µ–Ω! –ù–∞–ø–∏—à–∏ –≤ –∫–æ–Ω—Å–æ–ª–∞—Ç–∞: location.reload()');
};

window.deleteAllChatMessages = async function(password) {
  if (!password) {
    console.error('‚ùå –ü–∞—Ä–æ–ª–∞ –Ω–µ –µ –¥–∞–¥–µ–Ω–∞! –ò–∑–ø–æ–ª–∑–≤–∞–π: window.deleteAllChatMessages("admin")');
    return false;
  }

  if (password !== 'admin') {
    console.error('‚ùå –ì–†–ï–®–ù–ê –ü–ê–†–û–õ–ê!');
    return false;
  }

  try {
    const baseURL = 'https://med-student-chat-default-rtdb.europe-west1.firebasedatabase.app';
    const messagesRef = `${baseURL}/messages/global-chat.json`; // Fix: target global-chat
    const reactionsRef = `${baseURL}/reactions/global-chat.json`; // Fix: target global-chat

    // –ò–∑—Ç—Ä–∏–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞
    const msgResponse = await fetch(messagesRef, { method: 'DELETE' });
    if (!msgResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞');

    // –ò–∑—Ç—Ä–∏–π —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ
    const reactResponse = await fetch(reactionsRef, { method: 'DELETE' });
    if (!reactResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ');

    console.log('‚úÖ –ß–ê–¢ –ò–ó–¢–†–ò–¢ –£–°–ü–ï–®–ù–û! –í—Å–∏—á–∫–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –∏ —Ä–µ–∞–∫—Ü–∏–∏ —Å–∞ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç–∏.');
    console.log('üí° –ù–∞–ø–∏—à–∏: location.reload() –∑–∞ –¥–∞ –≤–∏–¥–∏—à –ø—Ä–æ–º–µ–Ω–∏—Ç–µ');
    return true;
  } catch (error) {
    console.error('‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —á–∞—Ç–∞:', error);
    return false;
  }
};

console.log('üí° –ö–æ–º–∞–Ω–¥–∏: resetChat() - —Ä–µ—Å–µ—Ç –Ω–∞ –∏–º–µ');

// Cache buster
const CHAT_VERSION = '20260122_v2';
