// ============================================
// COMPLETE CHAT SYSTEM - ONE FILE
// Firebase REST API + UI + User Management
// ============================================

// (Chat system initialized)

// ============================================
// PART 1: USER INITIALIZATION
// ============================================

// The `currentUser` object is now created in `js/user-identity.js` and is globally available.
// This file assumes `user-identity.js` has been loaded.

// ============================================
// PART 2: FIREBASE REST API
// ============================================

class ChatFirebaseREST {
  constructor(documentId) {
    this.documentId = documentId || 'default';
    this.messages = [];
    this.listeners = [];
    this.isPolling = false;
    this.unsubscribers = [];
    this.heartbeatInterval = null;
    
    // Firebase is now initialized globally by calendar.html, so no need for config here.

    // console.log('Using Firebase SDK Wrapper'); // Can be removed
    this.initSDK();
  }

  async initSDK() {
    // If the global firebase object is already available, use it.
    if (typeof firebase !== 'undefined') {
        this.initApp(firebase);
        return;
    } else {
        console.error("Firebase SDK not loaded globally. Please ensure firebase-app-compat.js and firebase-database-compat.js are loaded BEFORE chat.js and firebase.initializeApp() is called.");
    }
  }

  initApp(firebaseInstance) {
    try {
      // Assume app is already initialized globally. Just get the default app.
      const app = firebaseInstance.app();
      this.db = firebaseInstance.database();
      // console.log('‚úì Firebase SDK Initialized'); // Can be removed
    } catch (e) {
      console.error("Firebase Init Error: Ensure Firebase is initialized globally in the HTML.", e);
    }
  }

  async _ensureInit() {
    if (this.db) return;
    // If initSDK didn't run or failed, try again with global firebase.
    // This provides a fallback if initSDK was called prematurely or firebase wasn't ready.
    if (typeof firebase !== 'undefined' && !this.db) {
        this.initApp(firebase);
        if (this.db) return; // If successful now
    }
    // If still not initialized, something is wrong.
    throw new Error("Firebase not initialized. Check SDK loading and configuration.");
  }

  async sendMessage(text, replyTo = null, replyAuthor = null) {
    if (!text.trim()) return false;
    await this._ensureInit();

    const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
    
    const message = {
      userId: currentUser.userId,
      userName: currentUser.userName,
      userColor: currentUser.color,
      userAvatar: currentUser.avatar || null, // Add avatar
      text: text.trim(),
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      // id will be generated by key
    };

    if (replyTo && replyAuthor) {
      message.replyTo = replyTo;
      message.replyAuthor = replyAuthor;
    }

    try {
      const newMessageRef = messagesRef.push();
      await newMessageRef.set(message);
      return true;
    } catch (error) {
      console.error('SDK Send error:', error);
      return false;
    }
  }

  async updateMessage(messageKey, data) {
    await this._ensureInit();
    const messageRef = firebase.database().ref(`messages/${this.documentId}/${messageKey}`);
    try {
      await messageRef.update(data);
      return true;
    } catch (error) {
      console.error('SDK Update error:', error);
      return false;
    }
  }

  async loadMessages() {
    // –í SDK —Ä–µ–∂–∏–º, —Ç–æ–≤–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Ä—è–¥–∫–æ, –∑–∞—â–æ—Ç–æ startPolling –ø–æ–¥–¥—ä—Ä–∂–∞ –≤—Å–∏—á–∫–æ
    await this._ensureInit();
    
    try {
      const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
      // Limit to last 500 to prevent lagging
      const q = messagesRef.orderByChild('timestamp').limitToLast(500);
      
      const snapshot = await q.once('value');
      if (!snapshot.exists()) return [];
      
      const data = snapshot.val();
      const messages = Object.keys(data).map(key => ({
        ...data[key],
        key: key,
        id: key
      }));

      // Sort
      messages.sort((a, b) => a.timestamp - b.timestamp);
      this.messages = messages;
      return messages;
    } catch (error) {
      console.error('SDK Load error:', error);
      return [];
    }
  }

  async bulkUpdate(updates) {
    await this._ensureInit();
    try {
        await firebase.database().ref().update(updates);
        return true;
    } catch (error) {
        console.error('SDK Bulk Update error:', error);
        return false;
    }
  }

  async updateNameMapping(oldName, newName) {
    await this._ensureInit();
    const mappingRef = firebase.database().ref(`name_mappings/${oldName}`);
    try {
        await mappingRef.set(newName);
        return true;
    } catch (error) {
        console.error('SDK updateNameMapping error:', error);
        return false;
    }
  }

  async getNameMappings() {
    await this._ensureInit();
    try {
        const snapshot = await firebase.database().ref(`name_mappings`).once('value');
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  startNameMappingsPolling(callback) {
    this._ensureInit().then(() => {
        const mappingsRef = firebase.database().ref(`name_mappings`);

        const unsubscribe = mappingsRef.on('value', (snapshot) => {
            const mappings = snapshot.val() || {};
            callback(mappings);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getProtectedNames() {
    await this._ensureInit();
    try {
        const snapshot = await firebase.database().ref(`protected_names`).once('value');
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  async protectName(name, password) {
    await this._ensureInit();
    const protectedNameRef = firebase.database().ref(`protected_names/${name}`);
    try {
        await protectedNameRef.set(password); // In a real app, hash the password
        return true;
    } catch (error) {
        console.error('SDK protectName error:', error);
        return false;
    }
  }

  async setTyping(isTyping) {
    await this._ensureInit();
    // Use a disconnect handler to remove typing status if user closes tab
    const typingRef = firebase.database().ref(`typing/${this.documentId}/${currentUser.userId}`);
    try {
        if (isTyping) {
            await typingRef.set({
                userName: currentUser.userName,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            // Ensure it's removed on disconnect
            typingRef.onDisconnect().remove();
        } else {
            await typingRef.remove();
            typingRef.onDisconnect().cancel();
        }
    } catch (e) {
        console.error("SDK setTyping error:", e);
    }
  }

  startTypingPolling(callback) {
    this._ensureInit().then(() => {
        const typingRef = firebase.database().ref(`typing/${this.documentId}`);
        const unsubscribe = typingRef.on('value', (snapshot) => {
            const typingData = snapshot.val() || {};
            // Filter out stale typing indicators (older than 10 seconds)
            const activeTyping = {};
            const now = Date.now();
            
            Object.keys(typingData).forEach(userId => {
                const data = typingData[userId];
                // Check if data is object and has timestamp, or just handle simple case
                // We stored object above.
                if (data && data.timestamp && (now - data.timestamp < 10000) && userId !== String(currentUser.userId)) {
                    activeTyping[userId] = data.userName;
                }
            });
            
            callback(activeTyping);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  startPolling(callback, interval = 2000) {
    if (this.isPolling) return;
    this.isPolling = true;

    this._ensureInit().then(() => {
        const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
        // Realtime Listener
        const q = messagesRef.orderByChild('timestamp').limitToLast(500);

        const unsubscribe = q.on('value', (snapshot) => {
            const messages = [];
            snapshot.forEach((child) => {
                const val = child.val();
                messages.push({
                    ...val,
                    key: child.key,
                    id: child.key,
                    // Handle serverTimestamp properly if it's still processing (can be null briefly)
                    timestamp: val.timestamp || Date.now()
                });
            });
            
            // Check for new messages for notifications
            if (messages.length > 0) {
                 const lastMsg = messages[messages.length - 1];
                 // Initialize on first data arrival
                 if (!this.lastNotifiedId) {
                     this.lastNotifiedId = lastMsg.id;
                 } else if (lastMsg.id > this.lastNotifiedId) {
                     // Firebase IDs are chronological, so newId > oldId means addition
                     this.lastNotifiedId = lastMsg.id;
                     this.listeners.forEach(listener => listener(lastMsg));
                 } else if (lastMsg.id < this.lastNotifiedId) {
                     // A deletion happened at the end of the list, update tracker without notifying
                     this.lastNotifiedId = lastMsg.id;
                 }
            } // Can be removed, frequent

            this.messages = messages;
            callback(messages);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  addMessageListener(callback) {
    this.listeners.push(callback);
  }

  async updateColorForAllSessions(newColor) {
    // This functionality is mostly for updating the *chat-specific* presence entry,
    // which we are removing. So this function can be removed or adapted.
    // For now, removing.
    console.warn("updateColorForAllSessions is no longer relevant with site-wide presence.");
  }

  // forceUpdatePresence removed

  // markUserActive removed

  // getActiveUsers removed

  async deleteMessage(messageKey) {
    await this._ensureInit();
    try {
        const messageRef = firebase.database().ref(`messages/${this.documentId}/${messageKey}`);
        await messageRef.remove();
        return true;
    } catch (e) {
        console.error("SDK deleteMessage error:", e);
        return false;
    }
  }

  async setLastRead(userName, messageId) {
    if (!userName || !messageId) return false;
    // Note: Firebase keys can't contain ., $, #, [, ], /, or ASCII control chars 0-31 or 127.
    // Sanitize userName to be a safe key.
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    await this._ensureInit();
    const lastReadRef = firebase.database().ref(`last_read/${this.documentId}/${safeUserName}`);
    try {
        await lastReadRef.set(messageId);
        return true;
    } catch (error) {
        console.error('SDK setLastRead error:', error);
        return false;
    }
  }

  startLastReadPolling(userName, callback) {
    if (!userName) return;
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    this._ensureInit().then(() => {
        const lastReadRef = firebase.database().ref(`last_read/${this.documentId}/${safeUserName}`);

        const unsubscribe = lastReadRef.on('value', (snapshot) => {
            const lastReadId = snapshot.val();
            if (lastReadId) {
                callback(lastReadId);
            } // Can be removed, frequent
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getReactions(messageId) {
    await this._ensureInit();
    try {
      const snapshot = await firebase.database().ref(`reactions/${this.documentId}/${messageId}`).once('value');
      return snapshot.exists() ? snapshot.val() : null;
    } catch (e) {
      console.error("SDK getReactions error:", e);
      return null;
    }
  }

  async addReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, true);
  }

  async removeReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, false);
  }

  async setReaction(messageId, emoji, value) {
    await this._ensureInit();
    try {
      // Use set with false to "remove" (logically) or null/remove to physically remove?
      // The original code used PUT with true/false, establishing a schema where key=userId, value=true/false
      // path: reactions/docId/msgId/emoji/userId = true/false
      const reactionRef = firebase.database().ref(`reactions/${this.documentId}/${messageId}/${emoji}/${currentUser.userId}`);
      
      // If value is false, maybe we should remove the node to keep DB clean, 
      // but original code sent 'false'. Let's stick to user logic or improve it.
      // Actually, removing it is better for counting.
      if (value) {
          await reactionRef.set(true);
      } else {
          await reactionRef.set(null); // Remove the node
      }
      return true;
    } catch (e) {
      console.error("SDK setReaction error:", e);
      return false;
    }
  }

  async bulkRemoveReactions(messageId, emoji, userIds) {
    if (!userIds || userIds.length === 0) return true;
    await this._ensureInit();
    const updates = {};
    userIds.forEach(id => {
        updates[`reactions/${this.documentId}/${messageId}/${emoji}/${id}`] = null;
    });
    try {
        await firebase.database().ref().update(updates);
        return true;
    } catch (e) {
        console.error("SDK bulkRemoveReactions error:", e);
        return false;
    }
  }

  startReactionsPolling(callback) {
    this._ensureInit().then(() => {
        const reactionsRef = firebase.database().ref(`reactions/${this.documentId}`);

        const unsubscribe = reactionsRef.on('value', (snapshot) => {
            const reactions = snapshot.val() || {};
            callback(reactions);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  startSiteWidePresencePolling(callback) {
    this._ensureInit().then(() => {
        const onlineUsersRef = firebase.database().ref('online_users');
        const onlineGuestsRef = firebase.database().ref('online_guests');
        const siteUsersRef = firebase.database().ref('site_users');
        const offsetRef = firebase.database().ref(".info/serverTimeOffset");

        let serverTimeOffset = 0;
        offsetRef.on("value", (snap) => {
            serverTimeOffset = snap.val() || 0;
        });

        let allSiteUsers = {};     
        let allOnlineAuthData = {}; 
        let allOnlineGuestData = {}; 

        const processAndCallback = () => {
                const groupedUsers = {};
                const now = Date.now() + serverTimeOffset;
                const GRACE_PERIOD = 2 * 60 * 1000; // 2 minutes

                const isUserOnline = (devices) => {
                    return Object.values(devices).some(device => {
                        // 1. Truly active - most important check
                        if (device.isActive === true) {
                            return true;
                        }
                        
                        // 2. Recently active (within 30 seconds) - for transitions
                        if (device.lastActivity && (now - device.lastActivity) < 30000) {
                            return true;
                        }
                        
                        // 3. Grace period for backgrounded tabs
                        if (device.lastInactive && (now - device.lastInactive) < GRACE_PERIOD) {
                            return true;
                        }
                        
                        // 4. Grace period for disconnected devices
                        if (device.offlineAt && (now - device.offlineAt) < GRACE_PERIOD) {
                            return true;
                        }
                        
                        return false;
                    });
                };

                // ... (rest of processing)
                // Process Authenticated Users
                for (const uid in allOnlineAuthData) {
                    const devices = allOnlineAuthData[uid];
                    
                    // Get most recent activity/offline timestamp from all devices
                    let lastActivity = 0;
                    Object.values(devices).forEach(device => {
                        if (device.lastActivity && device.lastActivity > lastActivity) {
                            lastActivity = device.lastActivity;
                        }
                        if (device.timestamp && device.timestamp > lastActivity) {
                            lastActivity = device.timestamp;
                        }
                        if (device.offlineAt && device.offlineAt > lastActivity) {
                            lastActivity = device.offlineAt;
                        }
                        if (device.lastInactive && device.lastInactive > lastActivity) {
                            lastActivity = device.lastInactive;
                        }
                    });
                    
                    if (isUserOnline(devices)) {
                        const deviceIds = Object.keys(devices);
                        const deviceCount = deviceIds.length;
                        const hasMobile = deviceIds.some(deviceId => devices[deviceId].isMobile === true);
                        
                        const userProfile = allSiteUsers[uid];
                        if (userProfile) {
                            groupedUsers[uid] = {
                                userId: uid,
                                userName: userProfile.displayName || userProfile.username,
                                color: userProfile.color,
                                avatar: userProfile.avatar,
                                isAdmin: userProfile.isAdmin || false,
                                deviceCount: deviceCount,
                                hasMobile: hasMobile,
                                isGuest: false,
                                lastActivity: lastActivity
                            };
                        } else {
                            groupedUsers[uid] = {
                                userId: uid,
                                userName: `Unknown User (${uid})`,
                                color: '#cccccc',
                                deviceCount: deviceCount,
                                hasMobile: hasMobile,
                                isGuest: false,
                                lastActivity: lastActivity
                            };
                        }
                    } else if (allSiteUsers[uid] && lastActivity > 0) {
                        // Store offline users with their last activity for "Last seen" feature
                        // Only update if we have a valid timestamp (don't overwrite with 0)
                        const userProfile = allSiteUsers[uid];
                        allSiteUsers[uid] = {
                            ...userProfile,
                            lastActivity: lastActivity
                        };
                    }
                }

                // Process Guest Users
                for (const guestId in allOnlineGuestData) {
                    const devices = allOnlineGuestData[guestId];
                    if (isUserOnline(devices)) {
                        const deviceIds = Object.keys(devices);
                        const deviceCount = deviceIds.length;
                        const hasMobile = deviceIds.some(deviceId => devices[deviceId].isMobile === true);
                        
                        const sampleDeviceData = devices[deviceIds[0]]; 
                        const guestUserName = sampleDeviceData.userName || `Guest-${guestId.substring(6, 10)}`;

                        groupedUsers[guestId] = {
                            userId: guestId,
                            userName: guestUserName,
                            color: '#9E9E9E',
                            deviceCount: deviceCount,
                            hasMobile: hasMobile,
                            isGuest: true
                        };
                    }
                }

                callback({
                    count: Object.keys(groupedUsers).length,
                    users: groupedUsers,
                    usersList: Object.keys(groupedUsers),
                    allUsers: allSiteUsers
                });
        };

        // Run cleanup/refresh every 30 seconds to handle grace period expirations
        const refreshInterval = setInterval(processAndCallback, 30000);
        this.unsubscribers.push(() => clearInterval(refreshInterval));

        // Listen for all site users (for username and color)
        const unsubscribeSiteUsers = siteUsersRef.on('value', (snapshot) => {
            allSiteUsers = snapshot.val() || {};
            processAndCallback();
        });
        this.unsubscribers.push(unsubscribeSiteUsers);

        // Listen for authenticated users online presence data
        const unsubscribeOnlineUsers = onlineUsersRef.on('value', (snapshot) => {
            allOnlineAuthData = snapshot.val() || {};
            processAndCallback(); // Recalculate and update when online status changes
        });
        this.unsubscribers.push(unsubscribeOnlineUsers);

        // New: Listen for guest users online presence data
        const unsubscribeOnlineGuests = onlineGuestsRef.on('value', (snapshot) => {
            allOnlineGuestData = snapshot.val() || {};
            processAndCallback(); // Recalculate and update when guest online status changes
        });
        this.unsubscribers.push(unsubscribeOnlineGuests);
    });
  }

  stop() {
    this.isPolling = false;
    this.listeners = [];

    // Unsubscribe from all listeners
    this.unsubscribers.forEach(unsub => unsub()); // Can be removed, internal logic
    this.unsubscribers = [];

    // Clear heartbeat
    if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
    }

    // console.log('üõë ChatFirebaseREST —Å–ø—Ä—è–Ω.'); // Can be removed
  }
}

// ============================================
// PART 3: CHAT UI MANAGER
// ============================================

class ChatUIManager {
  constructor(containerId, documentId) {
    // console.log('üí¨ ChatUIManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º...'); // Can be removed
    this.container = document.getElementById(containerId);
    if (!this.container) {
      console.error('Container –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω:', containerId);
      return;
    }
    
    this.documentId = documentId || 'default';
    this.chatFirebase = new ChatFirebaseREST(this.documentId);
    this.isOpen = false;
    this.autoScroll = true;
    this.lastReadMessageId = localStorage.getItem(`lastReadMessage_${documentId}`) || null;
    this.notificationsDisabled = localStorage.getItem(`notificationsDisabled_${documentId}`) === 'true';
    this.unreadCount = 0;
    this.lastMessages = [];  // –°—ä—Ö—Ä–∞–Ω—è–≤–∞–º –ø—Ä–µ–¥–∏—à–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
    this.userNameMappings = {}; // –ö–∞—Ä—Ç–∞ –∑–∞ —Å—Ç–∞—Ä–∏ –∫—ä–º –Ω–æ–≤–∏ –∏–º–µ–Ω–∞
    this.reactionsCache = {}; // –ö–µ—à –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    this.activeUsers = {}; // –°–ø–∏—Å—ä–∫ —Å –∞–∫—Ç–∏–≤–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –∑–∞ –ª–æ–≥–∏–∫–∞ —Å —Ä–µ–∞–∫—Ü–∏–∏
    this.activeTyping = {}; // State for typing indicators
    this.showMembers = localStorage.getItem(`showMembers_${this.documentId}`) === 'true'; // Default to false if not set

    this.init();
  }

  _getMyUserIds() {
    if (!this.activeUsers || !currentUser.userName) return [currentUser.userId];
    
    const myName = currentUser.userName;
    const myIds = new Set([currentUser.userId]); // Always include current ID

    // Find all other userIds with the same name from the active list
    for (const userId in this.activeUsers) {
        const user = this.activeUsers[userId];
        if (user && user.userName === myName) {
            myIds.add(userId);
        }
    }
    return Array.from(myIds);
  }

  resolveName(originalName) {
    if (!this.userNameMappings || !originalName) return originalName;
    let currentName = originalName;
    let resolvedName = this.userNameMappings[currentName];
    let depth = 0; // safety break for circular dependencies
    while (resolvedName && depth < 10) {
        currentName = resolvedName;
        // Check for the next name in the chain
        resolvedName = this.userNameMappings[currentName];
        depth++;
    }
    return currentName;
  }

  fixInputLayout() {
    const inputArea = this.container.querySelector('.chat-input-area');
    if (!inputArea) return;

    // 1. Inject CSS for Column Layout if not present
    if (!document.getElementById('chat-layout-fix')) {
        const style = document.createElement('style');
        style.id = 'chat-layout-fix';
        style.textContent = `
            .chat-input-area {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 0 !important;
            }
            .chat-controls-row {
                display: flex !important;
                align-items: center !important;
                width: 100% !important;
                padding-top: 6px;
                position: relative;
                gap: 12px !important;
            }
            .reply-indicator {
                width: 100%;
                box-sizing: border-box;
                margin-bottom: 4px;
            }
.message-actions {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: -79px;
  display: none;
  gap: 2px;
  z-index: 10;
}
.message-actions.two-btns {
  right: -53px;
}
.chat-message:hover .message-actions {
  display: flex;
}
.message-actions button {
  transition: background 0.2s;
  border-radius: 8px !important;
  display: flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  width: 28px;
  height: 28px;
}
.message-actions button:hover {
  background: rgba(0, 0, 0, 0.05) !important;
}
            .message-options-menu {
                position: fixed;
                background: white;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                border: 1px solid var(--chat-border);
                padding: 4px;
                z-index: 10002;
                display: flex;
                flex-direction: column;
                min-width: 100px;
            }
            .message-option-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                font-size: 13px;
                cursor: pointer;
                border-radius: 8px;
                color: var(--chat-text);
                transition: background 0.2s;
            }
            .message-option-item:hover {
                background: var(--chat-secondary);
            }
            .message-option-item.delete {
                color: #ef4444;
            }
            .message-option-item img {
                width: 14px;
                height: 14px;
            }
            .message-actions button:hover {
                background: #dbeafe !important;
            }
            .reaction-tooltip {
                position: fixed;
                background: #262626;
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 12px;
                z-index: 10001;
                pointer-events: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                max-width: 200px;
                line-height: 1.5;
            }
            /* User Profile Modal */
            .user-profile-modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 20000;
                backdrop-filter: blur(2px);
                animation: fadeIn 0.2s ease;
            }
            .user-profile-modal {
                background: white;
                border-radius: 16px;
                width: 280px;
                padding: 24px;
                box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
                position: relative;
                animation: modalSlideUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            }
            @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
            @keyframes modalSlideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
            
            .profile-modal-close {
                position: absolute;
                top: 12px;
                right: 12px;
                background: none;
                border: none;
                font-size: 20px;
                color: #9ca3af;
                cursor: pointer;
                padding: 4px;
                line-height: 1;
            }
            .profile-modal-close:hover { color: #4b5563; }
            
            .profile-modal-avatar {
                width: 100px;
                height: 100px;
                border-radius: 50%;
                margin-bottom: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 36px;
                font-weight: bold;
                box-shadow: 0 4px 10px rgba(0,0,0,0.1);
                object-fit: cover;
            }
            .profile-modal-name {
                font-size: 18px;
                font-weight: 700;
                color: #111827;
                margin-bottom: 4px;
            }
            .profile-modal-status {
                font-size: 13px;
                color: #059669;
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 16px;
            }
            .status-dot { width: 8px; height: 8px; background: #10b981; border-radius: 50%; }
            
            .profile-modal-info {
                width: 100%;
                background: #f9fafb;
                border-radius: 12px;
                padding: 12px;
                margin-bottom: 20px;
                font-size: 12px;
                color: #4b5563;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            .info-item { display: flex; justify-content: space-between; }
            .info-label { font-weight: 600; }
            
            .profile-modal-actions {
                display: flex;
                gap: 8px;
                width: 100%;
            }
            .profile-action-btn {
                flex: 1;
                padding: 10px;
                border-radius: 8px;
                border: none;
                font-size: 13px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }
            .btn-mention { background: var(--chat-primary); color: white; }
            .btn-mention:hover { background: #6d28d9; }
        `;
        document.head.appendChild(style);
    }

    // 2. Restructure DOM: Move controls into a row if they aren't already
    const inputField = inputArea.querySelector('.chat-input');
    
    // Only proceed if inputField is direct child of inputArea (meaning not wrapped yet)
    if (inputField && inputField.parentElement === inputArea) {
        const row = document.createElement('div');
        row.className = 'chat-controls-row';
        
        // Find elements to move
        const sendBtn = inputArea.querySelector('.chat-send-btn');
        
        // Move them to row
        row.appendChild(inputField); // Input
        if (sendBtn) row.appendChild(sendBtn);
        
        // Append row to inputArea
        inputArea.appendChild(row);
    }
  }

  async init() {
    try {
      this.fixInputLayout();
      // await this.chatFirebase.markUserActive(); // Removed - using site-wide presence.js

      // –ó–∞—Ä–µ–¥–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è - –æ—Ç localStorage –∏–ª–∏ Firebase
      let messages = this.loadFromCache();
      if (!messages || messages.length === 0) {
        messages = await this.chatFirebase.loadMessages();
      }
      
      // –ó–∞—Ä–µ–¥–∏ –º–∞–ø–∏–Ω–≥–∏ –Ω–∞ –∏–º–µ–Ω–∞
      this.protectedNames = await this.chatFirebase.getProtectedNames();

      this.chatFirebase.startNameMappingsPolling((mappings) => {
          this.userNameMappings = mappings;
          if (this.lastMessages.length > 0) {
              this.renderMessages(this.lastMessages);
          }
      });
      
      this.saveToCache(messages);
      this.renderMessages(messages);

      // Polling –∑–∞ –Ω–æ–≤–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startPolling((messages) => {
        this.saveToCache(messages);
        this.renderMessages(messages);
      }, 2500);

      // Real-time —Å–ª—É—à–∞—Ç–µ–ª –∑–∞ –í–°–ò–ß–ö–ò —Ä–µ–∞–∫—Ü–∏–∏
      this.chatFirebase.startReactionsPolling((reactions) => {
        this.reactionsCache = reactions;
        this.renderAllReactions();
      });

      // New site-wide presence polling
      this.chatFirebase.startSiteWidePresencePolling((data) => {
        // Cache user data
        this.activeUsers = data.users || {};
        this.userProfiles = data.allUsers || {};
        
        // Re-render messages to update avatars/names now that reconciliation is flicker-free
        if (this.lastMessages.length > 0) {
            this.renderMessages(this.lastMessages);
        }

        this.updateNotificationButton(data);
        this.updateHeaderOnlineCount(data.count);
      });

      // Typing indicators polling
      this.chatFirebase.startTypingPolling((activeTyping) => {
          this.activeTyping = activeTyping;
          this.renderTypingIndicators(activeTyping);
      });

      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startLastReadPolling(currentUser.userName, (lastReadId) => {
        // Only update if the new ID is "greater" (newer) than what we have
        if (lastReadId && (!this.lastReadMessageId || lastReadId > this.lastReadMessageId)) {
          console.log(`üîÑ Synchronized newer lastReadId: ${lastReadId}`);
          this.lastReadMessageId = lastReadId;
          localStorage.setItem(`lastReadMessage_${this.documentId}`, lastReadId);
          
          this.recalculateUnreadCount(this.chatFirebase.messages);
          this.updateActiveCount();
        }
      });

      // Listener –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      this.chatFirebase.addMessageListener((newMessage) => {
        // Check if the message is from the current user
        const isMyMessage = (window.currentUser.userId && newMessage.userId === window.currentUser.userId) ||
                            (window.currentUser.legacyChatId && newMessage.userId === window.currentUser.legacyChatId);

        if (!isMyMessage) {
            // Check for mention
            const currentName = window.currentUser ? (window.currentUser.userName || window.currentUser.displayName || "").toLowerCase() : "";
            const textLower = (newMessage.text || "").toLowerCase();
            const hasIndividualMention = currentName && textLower.includes(`@${currentName}`);
            const hasEveryoneMention = textLower.includes('@everyone');
            
            if (hasIndividualMention || hasEveryoneMention) {
                this.showMentionNotification();
            }
            
            // Trigger standard notification only if chat is closed
            if (!this.isOpen) {
                // this.showNotification(); 
            }
        }
      });

      this.attachEventListeners();
      
      // –ü—Ä–∏–ª–æ–∂–∏ –Ω–∞—á–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ —Å —á–ª–µ–Ω–æ–≤–µ
      const chatPanel = this.container.querySelector('.chat-panel');
      if (chatPanel && this.showMembers) {
        chatPanel.classList.add('show-members');
      }
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–π –±—É—Ç–æ–Ω –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ–¥–∏–Ω –ø—ä—Ç
      this.initNotificationButton();
      
      // console.log('‚úì‚úì‚úì ChatUIManager –≥–æ—Ç–æ–≤'); // Can be removed
    } catch (error) {
      console.error('Init error:', error);
    }
  }

  loadFromCache() {
    try {
      const key = `chatMessages_${this.documentId}`;
      const cached = localStorage.getItem(key);
      if (cached) {
        return JSON.parse(cached);
      }
    } catch (error) {
      console.error('Cache load error:', error);
    }
    return null;
  }

  saveToCache(messages) {
    try {
      const key = `chatMessages_${this.documentId}`;
      localStorage.setItem(key, JSON.stringify(messages));
    } catch (error) {
      console.error('Cache save error:', error);
    }
  }

  attachEventListeners() {
    const sendBtn = this.container.querySelector('.chat-send-btn');
    const input = this.container.querySelector('.chat-input'); // This is now a textarea

    if (sendBtn && input) {
      sendBtn.addEventListener('click', () => this.handleSendMessage());

      const plusBtn = this.container.querySelector('.chat-plus-btn');
      if (plusBtn) {
        plusBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.togglePlusMenu();
        });
      }

      input.addEventListener('keydown', (e) => {
        // Mention navigation
        const suggestions = this.container.querySelector('#mention-suggestions');
        if (suggestions && suggestions.style.display !== 'none') {
            const items = suggestions.querySelectorAll('.suggestion-item');
            let activeIndex = Array.from(items).findIndex(item => item.classList.contains('active'));

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (items.length > 0) {
                    if (activeIndex >= 0) items[activeIndex].classList.remove('active');
                    activeIndex = (activeIndex + 1) % items.length;
                    items[activeIndex].classList.add('active');
                    items[activeIndex].scrollIntoView({ block: 'nearest' });
                }
                return;
            }
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (items.length > 0) {
                    if (activeIndex >= 0) items[activeIndex].classList.remove('active');
                    activeIndex = (activeIndex - 1 + items.length) % items.length;
                    items[activeIndex].classList.add('active');
                    items[activeIndex].scrollIntoView({ block: 'nearest' });
                }
                return;
            }
            if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (activeIndex >= 0) {
                    items[activeIndex].click();
                } else if (items.length > 0) {
                    items[0].click();
                }
                return;
            }
            if (e.key === 'Escape') {
                suggestions.style.display = 'none';
                return;
            }
        }

        if (e.key === 'Escape') {
            if (this.editingMessage) {
                this.cancelEditing();
            }
            return;
        }

        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSendMessage();
        }
      });
      
      // Auto-resize textarea
      input.addEventListener('input', () => {
         input.style.height = 'auto';
         input.style.height = (input.scrollHeight) + 'px';
         // Cap max height if needed via CSS max-height
         
         this.handleMentionInput(input);
         this.handleTyping();
      });
    }

    const messagesContainer = this.container.querySelector('.chat-messages');
    
    // Members toggle logic
    const membersToggle = this.container.querySelector('#chat-members-toggle');
    const chatPanel = this.container.querySelector('.chat-panel');
    if (membersToggle && chatPanel) {
      membersToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        
        this.showMembers = !chatPanel.classList.contains('show-members');
        chatPanel.classList.toggle('show-members');
        localStorage.setItem(`showMembers_${this.documentId}`, this.showMembers);
      });
    }

    if (messagesContainer) {
      messagesContainer.addEventListener('scroll', () => {
        const isAtBottom =
          messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 50;
        this.autoScroll = isAtBottom;
      });
    }
  }

  handleTyping() {
    if (this.typingTimeout) clearTimeout(this.typingTimeout);
    
    if (!this.isTyping) {
        this.isTyping = true;
        this.chatFirebase.setTyping(true);
    }

    this.typingTimeout = setTimeout(() => {
        this.isTyping = false;
        this.chatFirebase.setTyping(false);
    }, 2000); // Stop typing status after 2 seconds of inactivity
  }

  handleMentionInput(input) {
    const term = this.getMentionSearchTerm(input);
    if (term === null) {
      this.container.querySelector('#mention-suggestions').style.display = 'none';
      return;
    }

    // Get all potential users to mention
    const users = [];
    const seenUids = new Set();

    // 0. Add "everyone" option
    if ("everyone".includes(term.toLowerCase())) {
        users.push({ uid: 'all', name: 'everyone', avatar: null, color: '#ef4444' });
    }

    // 1. Online users first
    if (this.chatFirebase && this.chatFirebase.activeUsers) {
      Object.entries(this.chatFirebase.activeUsers).forEach(([uid, data]) => {
        const publicName = data.displayName || data.userName || data.username || "Unknown";
        const resolvedName = this.resolveName(publicName);
        if (resolvedName.toLowerCase().includes(term.toLowerCase())) {
          users.push({ uid, name: resolvedName, avatar: data.avatar, color: data.color });
          seenUids.add(uid);
        }
      });
    }

    // 2. Add other users from profiles
    if (this.userProfiles) {
      Object.entries(this.userProfiles).forEach(([uid, profile]) => {
        if (!seenUids.has(uid)) {
          const publicName = profile.displayName || profile.userName || profile.username || "Unknown";
          const resolvedName = this.resolveName(publicName);
          if (resolvedName.toLowerCase().includes(term.toLowerCase())) {
            users.push({ uid, name: resolvedName, avatar: profile.avatar, color: profile.color });
          }
        }
      });
    }

    if (users.length > 0) {
      this.renderMentionSuggestions(users, input);
    } else {
      this.container.querySelector('#mention-suggestions').style.display = 'none';
    }
  }

  getMentionSearchTerm(input) {
    const text = input.value;
    const cursor = input.selectionStart;
    const lastAt = text.lastIndexOf('@', cursor - 1);
    
    if (lastAt === -1) return null;
    
    // Check if there's a space before @ (optional, but usually mentions start after space or at start)
    if (lastAt > 0 && !/\s/.test(text[lastAt - 1])) {
        // Only allow if it's start of line or after space
        // But for university chat, maybe allow any @
    }

    const term = text.substring(lastAt + 1, cursor);
    if (/\s/.test(term)) return null; // No spaces allowed in mention term during search
    
    return term;
  }

  renderMentionSuggestions(users, input) {
    const container = this.container.querySelector('#mention-suggestions');
    container.innerHTML = users.slice(0, 8).map((user, index) => {
      const initial = user.name.charAt(0).toUpperCase();
      const userColor = user.color || '#588157';
      const hasRealAvatar = user.avatar && user.avatar.length > 5;
      
      return `
        <div class="suggestion-item ${index === 0 ? 'active' : ''}" data-uid="${user.uid}" data-name="${user.name}">
          <div class="suggestion-avatar" style="background-color: ${userColor}; position: relative;">
            <span style="display: ${hasRealAvatar ? 'none' : 'block'}">${initial}</span>
            ${hasRealAvatar ? `<img src="${user.avatar}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover; position: absolute; top: 0; left: 0;" onerror="this.style.display='none'; this.previousElementSibling.style.display='block'">` : ''}
          </div>
          <span>${this.escapeHtml(user.name)}</span>
        </div>
      `;
    }).join('');

    container.style.display = 'block';

    container.querySelectorAll('.suggestion-item').forEach(item => {
      item.addEventListener('click', () => {
        this.insertMention(input, item.dataset.name);
      });
    });
  }

  insertMention(input, username) {
    const text = input.value;
    const cursor = input.selectionStart;
    const lastAt = text.lastIndexOf('@', cursor - 1);
    
    const before = text.substring(0, lastAt);
    const after = text.substring(cursor);
    
    input.value = before + '@' + username + ' ' + after;
    input.focus();
    
    const newCursor = lastAt + username.length + 2; // +1 for @, +1 for space
    input.setSelectionRange(newCursor, newCursor);
    
    this.container.querySelector('#mention-suggestions').style.display = 'none';
    
    // Trigger auto-resize
    input.dispatchEvent(new Event('input'));
  }

  renderTypingIndicators(activeTyping) {
      // Remove existing indicator
      const existing = this.container.querySelector('.typing-indicator-container');
      if (existing) existing.remove();

      const userIds = Object.keys(activeTyping);
      if (userIds.length === 0) return;

      const names = userIds.map(uid => this.resolveName(activeTyping[uid])).join(', ');
      const text = userIds.length > 2 ? `${userIds.length} people are typing...` : `${names} is typing...`;

      const indicatorHtml = `
        <div class="typing-indicator-container">
            <div class="typing-dots">
                <span class="typing-dot"></span>
                <span class="typing-dot"></span>
                <span class="typing-dot"></span>
            </div>
            <span>${this.escapeHtml(text)}</span>
        </div>
      `;

      // Insert into wrapper (absolute positioned)
      const wrapper = this.container.querySelector('.chat-messages-wrapper');
      if (wrapper) {
          wrapper.insertAdjacentHTML('beforeend', indicatorHtml);
      }
  }

  initNotificationButton() {
    // Populate sidebar with ONLY the users list container
    const sidebarEl = this.container.querySelector('.chat-active-users');
    if (sidebarEl) {
      sidebarEl.innerHTML = `
        <div id="active-users-list" style="padding: 4px 4px; font-size: 11px; color: #6b7280;"></div>
      `;
    }

    // Attach listener to the HEADER button
    const toggleBtn = this.container.querySelector('#toggle-notifications');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => {
        this.notificationsDisabled = !this.notificationsDisabled;
        localStorage.setItem(`notificationsDisabled_${this.documentId}`, this.notificationsDisabled);
        
        // Update button visual state
        this.updateNotificationButtonColor();
        // Update unread count visibility
        this.updateActiveCount();
      });
    }
  }

  updateNotificationButtonColor() {
    const toggleBtn = this.container.querySelector('#toggle-notifications');
    if (toggleBtn) {
      const img = toggleBtn.querySelector('img');
      if (img) {
        img.src = `svg/chat/${this.notificationsDisabled ? 'icon-notifications-disabled.svg' : 'icon-notifications-enabled.svg'}`;
        img.style.width = this.notificationsDisabled ? '18px' : '20px';
        img.style.height = this.notificationsDisabled ? '18px' : '20px';
        img.style.filter = 'brightness(0) invert(1)';
      }
      toggleBtn.title = this.notificationsDisabled ? 'Notifications Disabled' : 'Notifications Enabled';
    }
  }

  updateNotificationButton(data) {
    const usersListEl = document.getElementById('active-users-list');
    if (!usersListEl) return;

    // data.users is online users, data.allUsers has all registered users
    let onlineUsers = Object.values(data.users || {});
    const allUsers = data.allUsers || {};
    const count = data.count || 0; // Online count

    const myId = (typeof window.currentUser !== 'undefined' && window.currentUser.userId) ? String(window.currentUser.userId) : null;

    // Get offline users who should be shown (filter by showInMembersList flag)
    const offlineUsers = [];
    for (const uid in allUsers) {
      const user = allUsers[uid];
      // Skip if already online or if not flagged to show in members list
      if (data.users[uid] || !user.showInMembersList) continue;
      
      offlineUsers.push({
        userId: uid,
        userName: user.displayName || user.username,
        color: user.color || '#999',
        avatar: user.avatar,
        isAdmin: user.isAdmin || false,
        lastSeen: user.lastSeen,
        isOffline: true
      });
    }

    // Map and sort online users
    onlineUsers.forEach(user => {
        // Resolve name mapping
        let name = user.userName;
        if (this.userNameMappings && this.userNameMappings[name]) {
            name = this.userNameMappings[name];
        }
        user.userName = name;
        user.isMe = (String(user.userId) === myId);
    });

    // Map and sort offline users
    offlineUsers.forEach(user => {
        // Resolve name mapping
        let name = user.userName;
        if (this.userNameMappings && this.userNameMappings[name]) {
            name = this.userNameMappings[name];
        }
        user.userName = name;
        user.isMe = (String(user.userId) === myId);
    });

    // Sort: current user first, then alphabetically
    onlineUsers.sort((a, b) => {
      if (a.isMe && !b.isMe) return -1;
      if (!a.isMe && b.isMe) return 1;
      return a.userName.localeCompare(b.userName);
    });

    offlineUsers.sort((a, b) => {
      if (a.isMe && !b.isMe) return -1;
      if (!a.isMe && b.isMe) return 1;
      return a.userName.localeCompare(b.userName);
    });

    const renderUserItem = (user) => {
      const mobileIcon = user.hasMobile
        ? `<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="margin-left: 4px; vertical-align: middle;" title="Mobile device"> <path d="M11.5,0h-7C3.675,0,3,0.675,3,1.5v13C3,15.325,3.675,16,4.5,16h7c0.825,0,1.5-0.675,1.5-1.5v-13C13,0.675,12.325,0,11.5,0z M8,15c-0.553,0-1-0.447-1-1s0.447-1,1-1s1,0.447,1,1S8.553,15,8,15z M12,12H4V2h8V12z" /> </svg>`
        : '';
      
      const opacity = user.isOffline ? '0.6' : '1';
        
      return `
        <div class="active-user-item" data-user-id="${user.userId}" style="display: flex; align-items: center; gap: 8px; margin: 6px 0; cursor: pointer; padding: 4px 2px; border-radius: 4px; transition: background 0.2s; opacity: ${opacity};">
          ${user.avatar ? 
            `<img src="${user.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover; flex-shrink: 0;">` :
            `<div style="width: 24px; height: 24px; border-radius: 50%; background-color: ${user.color}; display: flex; align-items: center; justify-content: center; font-size: 11px; color: white; font-weight: bold; flex-shrink: 0;">${user.userName.charAt(0).toUpperCase()}</div>`
          }
          <span style="font-size: 12px; flex: 1; min-width: 0; display: flex; align-items: center; ${user.isMe ? 'font-weight: bold; color: var(--fg);' : ''}">
            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block; max-width: 100%;">${user.userName}</span>
            ${mobileIcon}
          </span>
        </div>
      `;
    };

    usersListEl.innerHTML = `
      <strong>Online (${count}):</strong><br>
      ${onlineUsers.map(renderUserItem).join('')}
      ${offlineUsers.length > 0 ? `<div style="height: 4px;"></div><strong style="margin-top: 0; display: block;">Offline:</strong>${offlineUsers.map(renderUserItem).join('')}` : ''}
    `;

    // Add click listeners
    usersListEl.querySelectorAll('.active-user-item').forEach(item => {
        item.addEventListener('click', () => {
            this.showUserProfile(item.dataset.userId);
        });
    });

    // Also update header count to be consistent
    if (this.updateHeaderOnlineCount) {
        this.updateHeaderOnlineCount(count);
    }
  }

  showUserProfile(userId) {
    const user = this.activeUsers[userId] || (this.userProfiles && this.userProfiles[userId]);
    if (!user) return;

    const resolvedName = this.resolveName(user.userName || user.displayName);
    const initial = resolvedName.charAt(0).toUpperCase();
    const userColor = user.color || '#588157';
    const hasAvatar = user.avatar && user.avatar.length > 5;
    
    // Check if user is actually online (in activeUsers list)
    const isOnline = !!this.activeUsers[userId];
    
    // Determine status text (Admin > Guest > Member)
    let statusText = 'Member';
    if (user.isAdmin) {
        statusText = 'Admin';
    } else if (user.isGuest) {
        statusText = 'Guest';
    }
    
    const deviceText = user.hasMobile ? 'Mobile' : 'Desktop';
    
    // Format last seen time for offline users
    let lastSeenText = '';
    if (!isOnline) {
        // Try lastActivity from presence data first, then lastSeen from profile
        const lastSeenTimestamp = user.lastActivity || user.lastSeen;
        
        if (lastSeenTimestamp) {
            const lastSeenDate = new Date(lastSeenTimestamp);
            const now = new Date();
            const diffMs = now - lastSeenDate;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) {
                lastSeenText = 'Just now';
            } else if (diffMins < 60) {
                lastSeenText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
            } else if (diffHours < 24) {
                lastSeenText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
            } else if (diffDays < 7) {
                lastSeenText = `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
            } else {
                lastSeenText = lastSeenDate.toLocaleDateString();
            }
        } else {
            // No timestamp available (user hasn't been active since tracking was added)
            lastSeenText = 'Long time ago';
        }
    }
    
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'user-profile-modal-overlay';

    modalOverlay.innerHTML = `
        <div class="user-profile-modal">
            <button class="profile-modal-close">‚úï</button>
            
            ${hasAvatar ? 
                `<img src="${user.avatar}" class="profile-modal-avatar">` :
                `<div class="profile-modal-avatar" style="background-color: ${userColor}">${initial}</div>`
            }
            
            <div class="profile-modal-name">${this.escapeHtml(resolvedName)}</div>
            <div class="profile-modal-status">
                <span class="status-dot" style="background-color: ${isOnline ? '#22c55e' : '#9ca3af'}"></span>
                ${isOnline ? 'Online' : 'Offline'}
            </div>
            ${!isOnline && lastSeenText ? `<div style="font-size: 12px; color: #6b7280; margin-top: -4px;">Last seen: ${lastSeenText}</div>` : ''}
            
            <div class="profile-modal-info">
                <div class="info-item">
                    <span class="info-label">Status</span>
                    <span>${statusText}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Device</span>
                    <span>${deviceText}</span>
                </div>
                ${user.deviceCount > 1 ? `
                <div class="info-item">
                    <span class="info-label">Sessions</span>
                    <span>${user.deviceCount} active</span>
                </div>` : ''}
            </div>
            
            <div class="profile-modal-actions">
                <button class="profile-action-btn btn-mention">@ Mention</button>
            </div>
        </div>
    `;

    document.body.appendChild(modalOverlay);

    // Close on click overlay
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
            modalOverlay.remove();
        }
    });

    // Close on button
    modalOverlay.querySelector('.profile-modal-close').onclick = () => modalOverlay.remove();

    // Mention button
    modalOverlay.querySelector('.btn-mention').onclick = () => {
        const input = this.container.querySelector('.chat-input');
        if (input) {
            this.insertMention(input, resolvedName);
            modalOverlay.remove();
            // Open chat if closed? It's likely open if they clicked active members
        }
    };
  }

  async handleAdminCommand(commandObj) {
      const cmd = commandObj.substring(7).trim(); // Remove "/admin "

      if (cmd === 'deletechat') {
          if(confirm("‚ö† WARNING: This will delete ALL chat history globally! Are you sure?")) {
              await window.deleteAllChatMessages('admin');
          }
      }
  }

  async handleSendMessage() {
    const input = this.container.querySelector('.chat-input');
    const text = input.value;

    if (!text.trim()) return;

    // –†–µ–¥–∞–∫—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ
    if (this.editingMessage) {
        await this.editMessage(this.editingMessage.key, text);
        return;
    }

    // --- ADMIN COMMANDS ---
    if (text.startsWith('/admin ')) {
       await this.handleAdminCommand(text);
       input.value = '';
       return;
    }
    // ----------------------

    // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –∏–º–∞ reply
    const replyTo = input.dataset.replyTo;
    const replyAuthor = input.dataset.replyAuthor;

    const success = await this.chatFirebase.sendMessage(text, replyTo, replyAuthor);
    if (success) {
      // Find the last message in history (which should be the one just sent)
      // Note: startPolling will bring it in, but we can optimistically update
      // so the unread count stays 0 for our own messages.
      const messages = this.chatFirebase.messages;
      if (messages.length > 0) {
          const lastMsg = messages[messages.length - 1];
          // We don't have the NEW id yet because push() happened inside sendMessage,
          // but we can mark our current view as "up to date".
          this.unreadCount = 0;
          this.updateActiveCount();
      }

      input.value = '';
      input.dataset.replyTo = '';
      input.dataset.replyAuthor = '';
      
      // Reset textarea height after sending
      input.style.height = 'auto';
      
      input.focus();
      
      // –ü—Ä–µ–º–∞—Ö–Ω–∏ reply indicator
      const replyIndicator = this.container.querySelector('.reply-indicator');
      if (replyIndicator) replyIndicator.remove();
      
      // Realtime listener —â–µ —Å–µ –ø–æ–≥—Ä–∏–∂–∏ –∑–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ—Ç–æ (startPolling)
      // –ü—Ä–µ–º–∞—Ö–Ω–∞—Ö–º–µ —Ä—ä—á–Ω–æ—Ç–æ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º race conditions
    }
  }

  recalculateUnreadCount(messages) {
    // Helper to check if a message is from the current user
    const isMyMessage = (msg) => {
        return msg.userId === window.currentUser.userId || (window.currentUser.legacyChatId && msg.userId === window.currentUser.legacyChatId);
    };

    if (!this.lastReadMessageId) {
        // On first load, count all messages that are not from the current user.
        this.unreadCount = messages.filter(m => !isMyMessage(m)).length;
        return;
    }

    let readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
    
    // If marker is gone (deleted), try to recover using previous history
    if (readIndex === -1 && this.lastMessages.length > 0) {
        const oldIndex = this.lastMessages.findIndex(m => m.id === this.lastReadMessageId);
        if (oldIndex !== -1) {
            // Find a survivor preceding the deleted marker
            // Iterate backwards from oldIndex to find a survivor
            for (let i = oldIndex - 1; i >= 0; i--) {
                const predecessor = this.lastMessages[i];
                if (messages.find(m => m.id === predecessor.id)) {
                    this.lastReadMessageId = predecessor.id;
                    localStorage.setItem(`lastReadMessage_${this.documentId}`, this.lastReadMessageId);
                    readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
                    break;
                }
            }
        }
        
        // If still not found (e.g. all preceding messages deleted too, or never found), reset to 0
        // Because if the marker is gone, we assume the user was up to date.
        if (readIndex === -1) {
             this.unreadCount = 0;
             return;
        }
    }
    
    // Calculate unread
    let unreadMessages = [];
    if (readIndex !== -1) {
        // Only count messages that are NOT mine AND are newer than my last read marker
        unreadMessages = messages.slice(readIndex + 1).filter(m => !isMyMessage(m));
    } else {
        // Fallback: count all messages NOT mine
        unreadMessages = messages.filter(m => !isMyMessage(m));
    }

    this.unreadCount = unreadMessages.length;

    // Check for mentions in unread set
    const currentName = (window.currentUser.userName || window.currentUser.displayName || "").toLowerCase();
    this.unreadHasMention = unreadMessages.some(m => {
        const text = (m.text || "").toLowerCase();
        return text.includes('@everyone') || (currentName && text.includes(`@${currentName}`));
    });
  }

  renderMessages(messages) {
    const messagesContainer = this.container.querySelector('.chat-messages');
    if (!messagesContainer) return;

    const scrollWasAtBottom = this.autoScroll ||
      messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;

    // 1. Remove deleted messages from DOM
    const newIds = new Set(messages.map(m => m.id));
    let messageRemoved = false;
    messagesContainer.querySelectorAll('.chat-message').forEach(el => {
        if (!newIds.has(el.dataset.messageId)) {
            el.remove();
            messageRemoved = true;
        }
    });

    if (messageRemoved) {
        this.hideReactionTooltip();
    }

    // 2. Add or Update messages
    let prevMsg = null;
    let lastDateStr = null;

    messages.forEach((msg, index) => {
        const msgDate = new Date(msg.timestamp);
        const dateStr = msgDate.toLocaleDateString('en-US', { day: 'numeric', month: 'long', year: 'numeric' });
        
        // Add date separator if day changed
        if (dateStr !== lastDateStr) {
            let dateSep = messagesContainer.querySelector(`.chat-date-separator[data-date="${dateStr}"]`);
            if (!dateSep) {
                dateSep = document.createElement('div');
                dateSep.className = 'chat-date-separator';
                dateSep.dataset.date = dateStr;
                dateSep.innerHTML = `<span>${dateStr}</span>`;
                messagesContainer.appendChild(dateSep);
            }
            lastDateStr = dateStr;
        }

        let isContinuation = false;
        if (prevMsg && prevMsg.userId === msg.userId && (msg.timestamp - prevMsg.timestamp < 3 * 60 * 1000)) {
            isContinuation = true;
        }

        let existingEl = messagesContainer.querySelector(`.chat-message[data-message-id="${msg.id}"]`);
        if (!existingEl) {
            const messageEl = this.createMessageElement(msg, messages, isContinuation);
            messagesContainer.appendChild(messageEl);
            this.attachMessageListeners(messageEl);
        } else {
            // Check if profile data arrived for a placeholder message
            // ONLY refresh if we now have a real image to show (currentAvatar is long string)
            const profile = this.userProfiles && (this.userProfiles[msg.userId] || Object.values(this.userProfiles).find(p => (p.username||"").toLowerCase() === (msg.userName||"").toLowerCase()));
            const hasRealAvatar = profile && profile.avatar && typeof profile.avatar === 'string' && profile.avatar.length > 5;
            const isShowingPlaceholder = !existingEl.querySelector('img.message-avatar') || existingEl.querySelector('img.message-avatar').style.display === 'none';
            
            if (hasRealAvatar && isShowingPlaceholder && !isContinuation) {
                // Refresh in place to show new avatar/name
                const newMessageEl = this.createMessageElement(msg, messages, isContinuation);
                existingEl.replaceWith(newMessageEl);
                this.attachMessageListeners(newMessageEl);
            } else {
                // Check if message was edited
                const textEl = existingEl.querySelector('.message-text');
                if (textEl) {
                    const currentText = msg.text;
                    const isEdited = !!msg.edited;
                    // Store text in data-attribute for efficient change tracking
                                    if (textEl.getAttribute('data-raw-text') !== currentText) {
                                        textEl.innerHTML = `
                                            ${this.linkifyText(currentText)}
                                            ${isEdited ? `<span style="font-size: 10px; opacity: 0.5; margin-left: 4px;">(edited)</span>` : ''}
                                        `;
                                        textEl.setAttribute('data-raw-text', currentText);
                                    }                }

                // Standard continuation update - only touch visibility if changed
                const avatar = existingEl.querySelector('.message-avatar');
                if (avatar) {
                    const targetVis = isContinuation ? 'hidden' : 'visible';
                    if (avatar.style.visibility !== targetVis) avatar.style.visibility = targetVis;
                }
                const header = existingEl.querySelector('.message-header');
                if (header) {
                    const targetDisp = isContinuation ? 'none' : 'flex';
                    if (header.style.display !== targetDisp) header.style.display = targetDisp;
                }
            }
        }
        prevMsg = msg;
    });

    this.recalculateUnreadCount(messages);
    this.updateActiveCount();
    
    // Check if the last message is new
    const lastMsgId = messages.length > 0 ? messages[messages.length - 1].id : null;
    const oldLastMsgId = this.lastMessages && this.lastMessages.length > 0 ? this.lastMessages[this.lastMessages.length - 1].id : null;
    const hasNewMessage = lastMsgId !== oldLastMsgId;

    this.lastMessages = messages;

    // Re-render reactions from cache
    this.renderAllReactions();

    // Persist typing indicators if they exist
    if (this.activeTyping && Object.keys(this.activeTyping).length > 0) {
        this.renderTypingIndicators(this.activeTyping);
    }

    if (scrollWasAtBottom && hasNewMessage) {
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 50);
    }
  }

  fullRenderMessages(messages, messagesContainer) {
    // This is now legacy but kept for reference or edge cases
    this.renderMessages(messages);
  }

  createMessageElement(msg, messagesMap, isContinuation) {
    const messagesMapObj = {};
    (messagesMap || []).forEach(m => {
      messagesMapObj[m.id] = m;
    });

    // –ê–∫–æ –∏–º–∞ reply, –Ω–∞–º–µ—Ä–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–æ—Ç–æ —Å—ä–æ–±—â–µ–Ω–∏–µ
    let replyHTML = '';
    if (msg.replyTo && messagesMapObj[msg.replyTo]) {
      const originalMsg = messagesMapObj[msg.replyTo];
      replyHTML = `
         <div style="background: #f1f5f9; border-left: 3px solid #cbd5e1; padding: 4px 8px; margin-bottom: 4px; font-size: 11px; border-radius: 4px; opacity: 0.8;">
           <b>${this.escapeHtml(msg.replyAuthor || 'Someone')}:</b> ${this.linkifyText(originalMsg.text.substring(0, 50))}...
         </div>
      `;
    }

    // Dynamic Profile Lookup - Prioritize live data from site_users
    let userProfile = this.userProfiles ? (this.userProfiles[msg.userId] || this.userProfiles[String(msg.userId)] || null) : null;
    
    // Fallback: search by name in profiles if ID lookup failed (case-insensitive)
    if (!userProfile && this.userProfiles) {
        const searchName = (msg.userName || "").toLowerCase();
        userProfile = Object.values(this.userProfiles).find(p => 
            (p.username && p.username.toLowerCase() === searchName) || 
            (p.displayName && p.displayName.toLowerCase() === searchName)
        ) || null;
    }

    const currentAvatar = (userProfile && userProfile.avatar) ? userProfile.avatar : msg.userAvatar; 
    const currentColor = (userProfile && userProfile.color) ? userProfile.color : (msg.userColor || '#ccc'); 
    const resolvedName = this.resolveName(msg.userName);

    const isCurrentUser = (window.currentUser.userId && msg.userId === window.currentUser.userId) || (window.currentUser.legacyChatId && msg.userId === window.currentUser.legacyChatId);
    const messageBgColor = isCurrentUser ? '#e0f2fe' : 'var(--chat-secondary)';

    // Avatar Logic
    let avatarHtml = '';
    const avatarStyle = isContinuation ? 'visibility: hidden;' : 'visibility: visible;';
    const initial = (resolvedName || "?")[0].toUpperCase();
    
    if (currentAvatar && typeof currentAvatar === 'string' && currentAvatar.length > 5) {
        avatarHtml = `
            <div class="message-avatar-container" style="width: 32px; height: 32px; flex-shrink: 0; position: relative;">
                <img src="${currentAvatar}" class="message-avatar" style="${avatarStyle} object-fit: cover;" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="message-avatar" style="background-color: ${currentColor}; ${avatarStyle} display: none; align-items: center; justify-content: center; border-radius: 50%; color: white; font-weight: bold;">${initial}</div>
            </div>`;
    } else {
        avatarHtml = `
            <div class="message-avatar-container" style="width: 32px; height: 32px; flex-shrink: 0;">
                <div class="message-avatar" style="background-color: ${currentColor}; ${avatarStyle} display: flex; align-items: center; justify-content: center; border-radius: 50%; color: white; font-weight: bold;">${initial}</div>
            </div>`;
    }

    // Header Logic
    let headerHtml = '';
    const headerStyle = isContinuation ? 'display: none;' : 'display: flex;';
    headerHtml = `
      <div class="message-header" style="justify-content: flex-start; ${headerStyle}">
        <span class="message-author">${this.escapeHtml(resolvedName)}</span> 
        <span class="message-time">${this.formatTime(msg.timestamp)}</span>
      </div>
    `;

    // Reactions are now rendered from cache, so the initial div is populated
    const reactionsHTML = this.getReactionsHTML(msg.id);
    
    // Calculate margin: default very tight (2px), continuation (0px), loose if reactions (2px)
    let marginBottom = isContinuation ? '0px' : '2px';
    if (reactionsHTML) {
        marginBottom = '2px';
    }

    const actionClass = isCurrentUser ? '' : 'two-btns';

    const htmlString = `
      <div class="chat-message" data-user-id="${msg.userId}" data-message-id="${msg.id}" data-message-key="${msg.key}" style="position: relative; display: flex; gap: 8px; margin-bottom: ${marginBottom}; flex-direction: row;">
        ${avatarHtml}
        <div class="message-content" style="flex: 1; align-items: flex-start; display: flex; flex-direction: column; min-width: 0;">
          ${headerHtml}
          
          <div class="message-bubble-container" style="position: relative; width: fit-content; display: flex; flex-direction: column;">
             ${replyHTML}
             <div class="message-text" data-raw-text="${this.escapeHtml(msg.text)}" style="background-color: ${messageBgColor}; text-align: left; max-width: 100%; width: fit-content;">
            ${this.linkifyText(msg.text)}
            ${msg.edited ? `<span style="font-size: 10px; opacity: 0.5; margin-left: 4px;">(edited)</span>` : ''}
          </div>
             
        <div class="message-actions ${actionClass}">
          <button class="message-reply-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 50%; width: 24px; height: 24px;" title="–û—Ç–≥–æ–≤–æ—Ä–∏">
            <img src="svg/chat/icon-reply.svg" alt="Reply" style="width: 16px; height: 16px">
          </button>
          <button class="message-reaction-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 50%; width: 24px; height: 24px;" title="–î–æ–±–∞–≤–∏ —Ä–µ–∞–∫—Ü–∏—è">
            <img src="svg/chat/icon-reaction.svg" alt="Reaction" style="width: 16px; height: 16px">
          </button>
          ${isCurrentUser ? `
          <button class="message-options-btn" data-message-id="${msg.id}" data-message-key="${msg.key}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 50%; width: 24px; height: 24px;" title="–û—â–µ –æ–ø—Ü–∏–∏">
            <img src="svg/chat/icon-three-dots-vertical.svg" alt="More" style="width: 16px; height: 16px">
          </button>` : ''}
        </div>
          </div>

          <div class="message-reactions" data-message-id="${msg.id}" style="justify-content: flex-start;">${reactionsHTML}</div>
        </div>
      </div>
    `;

    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    // Attach listeners to reaction badges immediately after creation
    this.attachReactionBadgeListeners(temp.firstElementChild);
    return temp.firstElementChild;
  }

  attachMessageListeners(msgEl) {
    // Hover effect now handled by CSS (.chat-message:hover .message-actions)

    // –î–æ–±–∞–≤–∏ listener –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    const reactionBtn = msgEl.querySelector('.message-reaction-btn');
    if (reactionBtn) {
      reactionBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.showReactionPicker(msgEl.dataset.messageId);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ reply
    const replyBtn = msgEl.querySelector('.message-reply-btn');
    if (replyBtn) {
      replyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.startReply(msgEl.dataset.messageId, msgEl);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ options
    const optionsBtn = msgEl.querySelector('.message-options-btn');
    if (optionsBtn) {
      optionsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.showMessageOptions(optionsBtn.dataset.messageId, optionsBtn.dataset.messageKey, optionsBtn);
      });
    }

    // Add listener for profile view
    const avatar = msgEl.querySelector('.message-avatar');
    const author = msgEl.querySelector('.message-author');
    const userId = msgEl.dataset.userId;

    if (avatar) {
        avatar.style.cursor = 'pointer';
        avatar.addEventListener('click', (e) => {
            e.stopPropagation();
            this.showUserProfile(userId);
        });
    }
    if (author) {
        author.style.cursor = 'pointer';
        author.addEventListener('click', (e) => {
            e.stopPropagation();
            this.showUserProfile(userId);
        });
    }
  }

  showMessageOptions(messageId, messageKey, anchorEl) {
    const existingMenu = document.getElementById('message-options-menu');
    if (existingMenu) existingMenu.remove();

    const menu = document.createElement('div');
    menu.id = 'message-options-menu';
    menu.className = 'message-options-menu';
    
    menu.innerHTML = `
      <div class="message-option-item edit">
        <img src="svg/chat/icon-edit.svg" alt="Edit">
        Edit
      </div>
      <div class="message-option-item delete">
        <img src="svg/chat/icon-delete.svg" alt="Delete">
        Delete
      </div>
    `;

    document.body.appendChild(menu);

    const rect = anchorEl.getBoundingClientRect();
    const menuRect = menu.getBoundingClientRect();

    let top = rect.bottom + 5;
    let left = rect.right - menuRect.width;

    if (top + menuRect.height > window.innerHeight) top = rect.top - menuRect.height - 5;
    if (left < 10) left = 10;

    menu.style.top = top + 'px';
    menu.style.left = left + 'px';

    menu.querySelector('.edit').onclick = () => {
      menu.remove();
      this.startEditing(messageId, messageKey);
    };
    menu.querySelector('.delete').onclick = () => {
      menu.remove();
      this.deleteMessage(messageKey);
    };

    const closeMenu = (e) => {
      if (!menu.contains(e.target) && e.target !== anchorEl) {
        menu.remove();
        document.removeEventListener('mousedown', closeMenu);
      }
    };
    document.addEventListener('mousedown', closeMenu);
  }

  startEditing(messageId, messageKey) {
    const msg = this.chatFirebase.messages.find(m => m.id === messageId);
    if (!msg) return;

    const input = this.container.querySelector('.chat-input');
    if (!input) return;

    input.value = msg.text;
    input.focus();
    this.editingMessage = { id: messageId, key: messageKey };
    
    const inputArea = this.container.querySelector('.chat-input-area');
    if (inputArea) {
      inputArea.style.borderTop = '2px solid #588157';
      
      // Add editing indicator
      let editIndicator = inputArea.querySelector('.edit-indicator');
      if (!editIndicator) {
        editIndicator = document.createElement('div');
        editIndicator.className = 'edit-indicator';
        inputArea.prepend(editIndicator);
      }
      
      editIndicator.style.cssText = `
        background: var(--chat-secondary); border-left: 3px solid var(--chat-primary);
        padding: 8px 12px; margin-bottom: 8px; border-radius: 8px;
        font-size: 12px; display: flex; justify-content: space-between; align-items: center;
      `;
      
      editIndicator.innerHTML = `
        <span><strong style="color: var(--chat-primary);">Editing message</strong></span>
        <button class="cancel-edit-btn" style="border:none;background:none;cursor:pointer;font-size:16px;color:var(--chat-primary);padding: 0 4px; line-height: 1;">‚úï</button>
      `;
      
      editIndicator.querySelector('.cancel-edit-btn').onclick = () => this.cancelEditing();
    }
    
    input.placeholder = "Editing message...";
  }

  async editMessage(messageKey, newText) {
    if (await this.chatFirebase.updateMessage(messageKey, { text: newText, edited: true })) {
        this.cancelEditing();
    }
  }

  cancelEditing() {
    this.editingMessage = null;
    const input = this.container.querySelector('.chat-input');
    const inputArea = this.container.querySelector('.chat-input-area');
    if (input) {
      input.value = '';
      input.placeholder = "Write a message...";
    }
    if (inputArea) {
      inputArea.style.borderTop = '1px solid var(--chat-border)';
      const editIndicator = inputArea.querySelector('.edit-indicator');
      if (editIndicator) editIndicator.remove();
    }
  }

  togglePlusMenu() {
    let menu = this.container.querySelector('.chat-plus-menu');
    if (menu) {
      menu.remove();
      return;
    }

    menu = document.createElement('div');
    menu.className = 'chat-plus-menu';
    menu.innerHTML = `
      <div class="plus-menu-item" data-type="gif">
        <img src="svg/chat/icon-gif.svg">
        GIFs
      </div>
      <div class="plus-menu-item" data-type="sticker">
        <img src="svg/chat/icon-sticker.svg">
        Stickers
      </div>
    `;

    this.container.querySelector('.chat-input-area').appendChild(menu);

    menu.querySelectorAll('.plus-menu-item').forEach(item => {
      item.onclick = () => {
        const type = item.dataset.type;
        menu.remove();
        this.toggleMediaPicker(type);
      };
    });

    const closeMenu = (e) => {
      if (!menu.contains(e.target) && !this.container.querySelector('.chat-plus-btn').contains(e.target)) {
        menu.remove();
        document.removeEventListener('mousedown', closeMenu);
      }
    };
    document.addEventListener('mousedown', closeMenu);
  }

  toggleMediaPicker(type = 'gif') {
    let picker = this.container.querySelector('.gif-picker-container');
    if (picker) {
      if (picker.dataset.type === type) {
        picker.remove();
        return;
      }
      picker.remove();
    }

    picker = document.createElement('div');
    picker.className = 'gif-picker-container';
    picker.dataset.type = type;
    picker.innerHTML = `
      <div class="gif-picker-header">
        <input type="text" class="gif-search-input" placeholder="Search ${type === 'gif' ? 'GIFs' : 'stickers'}...">
      </div>
      <div class="gif-results">
        <div style="grid-column: span 2; padding: 20px; text-align: center; font-size: 12px; color: #666;">Loading...</div>
      </div>
    `;

    this.container.querySelector('.chat-input-area').appendChild(picker);

    const searchInput = picker.querySelector('.gif-search-input');
    searchInput.focus();

    this.searchMedia('', picker.querySelector('.gif-results'), type);

    let timeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        this.searchMedia(e.target.value, picker.querySelector('.gif-results'), type);
      }, 500);
    });

    const closePicker = (e) => {
      if (!picker.contains(e.target) && !this.container.querySelector('.chat-plus-btn').contains(e.target)) {
        picker.remove();
        document.removeEventListener('mousedown', closePicker);
      }
    };
    document.addEventListener('mousedown', closePicker);
  }

  async searchMedia(query, resultsContainer, type) {
    const apiKey = 'LIVDSRZULELA'; 
    const limit = 20;
    
    let url;
    if (type === 'sticker') {
        // Use search endpoint with sticker filter for both empty and non-empty queries
        const q = query ? query : 'trending';
        url = `https://g.tenor.com/v1/search?q=${encodeURIComponent(q)}&key=${apiKey}&limit=${limit}&searchfilter=sticker`;
    } else {
        url = query 
          ? `https://g.tenor.com/v1/search?q=${encodeURIComponent(query)}&key=${apiKey}&limit=${limit}`
          : `https://g.tenor.com/v1/trending?key=${apiKey}&limit=${limit}`;
    }

    try {
      const response = await fetch(url);
      const data = await response.json();
      
      resultsContainer.innerHTML = '';
      
      if (data.results && data.results.length > 0) {
        data.results.forEach(result => {
          const media = result.media[0].tinygif;
          const img = document.createElement('img');
          img.className = 'gif-item';
          img.src = media.url;
          
          if (type === 'sticker') {
              img.style.objectFit = 'contain';
              // Checkerboard pattern for transparency
              img.style.background = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uPBBn6DGORjDAFvAUvA9FcDCA9C6f9Uf9D8S5Z7T2Y4YBAAg7MTC6An6SgAAAAASUVORK5CYII=")';
          } else {
              img.style.objectFit = 'cover';
              img.style.background = '#eee';
          }
          
          img.onclick = () => this.selectMedia(media.url);
          resultsContainer.appendChild(img);
        });
      } else {
        resultsContainer.innerHTML = '<div style="grid-column: span 2; padding: 20px; text-align: center; font-size: 12px; color: #666;">No results</div>';
      }
    } catch (e) {
      console.error('Media search error:', e);
      resultsContainer.innerHTML = '<div style="grid-column: span 2; padding: 20px; text-align: center; font-size: 12px; color: #ef4444;">Error loading</div>';
    }
  }

  selectMedia(url) {
    this.chatFirebase.sendMessage(url);
    const picker = this.container.querySelector('.gif-picker-container');
    if (picker) picker.remove();
  }

  // Renaming old methods to stay consistent with new logic
  toggleGifPicker() { this.toggleMediaPicker('gif'); }
  async searchGifs(q, r) { this.searchMedia(q, r, 'gif'); }
  selectGif(u) { this.selectMedia(u); }

  updateHeaderOnlineCount(count) {
    const onlineCountEl = this.container.querySelector('.chat-online-count');
    if (onlineCountEl) {
        onlineCountEl.textContent = `Active: ${count || 1}`;
    }
  }

  updateActiveCount(data) {
    const badgeEl = document.querySelector('.chat-badge-count');
    const icon = document.querySelector('.chat-icon');
    
    // –ü–æ–∫–∞–∑–∏ –±—Ä–æ–π –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –°–ê–ú–û –∞–∫–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ç–∞ —Å–∞ –≤–∫–ª—é—á–µ–Ω–∏ –ò —á–∞—Ç—ä—Ç –µ –∑–∞—Ç–≤–æ—Ä–µ–Ω
    if (badgeEl) {
      if (this.notificationsDisabled || this.isOpen) {
        badgeEl.style.display = 'none';
        if (icon) icon.classList.remove('has-mention');
      } else {
        badgeEl.textContent = this.unreadCount;
        badgeEl.style.display = this.unreadCount > 0 ? 'flex' : 'none';
        
        // Remove mention highlight if no unread messages have a mention
        if (icon && !this.unreadHasMention) {
            icon.classList.remove('has-mention');
        }
      }
    }
  }

  // updateNotificationButton removed (duplicate logic)


  // updateActiveSidebar removed - replaced by updateNotificationButton

  showNotification() {
    const icon = document.querySelector('.chat-icon');
    if (icon) {
      icon.classList.add('has-notification');
      setTimeout(() => {
        icon.classList.remove('has-notification');
      }, 3000);
    }
  }

  showMentionNotification() {
    const icon = document.querySelector('.chat-icon');
    if (icon) {
      icon.classList.add('has-mention');
      // Special mention doesn't auto-remove as quickly as pulse
      // It stays until chat is opened or markAsRead is called
    }
    
    // Optional: Play sound if permitted
    try {
        const audio = new Audio('https://assets.mixkit.co/active_storage/sfx/2358/2358-preview.mp3');
        audio.volume = 0.5;
        audio.play().catch(e => console.log('Audio play blocked by browser'));
    } catch (e) {}
  }

  markAsRead() {
    const icon = document.querySelector('.chat-icon');
    if (icon) icon.classList.remove('has-mention');

    const messages = this.chatFirebase.messages;
    if (messages.length > 0) {
      // Always mark up to the absolute last message in the list
      const lastMessage = messages[messages.length - 1];
      const newLastReadId = lastMessage.id;

      // Update local state
      this.lastReadMessageId = newLastReadId;
      localStorage.setItem(`lastReadMessage_${this.documentId}`, newLastReadId);
      this.unreadCount = 0;
      this.updateActiveCount();
      
      // Synchronize with Firebase
      this.chatFirebase.setLastRead(currentUser.userName, newLastReadId);
    }
  }

  scrollToBottom() {
    const messagesContainer = this.container.querySelector('.chat-messages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  showReactionPicker(messageId) {
    // –ü—Ä–µ–º–∞—Ö–Ω–∏ —Å—Ç–∞—Ä picker –∞–∫–æ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
    const oldPicker = document.querySelector('.reaction-picker');
    if (oldPicker) oldPicker.remove();

    const emojis = ['üëç', 'üëé', 'üòÇ', '‚ù§Ô∏è', 'üò≠', 'üòÆ', 'üêê'];
    
    const picker = document.createElement('div');
    picker.className = 'reaction-picker';
    picker.style.cssText = `
      position: fixed;
      background: white;
      border: 1px solid var(--chat-border);
      border-radius: 20px;
      padding: 6px 10px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      z-index: 10000;
    `;

    const addEmojiButton = (emoji, messageId) => {
      const btn = document.createElement('button');
      btn.textContent = emoji;
      btn.style.cssText = `
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        padding: 4px;
        border-radius: 50%;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      btn.addEventListener('mouseenter', () => btn.style.background = 'var(--chat-secondary)');
      btn.addEventListener('mouseleave', () => btn.style.background = 'none');
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.addReaction(messageId, emoji);
        picker.remove();
        document.removeEventListener('click', closePicker);
      });
      return btn;
    };

    // –î–æ–±–∞–≤–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ –µ–º–æ–¥–∂–∏—Ç–∞
    emojis.forEach(emoji => {
      picker.appendChild(addEmojiButton(emoji, messageId));
    });

    // –î–æ–±–∞–≤–∏ –±—É—Ç–æ–Ω –∑–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ —Ä–µ–∞–∫—Ü–∏—è
    const customBtn = document.createElement('button');
    customBtn.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    `;
    customBtn.title = "–î–æ–±–∞–≤–∏ –¥—Ä—É–≥–∞ —Ä–µ–∞–∫—Ü–∏—è";
    customBtn.style.cssText = `
      background: #f3f4f6;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
      color: #6b7280;
      transition: all 0.2s;
    `;
    customBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const customEmoji = prompt("–í—ä–≤–µ–¥–∏ –µ–º–æ–¥–∂–∏ –∏–ª–∏ –∫—Ä–∞—Ç—ä–∫ —Ç–µ–∫—Å—Ç –∑–∞ —Ä–µ–∞–∫—Ü–∏—è:");
      if (customEmoji && customEmoji.trim()) {
        this.addReaction(messageId, customEmoji.trim().substring(0, 5));
      }
      picker.remove();
      document.removeEventListener('click', closePicker);
    });
    picker.appendChild(customBtn);

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π picker –¥–æ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
    const msgEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (msgEl) {
      const rect = msgEl.getBoundingClientRect();
      document.body.appendChild(picker);
      
      const pickerRect = picker.getBoundingClientRect();
      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π –≤ –≥–æ—Ä–Ω–∏—è –¥–µ—Å–µ–Ω —ä–≥—ä–ª –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
      let left = rect.right - pickerRect.width;
      let top = rect.top - pickerRect.height - 5;
      
      // –û—Å–∏–≥—É—Ä–∏ –¥–∞ –Ω–µ –∏–∑–ª–∏–∑–∞ –∏–∑–≤—ä–Ω –µ–∫—Ä–∞–Ω–∞ –Ω–∞–ª—è–≤–æ
      if (left < 10) left = 10;
      
      picker.style.left = left + 'px';
      picker.style.top = top + 'px';
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ picker
    const closePicker = (e) => {
      if (!picker.contains(e.target) && !e.target.closest('.message-reaction-btn')) {
        picker.remove();
        document.removeEventListener('click', closePicker);
      }
    };
    
    document.addEventListener('click', closePicker);
  }

  async addReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.addReaction(messageId, emoji);
  }

  showReactionTooltip(badgeElement) {
    this.hideReactionTooltip(); // –°–∫—Ä–∏–π –ø—Ä–µ–¥–∏—à–Ω–∏, –∞–∫–æ –∏–º–∞

    const messageId = badgeElement.dataset.messageId;
    const emoji = badgeElement.dataset.emoji;

    if (!this.reactionsCache || !this.reactionsCache[messageId] || !this.reactionsCache[messageId][emoji]) {
      return;
    }

    const reactors = this.reactionsCache[messageId][emoji];
    const reactorIds = Object.keys(reactors).filter(id => reactors[id] === true);

    if (reactorIds.length === 0) {
      return;
    }

    // –°—ä–∑–¥–∞–π –∫–∞—Ä—Ç–∞ –Ω–∞ userId -> userName –æ—Ç –≤—Å–∏—á–∫–∏ –Ω–∞–ª–∏—á–Ω–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏
    const userMap = {};
    // 1. –û—Ç –∞–∫—Ç–∏–≤–Ω–∏—Ç–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ (–Ω–∞–π-–∞–∫—Ç—É–∞–ª–Ω–∏ –∏–º–µ–Ω–∞)
    for (const userId in this.activeUsers) {
        userMap[userId] = this.activeUsers[userId].userName;
    }
    // 2. –û—Ç –∏—Å—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞ (–∑–∞ –æ—Ñ–ª–∞–π–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏)
    this.chatFirebase.messages.forEach(msg => {
        if (!userMap[msg.userId]) {
            userMap[msg.userId] = msg.userName;
        }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–π ID-—Ç–∞—Ç–∞ –≤ –∏–º–µ–Ω–∞
    const reactorNames = reactorIds.map(id => {
        const rawName = userMap[id] || '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω';
        const resolvedName = this.resolveName(rawName);
        const isMe = this._getMyUserIds().includes(id);
        // –ú–∞—Ä–∫–∏—Ä–∞–π —Ç–µ–∫—É—â–∏—è –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª
        return isMe ? `<strong>${this.escapeHtml(resolvedName)} (–ê–∑)</strong>` : this.escapeHtml(resolvedName);
    }).join('<br>');

    const tooltip = document.createElement('div');
    tooltip.id = 'reaction-tooltip';
    tooltip.className = 'reaction-tooltip';
    tooltip.innerHTML = reactorNames;

    document.body.appendChild(tooltip);

    const badgeRect = badgeElement.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π –Ω–∞–¥ –±—É—Ç–æ–Ω–∞, —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–Ω–æ
    let top = badgeRect.top - tooltipRect.height - 5;
    let left = badgeRect.left + (badgeRect.width / 2) - (tooltipRect.width / 2);

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
  }

  hideReactionTooltip() {
    const tooltip = document.getElementById('reaction-tooltip');
    if (tooltip) {
      tooltip.remove();
    }
  }

  renderAllReactions() {
    if (!this.reactionsCache) return;
    
    const messageElements = this.container.querySelectorAll('.chat-message[data-message-id]');
    messageElements.forEach(msgEl => {
        const messageId = msgEl.dataset.messageId;
        const reactionsContainer = msgEl.querySelector('.message-reactions');
        if (reactionsContainer) {
            const newHTML = this.getReactionsHTML(messageId);
            // Only update if changed to prevent flicker
            if (reactionsContainer.innerHTML !== newHTML) {
                // If we are about to replace the HTML, hide any active tooltip 
                // because the element being hovered might disappear
                this.hideReactionTooltip();
                
                reactionsContainer.innerHTML = newHTML;
                this.attachReactionBadgeListeners(msgEl);
            }
        }
    });
  }

  getReactionsHTML(messageId) {
    const reactionsForMessage = this.reactionsCache ? this.reactionsCache[messageId] : null;
    if (!reactionsForMessage) return '';

    const reactionCounts = {};
    const myReactions = {};
    
    const myUserIds = this._getMyUserIds(); // –í–∑–µ–º–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ userId-—Ç–∞

    Object.keys(reactionsForMessage).forEach(emoji => {
        const usersObj = reactionsForMessage[emoji] || {};
        const userIdsWhoReacted = Object.keys(usersObj).filter(userId => usersObj[userId] === true);
        const count = userIdsWhoReacted.length;
        
        if (count > 0) {
            reactionCounts[emoji] = count;
            // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –Ω—è–∫–æ–µ –æ—Ç –º–æ–∏—Ç–µ userId-—Ç–∞ –µ —Ä–µ–∞–≥–∏—Ä–∞–ª–æ
            if (userIdsWhoReacted.some(id => myUserIds.includes(id))) {
                myReactions[emoji] = true;
            }
        }
    });
      
    if (Object.keys(reactionCounts).length === 0) {
        return '';
    }

    return Object.keys(reactionCounts).map(emoji => `
        <button class="reaction-badge" data-emoji="${emoji}" data-message-id="${messageId}" 
          style="background: ${myReactions[emoji] ? '#93c5fd' : '#f0f0f0'}; border: none; border-radius: 12px; padding: 4px 8px; margin-right: 4px; cursor: pointer; font-size: 12px; font-weight: ${myReactions[emoji] ? 'bold' : 'normal'};">
          ${emoji} <span>${reactionCounts[emoji]}</span>
        </button>
      `).join('');
  }

  attachReactionBadgeListeners(element) {
    const container = element.querySelector('.message-reactions');
    if (!container) return;

    container.querySelectorAll('.reaction-badge').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const emoji = btn.dataset.emoji;
        const msgId = btn.dataset.messageId;
        
        const reactionsForMessage = this.reactionsCache ? this.reactionsCache[msgId] : null;
        if (!reactionsForMessage) {
            this.addReaction(msgId, emoji);
            return;
        }

        const myUserIds = this._getMyUserIds();
        const reactorsForEmoji = reactionsForMessage[emoji] || {};
        
        const myReactingIds = myUserIds.filter(id => reactorsForEmoji[id] === true);

        if (myReactingIds.length > 0) {
          // –ü—Ä–µ–º–∞—Ö–Ω–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ —Ä–µ–∞–∫—Ü–∏–∏ –∑–∞ —Ç–æ–≤–∞ –µ–º–æ–¥–∂–∏
          this.chatFirebase.bulkRemoveReactions(msgId, emoji, myReactingIds);
        } else {
          // –î–æ–±–∞–≤–∏ –Ω–æ–≤–∞ —Ä–µ–∞–∫—Ü–∏—è
          this.addReaction(msgId, emoji);
        }
      });

      // –î–æ–±–∞–≤–∏ hover —Å–ª—É—à–∞—Ç–µ–ª–∏ –∑–∞ tooltip
      btn.addEventListener('mouseenter', e => {
        this.showReactionTooltip(e.currentTarget);
      });
      btn.addEventListener('mouseleave', () => {
        this.hideReactionTooltip();
      });
    });
  }

  async removeReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.removeReaction(messageId, emoji);
  }

  startReply(messageId, messageEl) {
    // Find message text and author
    const textEl = messageEl.querySelector('.message-text');
    const authorEl = messageEl.querySelector('.message-author');
    
    if (!textEl || !authorEl) return;

    const author = authorEl.textContent;
    const text = textEl.dataset.rawText || textEl.textContent;

    // Put reply info in input field
    const input = this.container.querySelector('.chat-input');
    if (input) {
      input.dataset.replyTo = messageId;
      input.dataset.replyAuthor = author;
      input.dataset.replyText = text;
      
      const inputArea = this.container.querySelector('.chat-input-area');
      this.fixInputLayout();
      
      let replyIndicator = inputArea.querySelector('.reply-indicator');
      
      if (!replyIndicator) {
        replyIndicator = document.createElement('div');
        replyIndicator.className = 'reply-indicator';
        inputArea.prepend(replyIndicator);
      }

      replyIndicator.style.cssText = `
        background: var(--chat-secondary); border-left: 3px solid var(--chat-primary);
        padding: 8px 12px; margin-bottom: 8px; border-radius: 8px;
        font-size: 12px; display: flex; justify-content: space-between; align-items: flex-start;
        gap: 10px;
      `;

      // Limit preview text length
      const textPreview = text.length > 60 ? text.substring(0, 57) + '...' : text;

      replyIndicator.innerHTML = `
        <div style="flex: 1; min-width: 0;">
          <div style="font-weight: bold; color: var(--chat-primary); margin-bottom: 2px;">Replying to ${this.escapeHtml(author)}</div>
          <div style="opacity: 0.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(textPreview)}</div>
        </div>
        <button onclick="const input = this.closest('.chat-input-area').querySelector('.chat-input'); if(input) { input.dataset.replyTo=''; input.dataset.replyAuthor=''; input.dataset.replyText=''; } this.closest('.reply-indicator').remove();" style="border:none;background:none;cursor:pointer;font-size:16px;color:#64748b;padding: 0 4px; line-height: 1;">‚úï</button>
      `;

      input.focus();
    }
  }

  toggleChat() {
    if (!this.container) {
      console.error('Container not found!');
      return;
    }
    this.isOpen = !this.isOpen;
    const chatPanel = this.container.querySelector('.chat-panel');
    if (chatPanel) {
      chatPanel.classList.toggle('open', this.isOpen);
      if (this.isOpen) {
        const input = this.container.querySelector('.chat-input');
        // if (input) input.focus(); // Removed to prevent keyboard popup on mobile
        
        // –ú–∞—Ä–∫–∏—Ä–∞–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞ –∫–∞—Ç–æ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏
        this.markAsRead();

        // –ü—Ä–µ–≤—ä—Ä—Ç–∏ –¥–æ –¥–æ–ª—É –≤–µ–¥–Ω–∞–≥–∞ –∏ —Å–ª–µ–¥ –º–∞–ª–∫–æ –∑–∞–∫—ä—Å–Ω–µ–Ω–∏–µ (–∑–∞—Ä–∞–¥–∏ –∞–Ω–∏–º–∞—Ü–∏—è—Ç–∞)
        this.scrollToBottom();
        setTimeout(() => this.scrollToBottom(), 100);
        setTimeout(() => this.scrollToBottom(), 300);
      }
    }
  }

  formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    
    const isToday = date.getDate() === now.getDate() &&
                    date.getMonth() === now.getMonth() &&
                    date.getFullYear() === now.getFullYear();

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    
    if (isToday) {
      return `${hours}:${minutes}`;
    } else {
      const month = date.toLocaleString('en-US', { month: 'short' });
      const day = date.getDate();
      return `${month} ${day}, ${hours}:${minutes}`;
    }
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  linkifyText(text) {
    // 1. Escape HTML
    let processed = this.escapeHtml(text);
    
    // 2. Markdown Support (Bold and Italic)
    // Bold: **text** -> <strong>text</strong>
    processed = processed.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    
    // Italic: *text* -> <em>text</em>
    // Use a regex that requires non-whitespace content to avoid matching simple asterisks
    processed = processed.replace(/\*(?!\s)(.*?)(?<!\s)\*/g, '<em>$1</em>');

    // 3. Newlines
    processed = processed.replace(/\n/g, '<br>');
    
    // 4. Mentions (@username)
    const currentName = window.currentUser ? (window.currentUser.userName || window.currentUser.displayName || "").toLowerCase() : "";
    
    processed = processed.replace(/@([a-zA-Z0-9–ê-–Ø–∞-—è._-]+)/g, (match, username) => {
        const lowerName = username.toLowerCase();
        
        // Special case: @everyone
        if (lowerName === 'everyone') {
            return `<span class="mention-everyone" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); font-weight: 700; padding: 0 4px; border-radius: 4px;">@everyone</span>`;
        }

        const isMe = lowerName === currentName && currentName !== "";
        
        // Find user color
        let userColor = '#3a5a40'; // Default Fern Green
        
        // Search in profiles
        if (this.userProfiles) {
            const profile = Object.values(this.userProfiles).find(p => 
                (p.username || p.displayName || p.userName || "").toLowerCase() === lowerName
            );
            if (profile && profile.color) userColor = profile.color;
        }
        
        // If not found, check active users
        if (userColor === '#3a5a40' && this.chatFirebase && this.chatFirebase.activeUsers) {
            const activeUser = Object.values(this.chatFirebase.activeUsers).find(u => 
                (u.displayName || u.userName || u.username || "").toLowerCase() === lowerName
            );
            if (activeUser && activeUser.color) userColor = activeUser.color;
        }

        // If STILL not found, check message history (fallback for offline users not in allUsers)
        if (userColor === '#3a5a40' && this.chatFirebase && this.chatFirebase.messages) {
            const lastMsg = [...this.chatFirebase.messages].reverse().find(m => 
                (m.userName || "").toLowerCase() === lowerName
            );
            if (lastMsg && lastMsg.userColor) userColor = lastMsg.userColor;
        }

        if (isMe) {
            // Self-mention: Back to using user's color for text + light background
            return `<span class="mention-me" style="color: ${userColor}; background-color: ${userColor}26; border: 1px solid ${userColor}40;">@${username}</span>`;
        } else {
            // Others: Use user's color for text, light background
            return `<span class="mention" style="color: ${userColor}; background-color: ${userColor}26; border: 1px solid ${userColor}40;">@${username}</span>`;
        }
    });

    // 5. Linkify and Image Preview
    const urlRegex = /(https?:\/\/[^\s<>\[\]{}|\\^`"]*)/g;
    return processed.replace(urlRegex, (url) => {
      const isImage = /\.(jpeg|jpg|gif|png|webp)(\?.*)?$/i.test(url);
      
      if (isImage) {
          return `
            <div class="chat-image-preview" style="margin-top: 5px;">
              <a href="${url}" target="_blank">
                <img src="${url}" alt="Image" style="max-width: 100%; max-height: 200px; border-radius: 8px; border: 1px solid var(--chat-border); display: block; cursor: pointer;">
              </a>
            </div>
          `;
      }
      
      return `<a href="${url}" target="_blank" style="color: #4ade80; text-decoration: underline; cursor: pointer;">${url}</a>`;
    });
  }

  async deleteMessage(messageKey) {
        if (await this.chatFirebase.deleteMessage(messageKey)) {
            // Hide tooltip if it was showing for this message
            this.hideReactionTooltip();
            
            // –ü—Ä–µ–º–∞—Ö–Ω–∏ –ª–æ–∫–∞–ª–Ω–æ –≤–µ–¥–Ω–∞–≥–∞ —Å –∞–Ω–∏–º–∞—Ü–∏—è
            const messagesContainer = this.container.querySelector('.chat-messages');
            const messageEl = messagesContainer.querySelector(`[data-message-key="${messageKey}"]`);
            if (messageEl) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    messageEl.remove();
                }, 300);
            }
        } else {
            console.error('Failed to delete message via SDK');
        }
  }

  destroy() {
    this.chatFirebase.stop();
  }
}

// ============================================
// PART 4: INITIALIZATION
// ============================================

(async function initializeChat() {
  // console.log('Chat init...'); // Can be removed

  // Listen for changes in localStorage to sync user data across tabs
  window.addEventListener('storage', (event) => {
    if (event.key === 'loggedInUser' && event.newValue) {
      try {
        const newUserData = JSON.parse(event.newValue);
        // Check if the update is for the currently logged-in user
        if (window.currentUser && newUserData.uid === window.currentUser.userId) {
          // console.log('User data updated from another tab. Refreshing local state.'); // Can be removed
          
          // Update the global currentUser object
          Object.assign(window.currentUser, newUserData);
          
          // Force an immediate presence update with the new data (e.g., new color)
          if (window.chatManager && window.chatManager.chatFirebase) {
              window.chatManager.chatFirebase.forceUpdatePresence();
          }
        }
      } catch (e) { console.error('Error processing storage event:', e); }
    }
  });

  // Wait for the user identity to be resolved before doing anything else
  await window.currentUserPromise;
  
  let attempts = 0;
  const maxAttempts = 20;
  let chatInitialized = false;

  const CHAT_WIDGET_HTML = `
<div id="chat-widget" class="chat-widget">
  <button class="chat-icon" id="chat-toggle" title="Open Chat">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
    <span class="chat-badge-count" style="display: none;">0</span>
    <span class="chat-notification-pulse"></span>
  </button>

  <div class="chat-panel">
    <div class="chat-header">
      <div class="chat-header-title">
        <div style="font-size: 18px; font-weight: bold; margin: 0;">Chat</div>
        <span class="chat-online-count" style="font-size: 12px; color: #10b981;">Active: 1</span>
      </div>
      <div style="display: flex; gap: 8px;">
        <button class="chat-header-btn" id="toggle-notifications" title="Notifications">
          <img src="svg/chat/${this.notificationsDisabled ? 'icon-notifications-disabled.svg' : 'icon-notifications-enabled.svg'}" 
               style="width: ${this.notificationsDisabled ? '18px' : '20px'}; height: ${this.notificationsDisabled ? '18px' : '20px'}; filter: brightness(0) invert(1);">
        </button>
        <button class="chat-header-btn" id="chat-members-toggle" title="Active Members">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
        </button>
        <button class="chat-close-btn" id="chat-close" title="Close Chat">‚úï</button>
      </div>
    </div>

    <div class="chat-container">
      <div class="chat-messages-wrapper">
        <div class="chat-messages"></div>
      </div>
      <div class="chat-active-users"></div>
    </div>

    <div class="chat-input-area">
      <div id="mention-suggestions" class="mention-suggestions" style="display: none;"></div>
      <div class="chat-controls-row">
        <button class="chat-plus-btn" title="More options">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M13 9C13 8.44772 12.5523 8 12 8C11.4477 8 11 8.44772 11 9V11H9C8.44772 11 8 11.4477 8 12C8 12.5523 8.44772 13 9 13H11V15C11 15.5523 11.4477 16 12 16C12.5523 16 13 15.5523 13 15V13H15C15.5523 13 16 12.5523 16 12C16 11.4477 15.5523 11 15 11H13V9ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12Z"></path>
          </svg>
        </button>
        <textarea
          class="chat-input"
          placeholder="Write a message..."
          maxlength="500"
          rows="1"
        ></textarea>
        <button class="chat-send-btn" title="Send">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M16.6915026,12.4744748 L3.50612381,13.2599618 C3.19218622,13.2599618 3.03521743,13.4170592 3.03521743,13.5741566 L1.15159189,20.0151496 C0.8376543,20.8006365 0.99,21.89 1.77946707,22.52 C2.41,22.99 3.50612381,23.1 4.13399899,22.8429026 L21.714504,14.0454487 C22.6563168,13.5741566 23.1272231,12.6315722 22.9702544,11.6889879 L4.13399899,1.16151496 C3.34915502,0.9 2.40734225,0.9 1.77946707,1.4429026 C0.994623095,2.08 0.837654326,3.0226 1.15159189,3.97788954 L3.03521743,10.4188814 C3.03521743,10.5759788 3.34915502,10.7330762 3.50612381,10.7330762 L16.6915026,11.5185631 C16.6915026,11.5185631 17.1624089,11.5185631 17.1624089,12.0598639 C17.1624089,12.4744748 16.6915026,12.4744748 16.6915026,12.4744748 Z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<style>
.chat-plus-btn {
  width: 36px;
  height: 36px;
  border: none;
  background: var(--chat-primary);
  color: white;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex-shrink: 0;
  margin-right: 6px;
}
.chat-plus-btn:hover {
  transform: scale(1.05);
}
.chat-plus-btn:active {
  transform: scale(0.95);
}
.chat-plus-menu {
  position: absolute;
  bottom: 100%;
  left: 0;
  background: white;
  border-radius: 12px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
  border: 1px solid var(--chat-border);
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  z-index: 10004;
  margin-bottom: 10px;
  min-width: 140px;
}
.plus-menu-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
  color: var(--chat-text);
}
.plus-menu-item:hover {
  background: var(--chat-secondary);
}
.plus-menu-item img {
  width: 24px;
  height: 24px;
  filter: invert(48%) sepia(13%) saturate(1063%) hue-rotate(68deg) brightness(92%) contrast(85%);
}
.chat-gif-btn {
  display: none; /* Replaced by plus button */
}
.gif-picker-container {
  position: absolute;
  bottom: 100%;
  right: 0;
  width: 250px;
  height: 350px;
  background: white;
  border: 1px solid var(--chat-border);
  border-radius: 12px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
  display: flex;
  flex-direction: column;
  z-index: 10003;
  margin-bottom: 10px;
  overflow: hidden;
}
.gif-picker-header {
  padding: 8px;
  border-bottom: 1px solid #eee;
}
.gif-search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid #ddd;
  border-radius: 20px;
  font-size: 13px;
  outline: none;
}
.gif-results {
  flex: 1;
  overflow-y: auto;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
  padding: 4px;
}
.gif-item {
  width: 100%;
  height: 100px;
  object-fit: cover;
  cursor: pointer;
  border-radius: 8px;
  transition: opacity 0.2s;
}
.gif-item:hover {
  opacity: 0.8;
}
#chat-widget {
  --chat-primary: #588157;
  --chat-secondary: #f0ede2;
  --chat-border: #a3b18a;
  --chat-text: #000000;
  --chat-text-light: #000000;
}
.chat-widget {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 5000;
  font-family: 'Open Sans', Arial, sans-serif;
}
.chat-icon {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: var(--chat-primary);
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(58, 90, 64, 0.3);
  transition: all 0.3s ease;
  position: relative;
}
.chat-icon:hover {
  background: #344e41;
  box-shadow: 0 6px 16px rgba(93, 64, 55, 0.5);
  transform: scale(1.1);
}
.chat-badge-count {
  position: absolute;
  top: -8px;
  right: -8px;
  background: #ef4444;
  color: white;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  border: 2px solid white;
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  transition: all 0.3s ease;
}
.chat-icon.has-mention .chat-badge-count {
  background: #f59e0b !important;
  box-shadow: 0 0 12px #f59e0b;
}
.chat-notification-pulse {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 16px;
  height: 16px;
  background: #22c55e;
  border-radius: 50%;
  border: 2px solid white;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.chat-panel {
  position: fixed;
  bottom: 90px;
  right: 20px;
  width: 550px;
  height: 600px;
  background: white;
  border-radius: 12px;
  box-shadow: 0 5px 40px rgba(0, 0, 0, 0.16);
  display: flex;
  flex-direction: column;
  opacity: 0;
  pointer-events: none;
  transform: translateY(20px);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.chat-panel.open {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
}
.chat-header {
  padding: 16px;
  border-bottom: 1px solid var(--chat-border);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  background: var(--chat-primary);
  color: white;
  border-radius: 12px 12px 0 0;
}
.chat-header-title h3 {
  margin: 0 0 4px 0;
  font-size: 16px;
  font-weight: 600;
}
.chat-online-count {
  font-size: 12px;
  opacity: 0.9;
  display: none;
}
.chat-header-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  transition: background 0.2s;
}
.chat-header-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}
#chat-members-toggle {
  position: relative;
}
.chat-panel:not(.show-members) #chat-members-toggle::after {
  content: "";
  position: absolute;
  top: 15%;
  left: 50%;
  width: 2px;
  height: 70%;
  background: white;
  transform: translateX(-50%) rotate(-45deg);
  border-radius: 1px;
  box-shadow: 0 0 2px rgba(0,0,0,0.3);
}
.chat-close-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  width: 32px;
  height: 32px;
  font-size: 18px;
  color: white;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s;
}
.chat-close-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}
.chat-container {
  display: flex;
  flex: 1;
  min-height: 0;
  gap: 0;
}
.chat-messages-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}
.chat-messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 12px 0;
  display: flex;
  flex-direction: column;
  gap: 0;
}
.chat-date-separator {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 16px 0 8px 0;
  padding: 0 16px;
  height: 1px;
  background: var(--chat-border);
  position: relative;
  flex-shrink: 0;
}
.chat-date-separator span {
  background: white;
  padding: 2px 10px;
  font-size: 11px;
  font-weight: 600;
  color: var(--chat-text-light);
  transform: translateY(-50%);
  position: absolute;
  top: 50%;
}
.chat-message {
  display: flex;
  gap: 8px;
  animation: slideIn 0.3s ease;
  /* margin-bottom controlled by inline styles (1px continuation, 6px new group) */
}
@keyframes slideIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  font-size: 14px;
  flex-shrink: 0;
  object-fit: cover;
}
.message-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 2px;
  margin-right: 80px; /* Increased to fit action buttons */
}
.message-header {
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.message-author {
  font-weight: 600;
  font-size: 13px;
  color: var(--chat-text);
}
.message-time {
  font-size: 11px;
  color: var(--chat-text-light);
}
.message-text {
  font-size: 13px;
  color: var(--chat-text);
  word-break: break-word;
  background: var(--chat-secondary);
  padding: 4px 10px;
  border-radius: 8px;
  line-height: 1.4;
  box-sizing: border-box;
  max-width: 100%;
  width: fit-content;
}
.mention {
  background: rgba(88, 129, 87, 0.15);
  color: #3a5a40;
  padding: 0 4px;
  border-radius: 4px;
  font-weight: 600;
  display: inline-block;
}
.mention-me {
  background: #588157;
  color: white;
  padding: 0 4px;
  border-radius: 4px;
  font-weight: 600;
  display: inline-block;
}
.chat-active-users {
  width: 120px;
  padding: 4px 2px;
  border-left: 1px solid var(--chat-border);
  overflow-y: auto;
  background: #fafafa;
  display: none;
  flex-direction: column;
  gap: 8px;
  min-width: 0;
}
.chat-panel.show-members .chat-active-users {
  display: flex;
}
.active-users-header {
  font-size: 11px;
  font-weight: 600;
  color: var(--chat-text-light);
  padding: 0 4px;
  text-transform: uppercase;
}
.active-user {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: var(--chat-text);
  padding: 4px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  min-width: 0;
}
.active-user:hover {
  background: var(--chat-secondary);
}
.active-user-badge {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  font-size: 11px;
  flex-shrink: 0;
}
.active-user span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 11px;
}
.chat-input-area {
  display: flex;
  flex-direction: column;
  padding: 12px;
  border-top: 1px solid var(--chat-border);
  background: #fff;
  position: relative;
}
.mention-suggestions {
  position: absolute;
  bottom: 100%;
  left: 12px;
  right: 12px;
  background: white;
  border: 1px solid var(--chat-border);
  border-radius: 8px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
  max-height: 200px;
  overflow-y: auto;
  z-index: 100;
  margin-bottom: 5px;
}
.suggestion-item {
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: background 0.2s;
  font-size: 13px;
}
.suggestion-item:hover, .suggestion-item.active {
  background: var(--chat-secondary);
}
.suggestion-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--chat-primary);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: bold;
}
.chat-controls-row {
  display: flex;
  align-items: center;
  width: 100%;
}
.chat-tool-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  margin-right: 4px;
  color: var(--chat-text-light);
}
.chat-tool-btn:hover {
  color: var(--chat-primary);
}
.chat-input {
  flex: 0.98;
  border: 1px solid var(--chat-border);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 13px;
  font-family: inherit;
  outline: none;
  transition: all 0.2s;
  resize: none;
}
.chat-input:focus {
  border-color: var(--chat-primary);
  box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
}
.chat-send-btn {
  width: 36px;
  height: 36px;
  border: none;
  background: var(--chat-primary);
  color: white;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex-shrink: 0;
}
.chat-send-btn:hover {
  transform: scale(1.05);
}
.chat-send-btn:active {
  transform: scale(0.95);
}
.chat-user-info {
  padding: 8px 12px;
  font-size: 11px;
  color: var(--chat-text-light);
  border-top: 1px solid var(--chat-border);
  background: #fafafa;
  border-radius: 0 0 12px 12px;
}
#current-user-name {
  color: var(--chat-primary);
  font-weight: 600;
}
@media (max-width: 600px) {
  .chat-panel {
    width: calc(100vw - 40px);
    height: 65vh;
    bottom: 100px;
    right: 20px;
    left: 20px;
    max-width: none;
  }
  .chat-active-users {
    display: none;
  }
  .chat-panel.show-members .chat-active-users {
    display: flex;
    position: absolute;
    right: 0;
    top: 75px;
    bottom: 67px;
    z-index: 15;
    box-shadow: -2px 0 10px rgba(0,0,0,0.1);
    margin-top: -10px;
    align-self: stretch;
  }
  .chat-online-count {
    display: none !important;
  }
  .chat-widget {
    bottom: 10px;
    right: 10px;
  }
  .chat-icon {
    width: 48px;
    height: 48px;
  }
}
.chat-messages::-webkit-scrollbar {
  width: 6px;
}
.chat-active-users::-webkit-scrollbar {
  width: 3px;
}
.chat-messages::-webkit-scrollbar-track,
.chat-active-users::-webkit-scrollbar-track {
  background: transparent;
}
.chat-messages::-webkit-scrollbar-thumb,
.chat-active-users::-webkit-scrollbar-thumb {
  background: var(--chat-border);
  border-radius: 3px;
}
.chat-messages::-webkit-scrollbar-thumb:hover,
.chat-active-users::-webkit-scrollbar-thumb:hover {
  background: var(--chat-text-light);
}
.chat-messages a {
  color: #4ade80 !important;
  text-decoration: underline !important;
  cursor: pointer !important;
}
.message-text strong {
  font-weight: 700;
  color: inherit;
}
.message-text em {
  font-style: italic;
  color: inherit;
}
.typing-indicator-container {
  position: absolute;
  bottom: 4px;
  left: 0;
  width: 100%;
  padding: 2px 12px;
  font-size: 10px;
  color: #9ca3af;
  min-height: 16px;
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.8);
  pointer-events: none;
  z-index: 5;
}
.typing-dots {
  display: inline-flex;
  align-items: center;
  gap: 2px;
}
.typing-dot {
  width: 3px;
  height: 3px;
  background-color: #9ca3af;
  border-radius: 50%;
  animation: typingBounce 1.4s infinite ease-in-out both;
}
.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}
</style>
`;

  async function loadChatWidget() {
    if (document.getElementById('chat-widget')) return true;

    try {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = CHAT_WIDGET_HTML;
      
      // Inject CSS
      const style = tempDiv.querySelector('style');
      if (style) document.head.appendChild(style);
      
      // Inject HTML
      const widget = tempDiv.querySelector('#chat-widget');
      if (widget) {
        document.body.appendChild(widget);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error loading chat widget:', error);
      return false;
    }
  }

  async function tryInit() {
    if (chatInitialized) return;
    
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => tryInit());
      return;
    } 
    
    attempts++;
    
    // 1. Try to load the widget if missing
    if (!document.getElementById('chat-widget')) {
      await loadChatWidget();
    }

    // 2. Check if widget now exists
    const widget = document.getElementById('chat-widget');
    if (widget) {
      chatInitialized = true;
      initChat();
      return;
    }

    // 3. Retry if not found
    if (attempts < maxAttempts) {
      setTimeout(tryInit, 150);
    } else {
      console.error('Chat system: Failed to find or load #chat-widget after multiple attempts.');
    }
  }

  function initChat() {
    // console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º Chat UI...'); // Can be removed
    
    const chatWidget = document.getElementById('chat-widget');
    if (!chatWidget) {
      console.error('Chat widget –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }

    // –ì–õ–û–ë–ê–õ–ï–ù –ß–ê–¢ –ó–ê –í–°–ò–ß–ö–ò –°–ê–ô–¢–û–í–ï
    const documentId = 'global-chat';

    let chatManager;
    try {
      chatManager = new ChatUIManager('chat-widget', documentId);
      window.chatManager = chatManager;
    //  console.log('‚úì‚úì‚úì Chat —Å–∏—Å—Ç–µ–º–∞ –ì–û–¢–û–í–ê!');
    } catch (error) {
      console.error('Chat init error:', error);
      return;
    }

    const chatIcon = document.getElementById('chat-toggle');
    if (chatIcon) {
      chatIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // console.log('üí¨ Click'); // Can be removed
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const chatCloseBtn = document.getElementById('chat-close');
    if (chatCloseBtn) {
      chatCloseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const currentUserNameEl = document.getElementById('current-user-name');
    if (currentUserNameEl && window.currentUser) {
      currentUserNameEl.textContent = window.currentUser.userName;
    }

    // console.log('–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª:', window.currentUser.userName); // Can be removed
  }

  tryInit();
})();

// ============================================
// GLOBAL RESET FUNCTION - –¥–æ—Å—Ç—ä–ø–Ω–∞ –æ—Ç–≤—Å—è–∫—ä–¥–µ
// ============================================

window.resetChat = function() {
  localStorage.removeItem('userId');
  localStorage.removeItem('userName');
  localStorage.removeItem('userColor');
  console.log('‚úÖ –†–µ—Å–µ—Ç –∑–∞–≤—ä—Ä—à–µ–Ω! –ù–∞–ø–∏—à–∏ –≤ –∫–æ–Ω—Å–æ–ª–∞—Ç–∞: location.reload()');
};

window.deleteAllChatMessages = async function(password) {
  if (!password) {
    console.error('‚ùå –ü–∞—Ä–æ–ª–∞ –Ω–µ –µ –¥–∞–¥–µ–Ω–∞! –ò–∑–ø–æ–ª–∑–≤–∞–π: window.deleteAllChatMessages("admin")');
    return false;
  }

  if (password !== 'admin') {
    console.error('‚ùå –ì–†–ï–®–ù–ê –ü–ê–†–û–õ–ê!');
    return false;
  }

  try {
    const baseURL = 'https://med-student-chat-default-rtdb.europe-west1.firebasedatabase.app';
    const messagesRef = `${baseURL}/messages/global-chat.json`; // Fix: target global-chat
    const reactionsRef = `${baseURL}/reactions/global-chat.json`; // Fix: target global-chat

    // –ò–∑—Ç—Ä–∏–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞
    const msgResponse = await fetch(messagesRef, { method: 'DELETE' });
    if (!msgResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞');

    // –ò–∑—Ç—Ä–∏–π —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ
    const reactResponse = await fetch(reactionsRef, { method: 'DELETE' });
    if (!reactResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ');

    console.log('‚úÖ –ß–ê–¢ –ò–ó–¢–†–ò–¢ –£–°–ü–ï–®–ù–û! –í—Å–∏—á–∫–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –∏ —Ä–µ–∞–∫—Ü–∏–∏ —Å–∞ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç–∏.');
    console.log('üí° –ù–∞–ø–∏—à–∏: location.reload() –∑–∞ –¥–∞ –≤–∏–¥–∏—à –ø—Ä–æ–º–µ–Ω–∏—Ç–µ');
    return true;
  } catch (error) {
    console.error('‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —á–∞—Ç–∞:', error);
    return false;
  }
};

// console.log('üí° –ö–æ–º–∞–Ω–¥–∏: resetChat() - —Ä–µ—Å–µ—Ç –Ω–∞ –∏–º–µ');

// Cache buster
const CHAT_VERSION = '20260122_v2';
