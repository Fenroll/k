// ============================================
// COMPLETE CHAT SYSTEM - ONE FILE
// Firebase REST API + UI + User Management
// ============================================

// (Chat system initialized)

// ============================================
// PART 1: USER INITIALIZATION
// ============================================

// The `currentUser` object is now created in `js/user-identity.js` and is globally available.
// This file assumes `user-identity.js` has been loaded.

// ============================================
// PART 2: FIREBASE REST API
// ============================================

class ChatFirebaseREST {
  constructor(documentId) {
    this.documentId = documentId || 'default';
    this.messages = [];
    this.listeners = [];
    this.isPolling = false;
    this.unsubscribers = [];
    this.heartbeatInterval = null;
    
    // Firebase is now initialized globally by calendar.html, so no need for config here.

    // console.log('Using Firebase SDK Wrapper'); // Can be removed
    this.initSDK();
  }

  async initSDK() {
    // If the global firebase object is already available, use it.
    if (typeof firebase !== 'undefined') {
        this.initApp(firebase);
        return;
    } else {
        console.error("Firebase SDK not loaded globally. Please ensure firebase-app-compat.js and firebase-database-compat.js are loaded BEFORE chat.js and firebase.initializeApp() is called.");
    }
  }

  initApp(firebaseInstance) {
    try {
      // Assume app is already initialized globally. Just get the default app.
      const app = firebaseInstance.app();
      this.db = firebaseInstance.database();
      // console.log('‚úì Firebase SDK Initialized'); // Can be removed
    } catch (e) {
      console.error("Firebase Init Error: Ensure Firebase is initialized globally in the HTML.", e);
    }
  }

  async _ensureInit() {
    if (this.db) return;
    // If initSDK didn't run or failed, try again with global firebase.
    // This provides a fallback if initSDK was called prematurely or firebase wasn't ready.
    if (typeof firebase !== 'undefined' && !this.db) {
        this.initApp(firebase);
        if (this.db) return; // If successful now
    }
    // If still not initialized, something is wrong.
    throw new Error("Firebase not initialized. Check SDK loading and configuration.");
  }

  async sendMessage(text, replyTo = null, replyAuthor = null) {
    if (!text.trim()) return false;
    await this._ensureInit();

    const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
    
    const message = {
      userId: currentUser.userId,
      userName: currentUser.userName,
      userColor: currentUser.color,
      text: text.trim(),
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      // id will be generated by key
    };

    if (replyTo && replyAuthor) {
      message.replyTo = replyTo;
      message.replyAuthor = replyAuthor;
    }

    try {
      const newMessageRef = messagesRef.push();
      await newMessageRef.set(message);
      return true;
    } catch (error) {
      console.error('SDK Send error:', error);
      return false;
    }
  }

  async loadMessages() {
    // –í SDK —Ä–µ–∂–∏–º, —Ç–æ–≤–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Ä—è–¥–∫–æ, –∑–∞—â–æ—Ç–æ startPolling –ø–æ–¥–¥—ä—Ä–∂–∞ –≤—Å–∏—á–∫–æ
    await this._ensureInit();
    
    try {
      const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
      // Limit to last 500 to prevent lagging
      const q = messagesRef.orderByChild('timestamp').limitToLast(500);
      
      const snapshot = await q.once('value');
      if (!snapshot.exists()) return [];
      
      const data = snapshot.val();
      const messages = Object.keys(data).map(key => ({
        ...data[key],
        key: key,
        id: key
      }));

      // Sort
      messages.sort((a, b) => a.timestamp - b.timestamp);
      this.messages = messages;
      return messages;
    } catch (error) {
      console.error('SDK Load error:', error);
      return [];
    }
  }

  async bulkUpdate(updates) {
    await this._ensureInit();
    try {
        await firebase.database().ref().update(updates);
        return true;
    } catch (error) {
        console.error('SDK Bulk Update error:', error);
        return false;
    }
  }

  async updateNameMapping(oldName, newName) {
    await this._ensureInit();
    const mappingRef = firebase.database().ref(`name_mappings/${oldName}`);
    try {
        await mappingRef.set(newName);
        return true;
    } catch (error) {
        console.error('SDK updateNameMapping error:', error);
        return false;
    }
  }

  async getNameMappings() {
    await this._ensureInit();
    try {
        const snapshot = await firebase.database().ref(`name_mappings`).once('value');
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  startNameMappingsPolling(callback) {
    this._ensureInit().then(() => {
        const mappingsRef = firebase.database().ref(`name_mappings`);

        const unsubscribe = mappingsRef.on('value', (snapshot) => {
            const mappings = snapshot.val() || {};
            callback(mappings);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getProtectedNames() {
    await this._ensureInit();
    try {
        const snapshot = await firebase.database().ref(`protected_names`).once('value');
        return snapshot.exists() ? snapshot.val() : {};
    } catch(e) { return {}; }
  }

  async protectName(name, password) {
    await this._ensureInit();
    const protectedNameRef = firebase.database().ref(`protected_names/${name}`);
    try {
        await protectedNameRef.set(password); // In a real app, hash the password
        return true;
    } catch (error) {
        console.error('SDK protectName error:', error);
        return false;
    }
  }

  startPolling(callback, interval = 2000) {
    if (this.isPolling) return;
    this.isPolling = true;

    this._ensureInit().then(() => {
        const messagesRef = firebase.database().ref(`messages/${this.documentId}`);
        // Realtime Listener
        const q = messagesRef.orderByChild('timestamp').limitToLast(500);

        const unsubscribe = q.on('value', (snapshot) => {
            const messages = [];
            snapshot.forEach((child) => {
                const val = child.val();
                messages.push({
                    ...val,
                    key: child.key,
                    id: child.key,
                    // Handle serverTimestamp properly if it's still processing (can be null briefly)
                    timestamp: val.timestamp || Date.now()
                });
            });
            
            // Check for new messages for notifications
            if (messages.length > this.messages.length && this.messages.length > 0) {
                 const newMessage = messages[messages.length - 1];
                 this.listeners.forEach(listener => listener(newMessage));
            } // Can be removed, frequent

            this.messages = messages;
            callback(messages);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  addMessageListener(callback) {
    this.listeners.push(callback);
  }

  async updateColorForAllSessions(newColor) {
    // This functionality is mostly for updating the *chat-specific* presence entry,
    // which we are removing. So this function can be removed or adapted.
    // For now, removing.
    console.warn("updateColorForAllSessions is no longer relevant with site-wide presence.");
  }

  // forceUpdatePresence removed

  // markUserActive removed

  // getActiveUsers removed

  async deleteMessage(messageKey) {
    await this._ensureInit();
    try {
        const messageRef = firebase.database().ref(`messages/${this.documentId}/${messageKey}`);
        await messageRef.remove();
        return true;
    } catch (e) {
        console.error("SDK deleteMessage error:", e);
        return false;
    }
  }

  async setLastRead(userName, messageId) {
    if (!userName || !messageId) return false;
    // Note: Firebase keys can't contain ., $, #, [, ], /, or ASCII control chars 0-31 or 127.
    // Sanitize userName to be a safe key.
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    await this._ensureInit();
    const lastReadRef = firebase.database().ref(`last_read/${this.documentId}/${safeUserName}`);
    try {
        await lastReadRef.set(messageId);
        return true;
    } catch (error) {
        console.error('SDK setLastRead error:', error);
        return false;
    }
  }

  startLastReadPolling(userName, callback) {
    if (!userName) return;
    const safeUserName = userName.replace(/[.#$[\]/]/g, '_');

    this._ensureInit().then(() => {
        const lastReadRef = firebase.database().ref(`last_read/${this.documentId}/${safeUserName}`);

        const unsubscribe = lastReadRef.on('value', (snapshot) => {
            const lastReadId = snapshot.val();
            if (lastReadId) {
                callback(lastReadId);
            } // Can be removed, frequent
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  async getReactions(messageId) {
    await this._ensureInit();
    try {
      const snapshot = await firebase.database().ref(`reactions/${this.documentId}/${messageId}`).once('value');
      return snapshot.exists() ? snapshot.val() : null;
    } catch (e) {
      console.error("SDK getReactions error:", e);
      return null;
    }
  }

  async addReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, true);
  }

  async removeReaction(messageId, emoji) {
    return this.setReaction(messageId, emoji, false);
  }

  async setReaction(messageId, emoji, value) {
    await this._ensureInit();
    try {
      // Use set with false to "remove" (logically) or null/remove to physically remove?
      // The original code used PUT with true/false, establishing a schema where key=userId, value=true/false
      // path: reactions/docId/msgId/emoji/userId = true/false
      const reactionRef = firebase.database().ref(`reactions/${this.documentId}/${messageId}/${emoji}/${currentUser.userId}`);
      
      // If value is false, maybe we should remove the node to keep DB clean, 
      // but original code sent 'false'. Let's stick to user logic or improve it.
      // Actually, removing it is better for counting.
      if (value) {
          await reactionRef.set(true);
      } else {
          await reactionRef.set(null); // Remove the node
      }
      return true;
    } catch (e) {
      console.error("SDK setReaction error:", e);
      return false;
    }
  }

  async bulkRemoveReactions(messageId, emoji, userIds) {
    if (!userIds || userIds.length === 0) return true;
    await this._ensureInit();
    const updates = {};
    userIds.forEach(id => {
        updates[`reactions/${this.documentId}/${messageId}/${emoji}/${id}`] = null;
    });
    try {
        await firebase.database().ref().update(updates);
        return true;
    } catch (e) {
        console.error("SDK bulkRemoveReactions error:", e);
        return false;
    }
  }

  startReactionsPolling(callback) {
    this._ensureInit().then(() => {
        const reactionsRef = firebase.database().ref(`reactions/${this.documentId}`);

        const unsubscribe = reactionsRef.on('value', (snapshot) => {
            const reactions = snapshot.val() || {};
            callback(reactions);
        });
        this.unsubscribers.push(unsubscribe);
    });
  }

  startSiteWidePresencePolling(callback) {
    this._ensureInit().then(() => {
        const onlineUsersRef = firebase.database().ref('online_users');
        const onlineGuestsRef = firebase.database().ref('online_guests'); // New: reference for guest users
        const siteUsersRef = firebase.database().ref('site_users');

        let allSiteUsers = {};     // Cache for user profiles
        let allOnlineAuthData = {}; // Cache for authenticated users online presence
        let allOnlineGuestData = {}; // Cache for guest users online presence

        const processAndCallback = () => {
            const groupedUsers = {};

            // Process Authenticated Users
            for (const uid in allOnlineAuthData) {
                const devices = allOnlineAuthData[uid];
                const deviceIds = Object.keys(devices);
                const deviceCount = deviceIds.length;
                let hasMobile = false;

                if (deviceCount > 0) {
                    hasMobile = deviceIds.some(deviceId => devices[deviceId].isMobile === true);
                    
                    const userProfile = allSiteUsers[uid];
                    if (userProfile) {
                        groupedUsers[uid] = {
                            userId: uid,
                            userName: userProfile.displayName || userProfile.username,
                            color: userProfile.color,
                            deviceCount: deviceCount,
                            hasMobile: hasMobile,
                            isGuest: false
                        };
                    } else {
                        // Fallback for users not found in site_users (e.g., deleted accounts)
                        groupedUsers[uid] = {
                            userId: uid,
                            userName: `Unknown User (${uid})`,
                            color: '#cccccc',
                            deviceCount: deviceCount,
                            hasMobile: hasMobile,
                            isGuest: false
                        };
                    }
                }
            }

            // Process Guest Users
            for (const guestId in allOnlineGuestData) {
                const devices = allOnlineGuestData[guestId];
                const deviceIds = Object.keys(devices);
                const deviceCount = deviceIds.length;
                let hasMobile = false;

                if (deviceCount > 0) {
                    hasMobile = deviceIds.some(deviceId => devices[deviceId].isMobile === true);
                    
                    // Guest userName is stored directly in deviceData by presence.js
                    const sampleDeviceData = devices[deviceIds[0]]; 
                    const guestUserName = sampleDeviceData.userName || `Guest-${guestId.substring(6, 10)}`;

                    groupedUsers[guestId] = {
                        userId: guestId,
                        userName: guestUserName,
                        color: '#9E9E9E', // Default grey color for guests
                        deviceCount: deviceCount,
                        hasMobile: hasMobile,
                        isGuest: true
                    };
                }
            }

            callback({
                count: Object.keys(groupedUsers).length,
                users: groupedUsers,
                usersList: Object.keys(groupedUsers)
            });
        };

        // Listen for all site users (for username and color)
        const unsubscribeSiteUsers = siteUsersRef.on('value', (snapshot) => {
            allSiteUsers = snapshot.val() || {};
            processAndCallback(); // Recalculate and update when user profiles change
        });
        this.unsubscribers.push(unsubscribeSiteUsers);

        // Listen for authenticated users online presence data
        const unsubscribeOnlineUsers = onlineUsersRef.on('value', (snapshot) => {
            allOnlineAuthData = snapshot.val() || {};
            processAndCallback(); // Recalculate and update when online status changes
        });
        this.unsubscribers.push(unsubscribeOnlineUsers);

        // New: Listen for guest users online presence data
        const unsubscribeOnlineGuests = onlineGuestsRef.on('value', (snapshot) => {
            allOnlineGuestData = snapshot.val() || {};
            processAndCallback(); // Recalculate and update when guest online status changes
        });
        this.unsubscribers.push(unsubscribeOnlineGuests);
    });
  }

  stop() {
    this.isPolling = false;
    this.listeners = [];

    // Unsubscribe from all listeners
    this.unsubscribers.forEach(unsub => unsub()); // Can be removed, internal logic
    this.unsubscribers = [];

    // Clear heartbeat
    if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
    }

    // console.log('üõë ChatFirebaseREST —Å–ø—Ä—è–Ω.'); // Can be removed
  }
}

// ============================================
// PART 3: CHAT UI MANAGER
// ============================================

class ChatUIManager {
  constructor(containerId, documentId) {
    // console.log('üí¨ ChatUIManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º...'); // Can be removed
    this.container = document.getElementById(containerId);
    if (!this.container) {
      console.error('Container –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω:', containerId);
      return;
    }
    
    this.documentId = documentId || 'default';
    this.chatFirebase = new ChatFirebaseREST(this.documentId);
    this.isOpen = false;
    this.autoScroll = true;
    this.lastReadMessageId = localStorage.getItem(`lastReadMessage_${documentId}`) || null;
    this.notificationsDisabled = localStorage.getItem(`notificationsDisabled_${documentId}`) === 'true';
    this.unreadCount = 0;
    this.lastMessages = [];  // –°—ä—Ö—Ä–∞–Ω—è–≤–∞–º –ø—Ä–µ–¥–∏—à–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
    this.userNameMappings = {}; // –ö–∞—Ä—Ç–∞ –∑–∞ —Å—Ç–∞—Ä–∏ –∫—ä–º –Ω–æ–≤–∏ –∏–º–µ–Ω–∞
    this.reactionsCache = {}; // –ö–µ—à –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    this.activeUsers = {}; // –°–ø–∏—Å—ä–∫ —Å –∞–∫—Ç–∏–≤–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –∑–∞ –ª–æ–≥–∏–∫–∞ —Å —Ä–µ–∞–∫—Ü–∏–∏
    this.showMembers = localStorage.getItem(`showMembers_${this.documentId}`) !== 'false'; // Default to true if not set

    this.init();
  }

  _getMyUserIds() {
    if (!this.activeUsers || !currentUser.userName) return [currentUser.userId];
    
    const myName = currentUser.userName;
    const myIds = new Set([currentUser.userId]); // Always include current ID

    // Find all other userIds with the same name from the active list
    for (const userId in this.activeUsers) {
        const user = this.activeUsers[userId];
        if (user && user.userName === myName) {
            myIds.add(userId);
        }
    }
    return Array.from(myIds);
  }

  resolveName(originalName) {
    if (!this.userNameMappings || !originalName) return originalName;
    let currentName = originalName;
    let resolvedName = this.userNameMappings[currentName];
    let depth = 0; // safety break for circular dependencies
    while (resolvedName && depth < 10) {
        currentName = resolvedName;
        // Check for the next name in the chain
        resolvedName = this.userNameMappings[currentName];
        depth++;
    }
    return currentName;
  }

  fixInputLayout() {
    const inputArea = this.container.querySelector('.chat-input-area');
    if (!inputArea) return;

    // 1. Inject CSS for Column Layout if not present
    if (!document.getElementById('chat-layout-fix')) {
        const style = document.createElement('style');
        style.id = 'chat-layout-fix';
        style.textContent = `
            .chat-input-area {
                display: flex !important;
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 0 !important;
            }
            .chat-controls-row {
                display: flex !important;
                align-items: center !important;
                width: 100% !important;
                padding-top: 6px;
                position: relative;
                gap: 12px !important;
            }
            .reply-indicator {
                width: 100%;
                box-sizing: border-box;
                margin-bottom: 4px;
            }
            .message-actions {
                position: absolute;
                top: 3px;
                right: 3px;
                display: none;
                background: white;
                border-radius: 6px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                padding: 2px;
                gap: 2px;
            }
            .chat-message:hover .message-actions {
                display: flex;
            }
            .message-actions button {
                transition: background 0.2s;
            }
            .message-actions button:hover {
                background: #dbeafe !important;
            }
            .reaction-tooltip {
                position: fixed;
                background: #262626;
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 12px;
                z-index: 10001;
                pointer-events: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                max-width: 200px;
                line-height: 1.5;
            }
        `;
        document.head.appendChild(style);
    }

    // 2. Restructure DOM: Move controls into a row if they aren't already
    const inputField = inputArea.querySelector('.chat-input');
    
    // Only proceed if inputField is direct child of inputArea (meaning not wrapped yet)
    if (inputField && inputField.parentElement === inputArea) {
        const row = document.createElement('div');
        row.className = 'chat-controls-row';
        
        // Find elements to move
        const uploadInput = inputArea.querySelector('#image-upload-input');
        const uploadBtn = inputArea.querySelector('#image-upload-btn');
        const sendBtn = inputArea.querySelector('.chat-send-btn');
        
        // Move them to row
        if (uploadInput) row.appendChild(uploadInput);
        if (uploadBtn) row.appendChild(uploadBtn);
        row.appendChild(inputField); // Input
        if (sendBtn) row.appendChild(sendBtn);
        
        // Append row to inputArea
        inputArea.appendChild(row);
    }
  }

  async init() {
    try {
      this.fixInputLayout();
      // await this.chatFirebase.markUserActive(); // Removed - using site-wide presence.js

      // –ó–∞—Ä–µ–¥–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è - –æ—Ç localStorage –∏–ª–∏ Firebase
      let messages = this.loadFromCache();
      if (!messages || messages.length === 0) {
        messages = await this.chatFirebase.loadMessages();
      }
      
      // –ó–∞—Ä–µ–¥–∏ –º–∞–ø–∏–Ω–≥–∏ –Ω–∞ –∏–º–µ–Ω–∞
      this.protectedNames = await this.chatFirebase.getProtectedNames();

      this.chatFirebase.startNameMappingsPolling((mappings) => {
          this.userNameMappings = mappings;
          if (this.lastMessages.length > 0) {
              this.renderMessages(this.lastMessages);
          }
      });
      
      this.saveToCache(messages);
      this.renderMessages(messages);

      // Polling –∑–∞ –Ω–æ–≤–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startPolling((messages) => {
        this.saveToCache(messages);
        this.renderMessages(messages);
      }, 2500);

      // Real-time —Å–ª—É—à–∞—Ç–µ–ª –∑–∞ –í–°–ò–ß–ö–ò —Ä–µ–∞–∫—Ü–∏–∏
      this.chatFirebase.startReactionsPolling((reactions) => {
        this.reactionsCache = reactions;
        this.renderAllReactions();
      });

      // New site-wide presence polling
      this.chatFirebase.startSiteWidePresencePolling((data) => {
        // data.users is now an object like { uid: { userId, userName, color, deviceCount, hasMobile } }
        this.activeUsers = data.users || {}; // Cache the user-centric data
        this.updateNotificationButton(data);
        this.updateHeaderOnlineCount(data.count);
      });

      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è
      this.chatFirebase.startLastReadPolling(currentUser.userName, (lastReadId) => {
        if (lastReadId && lastReadId !== this.lastReadMessageId) {
          console.log(`üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞–Ω –Ω–æ–≤ lastReadId: ${lastReadId}`);
          this.lastReadMessageId = lastReadId; // Can be removed, frequent
          localStorage.setItem(`lastReadMessage_${this.documentId}`, lastReadId);
          
          // –ü—Ä–µ–∏–∑—á–∏—Å–ª–∏ –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏—Ç–µ –∏ –æ–±–Ω–æ–≤–∏ –±—Ä–æ—è—á–∞
          this.recalculateUnreadCount(this.chatFirebase.messages);
          this.updateActiveCount();
        }
      });

      // Listener –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      this.chatFirebase.addMessageListener((newMessage) => {
        // Check if the message is from the current user
        const isMyMessage = (window.currentUser.userId && newMessage.userId === window.currentUser.userId) ||
                            (window.currentUser.legacyChatId && newMessage.userId === window.currentUser.legacyChatId);

        // Trigger notification only if chat is closed and message is not from self
        if (!this.isOpen && !isMyMessage) {
            // this.showNotification(); // Removed: user requested to remove notification animation
        }
      });

      this.attachEventListeners();
      
      // –ü—Ä–∏–ª–æ–∂–∏ –Ω–∞—á–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ —Å —á–ª–µ–Ω–æ–≤–µ
      const chatPanel = this.container.querySelector('.chat-panel');
      if (chatPanel && this.showMembers) {
        chatPanel.classList.add('show-members');
      }
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–π –±—É—Ç–æ–Ω –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ–¥–∏–Ω –ø—ä—Ç
      this.initNotificationButton();
      
      // console.log('‚úì‚úì‚úì ChatUIManager –≥–æ—Ç–æ–≤'); // Can be removed
    } catch (error) {
      console.error('Init error:', error);
    }
  }

  loadFromCache() {
    try {
      const key = `chatMessages_${this.documentId}`;
      const cached = localStorage.getItem(key);
      if (cached) {
        return JSON.parse(cached);
      }
    } catch (error) {
      console.error('Cache load error:', error);
    }
    return null;
  }

  saveToCache(messages) {
    try {
      const key = `chatMessages_${this.documentId}`;
      localStorage.setItem(key, JSON.stringify(messages));
    } catch (error) {
      console.error('Cache save error:', error);
    }
  }

  attachEventListeners() {
    const sendBtn = this.container.querySelector('.chat-send-btn');
    const input = this.container.querySelector('.chat-input'); // This is now a textarea

    if (sendBtn && input) {
      sendBtn.addEventListener('click', () => this.handleSendMessage());
      
      // Handle Enter (Send) vs Shift+Enter (New Line)
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSendMessage();
        }
      });
      
      // Auto-resize textarea
      input.addEventListener('input', () => {
         input.style.height = 'auto';
         input.style.height = (input.scrollHeight) + 'px';
         // Cap max height if needed via CSS max-height
      });
    }

    const messagesContainer = this.container.querySelector('.chat-messages');
    
    // Members toggle logic
    const membersToggle = this.container.querySelector('#chat-members-toggle');
    const chatPanel = this.container.querySelector('.chat-panel');
    if (membersToggle && chatPanel) {
      membersToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const isMobile = window.innerWidth <= 600;
        
        if (isMobile) {
          // –ù–∞ –º–æ–±–∏–ª–µ–Ω –ø—Ä–æ—Å—Ç–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞–º–µ –±–µ–∑ –∑–∞–ø–∏—Å–≤–∞–Ω–µ
          chatPanel.classList.toggle('show-members');
        } else {
          // –ù–∞ –¥–µ—Å–∫—Ç–æ–ø –ø—Ä–µ–≤–∫–ª—é—á–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
          this.showMembers = !chatPanel.classList.contains('show-members');
          chatPanel.classList.toggle('show-members');
          localStorage.setItem(`showMembers_${this.documentId}`, this.showMembers);
        }
      });
    }

    if (messagesContainer) {
      messagesContainer.addEventListener('scroll', () => {
        const isAtBottom =
          messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 50;
        this.autoScroll = isAtBottom;
      });
    }
  }

  initNotificationButton() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–π –±—É—Ç–æ–Ω –∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ–¥–∏–Ω –ø—ä—Ç
    const sidebarEl = this.container.querySelector('.chat-active-users');
    if (!sidebarEl) {
      console.error('Sidebar –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }

    sidebarEl.innerHTML = `
      <div style="padding: 8px;">
        <button id="toggle-notifications" style="width: 100%; padding: 10px; background: ${this.notificationsDisabled ? '#ff6b6b' : '#4ade80'}; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 6px;">
          <img src="svg/chat/${this.notificationsDisabled ? 'icon-notifications-disabled.svg' : 'icon-notifications-enabled.svg'}" alt="–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è" style="width: 16px; height: 16px; filter: invert(1);">
          <span>${this.notificationsDisabled ? '–ò–∑–∫–ª—é—á–µ–Ω–∏' : '–í–∫–ª—é—á–µ–Ω–∏'}</span>
        </button>
        <div id="active-users-list" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280;"></div>
      </div>
    `;

    // –î–æ–±–∞–≤–∏ listener –µ–¥–∏–Ω –ø—ä—Ç
    const toggleBtn = sidebarEl.querySelector('#toggle-notifications');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => { // Can be removed, internal logic
        this.notificationsDisabled = !this.notificationsDisabled;
        localStorage.setItem(`notificationsDisabled_${this.documentId}`, this.notificationsDisabled);
        // –û–±–Ω–æ–≤–∏ —Ü–≤–µ—Ç–∞ –±–µ–∑ –¥–∞ –ø—Ä–µ–∑–∞–ø–∏—Å–≤–∞—à HTML
        this.updateNotificationButtonColor();
        // –û–±–Ω–æ–≤–∏ –∏–∫–æ–Ω–∫–∞—Ç–∞ (—Å–∫—Ä–∏–π/–ø–æ–∫–∞–∂–∏ —á–∏—Å–ª–æ—Ç–æ –Ω–∞ –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏)
        this.updateActiveCount();
      });
    } else {
      console.error('–ë—É—Ç–æ–Ω –ù–ï –µ –Ω–∞–º–µ—Ä–µ–Ω!');
    }
  }

  updateNotificationButtonColor() {
    // –û–±–Ω–æ–≤–∏ —Å–∞–º–æ —Ü–≤–µ—Ç–∞ –∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –±—É—Ç–æ–Ω–∞ –±–µ–∑ –¥–∞ –ø—Ä–µ–∑–∞–ø–∏—Å–≤–∞—à HTML
    const toggleBtn = document.querySelector('#toggle-notifications');
    if (toggleBtn) {
      toggleBtn.style.background = this.notificationsDisabled ? '#ff6b6b' : '#4ade80';
      const img = toggleBtn.querySelector('img');
      if (img) {
        img.src = `svg/chat/${this.notificationsDisabled ? 'icon-notifications-disabled.svg' : 'icon-notifications-enabled.svg'}`;
      }
      const span = toggleBtn.querySelector('span');
      if (span) {
        span.textContent = this.notificationsDisabled ? '–ò–∑–∫–ª—é—á–µ–Ω–∏' : '–í–∫–ª—é—á–µ–Ω–∏';
      }
    }
  }

  updateNotificationButton(data) {
    const usersListEl = document.getElementById('active-users-list');
    if (!usersListEl) return;

    // data.users is already an object of user-centric data:
    // { uid: { userId, userName, color, deviceCount, hasMobile } }
    let users = Object.values(data.users || {});
    const count = data.count || 0; // Use count directly from data

    const myId = (typeof window.currentUser !== 'undefined' && window.currentUser.userId) ? String(window.currentUser.userId) : null;

    // Map and sort users
    users.forEach(user => {
        // Resolve name mapping
        let name = user.userName;
        if (this.userNameMappings && this.userNameMappings[name]) {
            name = this.userNameMappings[name];
        }
        user.userName = name; // Update with resolved name
        user.isMe = (String(user.userId) === myId); // Check if current user
    });

    // Sort: current user first, then alphabetically by userName
    users.sort((a, b) => {
      if (a.isMe && !b.isMe) return -1;
      if (!a.isMe && b.isMe) return 1;
      return a.userName.localeCompare(b.userName);
    });

    usersListEl.innerHTML = `
      <strong>–ê–∫—Ç–∏–≤–Ω–∏ (${count}):</strong><br>
      ${users.map(user => {
          const mobileIcon = user.hasMobile
            ? `<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="margin-left: 4px; vertical-align: middle;" title="Mobile device"> <path d="M11.5,0h-7C3.675,0,3,0.675,3,1.5v13C3,15.325,3.675,16,4.5,16h7c0.825,0,1.5-0.675,1.5-1.5v-13C13,0.675,12.325,0,11.5,0z M8,15c-0.553,0-1-0.447-1-1s0.447-1,1-1s1,0.447,1,1S8.553,15,8,15z M12,12H4V2h8V12z" /> </svg>`
            : '';
            
          return `
        <div style="display: flex; align-items: center; gap: 6px; margin: 4px 0;">
          <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${user.color};"></div>
          <span style="font-size: 10px; flex: 1; word-break: break-all; display: flex; align-items: center; ${user.isMe ? 'font-weight: bold; color: var(--fg);' : ''}">
            ${user.userName} ${user.isMe ? ' (–ê–∑)' : ''}
            ${mobileIcon}
          </span>
        </div>
      `}).join('')}
    `;

    // Also update header count to be consistent
    if (this.updateHeaderOnlineCount) {
        this.updateHeaderOnlineCount(count);
    }
  }

  async handleAdminCommand(commandObj) {
      const cmd = commandObj.substring(7).trim(); // Remove "/admin "

      if (cmd === 'deletechat') {
          if(confirm("‚ö† WARNING: This will delete ALL chat history globally! Are you sure?")) {
              await window.deleteAllChatMessages('admin');
          }
      }
  }

  async handleSendMessage() {
    const input = this.container.querySelector('.chat-input');
    const text = input.value;

    if (!text.trim()) return;

    // --- ADMIN COMMANDS ---
    if (text.startsWith('/admin ')) {
       await this.handleAdminCommand(text);
       input.value = '';
       return;
    }
    // ----------------------

    // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –∏–º–∞ reply
    const replyTo = input.dataset.replyTo;
    const replyAuthor = input.dataset.replyAuthor;

    const success = await this.chatFirebase.sendMessage(text, replyTo, replyAuthor);
    if (success) {
      input.value = '';
      input.dataset.replyTo = '';
      input.dataset.replyAuthor = '';
      
      // Reset textarea height after sending
      input.style.height = 'auto';
      
      input.focus();
      
      // –ü—Ä–µ–º–∞—Ö–Ω–∏ reply indicator
      const replyIndicator = this.container.querySelector('.reply-indicator');
      if (replyIndicator) replyIndicator.remove();
      
      // Realtime listener —â–µ —Å–µ –ø–æ–≥—Ä–∏–∂–∏ –∑–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ—Ç–æ (startPolling)
      // –ü—Ä–µ–º–∞—Ö–Ω–∞—Ö–º–µ —Ä—ä—á–Ω–æ—Ç–æ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º race conditions
    }
  }

  recalculateUnreadCount(messages) {
    // Helper to check if a message is from the current user
    const isMyMessage = (msg) => {
        return msg.userId === window.currentUser.userId || (window.currentUser.legacyChatId && msg.userId === window.currentUser.legacyChatId);
    };

    if (!this.lastReadMessageId) {
        // On first load, count all messages that are not from the current user.
        this.unreadCount = messages.filter(m => !isMyMessage(m)).length;
        return;
    }

    let readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
    
    // If marker is gone (deleted), try to recover using previous history
    if (readIndex === -1 && this.lastMessages.length > 0) {
        const oldIndex = this.lastMessages.findIndex(m => m.id === this.lastReadMessageId);
        if (oldIndex !== -1) {
            // Find a survivor preceding the deleted marker
            // Iterate backwards from oldIndex to find a survivor
            for (let i = oldIndex - 1; i >= 0; i--) {
                const predecessor = this.lastMessages[i];
                if (messages.find(m => m.id === predecessor.id)) {
                    this.lastReadMessageId = predecessor.id;
                    localStorage.setItem(`lastReadMessage_${this.documentId}`, this.lastReadMessageId);
                    readIndex = messages.findIndex(m => m.id === this.lastReadMessageId);
                    break;
                }
            }
        }
        
        // If still not found (e.g. all preceding messages deleted too, or never found), reset to 0
        // Because if the marker is gone, we assume the user was up to date.
        if (readIndex === -1) {
             this.unreadCount = 0;
             return;
        }
    }
    
    // Calculate unread
    if (readIndex !== -1) {
        const newMessages = messages.slice(readIndex + 1);
        // Count only new messages that are not from the current user
        this.unreadCount = newMessages.filter(m => !isMyMessage(m)).length;
    } else {
        // Fallback: count all messages not from the current user
        this.unreadCount = messages.filter(m => !isMyMessage(m)).length;
    }
  }

  renderMessages(messages) {
    const messagesContainer = this.container.querySelector('.chat-messages');
    if (!messagesContainer) return;

    const scrollWasAtBottom = this.autoScroll ||
      messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 50;

    // Always do a full re-render to ensure all data (like names) is up-to-date.
    // This is simpler and more reliable than complex diffing, matching the working logic from notes-init.js.
    this.fullRenderMessages(messages, messagesContainer);

    this.recalculateUnreadCount(messages);
    this.updateActiveCount();
    this.lastMessages = messages;

    if (scrollWasAtBottom) {
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 0);
    }
  }

  fullRenderMessages(messages, messagesContainer) {
    messagesContainer.innerHTML = '';
    
    // –î–æ–±–∞–≤–∏ –≤—Å–∏—á–∫–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –µ–¥–∏–Ω –ø–æ –µ–¥–∏–Ω (incremental)
    messages.forEach(msg => {
      const messageEl = this.createMessageElement(msg, messages);
      messagesContainer.appendChild(messageEl);
      this.attachMessageListeners(messageEl);
    });

    // –°–ª–µ–¥ –∫–∞—Ç–æ –≤—Å–∏—á–∫–∏ —Å–∞ –≤ DOM, —Ä–µ–Ω–¥–∏—Ä–∞–π —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ –æ—Ç –∫–µ—à–∞
    this.renderAllReactions();
  }

  createMessageElement(msg, messagesMap) {
    const messagesMapObj = {};
    (messagesMap || []).forEach(m => {
      messagesMapObj[m.id] = m;
    });

    // –ê–∫–æ –∏–º–∞ reply, –Ω–∞–º–µ—Ä–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–æ—Ç–æ —Å—ä–æ–±—â–µ–Ω–∏–µ
    let replyHTML = '';
    if (msg.replyTo && messagesMapObj[msg.replyTo]) {
      const originalMsg = messagesMapObj[msg.replyTo];
      replyHTML = `
         <div style="background: #f1f5f9; border-left: 3px solid #cbd5e1; padding: 4px 8px; margin-bottom: 4px; font-size: 11px; border-radius: 4px; opacity: 0.8;">
           <b>${this.escapeHtml(msg.replyAuthor || 'Someone')}:</b> ${this.linkifyText(originalMsg.text.substring(0, 50))}...
         </div>
      `;
    }

    const resolvedName = this.resolveName(msg.userName);

    const isCurrentUser = (window.currentUser.userId && msg.userId === window.currentUser.userId) || (window.currentUser.legacyChatId && msg.userId === window.currentUser.legacyChatId);
    const messageBgColor = isCurrentUser ? '#e0f2fe' : 'var(--chat-secondary)'; // Keep visual distinction

    // Reactions are now rendered from cache, so the initial div is populated
    const reactionsHTML = this.getReactionsHTML(msg.id);

    const htmlString = `
      <div class="chat-message" data-user-id="${msg.userId}" data-message-id="${msg.id}" data-message-key="${msg.key}" style="position: relative;">
        <div class="message-content">
          <div class="message-header">
            <span class="message-author">${this.escapeHtml(resolvedName)}</span>
            <span class="message-time">${this.formatTime(msg.timestamp)}</span>
          </div>
          ${replyHTML}
          <div class="message-text" style="background-color: ${messageBgColor};">${this.linkifyText(msg.text)}</div>
          <div class="message-reactions" data-message-id="${msg.id}">${reactionsHTML}</div>
        </div>
        <div class="message-actions">
         <button class="message-reply-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–û—Ç–≥–æ–≤–æ—Ä–∏">
            <img src="svg/chat/icon-reply.svg" alt="Reply" style="width: 100%; height: 100%; opacity: 0.7; filter: invert(0.3);">
          </button>
           <button class="message-reaction-btn" data-message-id="${msg.id}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–î–æ–±–∞–≤–∏ —Ä–µ–∞–∫—Ü–∏—è">
            <img src="svg/chat/icon-reaction.svg" alt="Reaction" style="width: 100%; height: 100%; opacity: 0.7;">
          </button>
          ${isCurrentUser ? `<button class="message-delete-btn" data-message-key="${msg.key}" style="background: none; border: none; cursor: pointer; padding: 4px; border-radius: 4px; width: 24px; height: 24px;" title="–ò–∑—Ç—Ä–∏–π —Å—ä–æ–±—â–µ–Ω–∏–µ">
            <img src="svg/chat/icon-delete.svg" alt="Delete" style="width: 100%; height: 100%; opacity: 0.6;">
          </button>` : ''}
        </div>
      </div>
    `;

    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    // Attach listeners to reaction badges immediately after creation
    this.attachReactionBadgeListeners(temp.firstElementChild);
    return temp.firstElementChild;
  }

  attachMessageListeners(msgEl) {
    // Hover effect now handled by CSS (.chat-message:hover .message-actions)

    // –î–æ–±–∞–≤–∏ listener –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏
    const reactionBtn = msgEl.querySelector('.message-reaction-btn');
    if (reactionBtn) {
      reactionBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.showReactionPicker(msgEl.dataset.messageId);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ reply
    const replyBtn = msgEl.querySelector('.message-reply-btn');
    if (replyBtn) {
      replyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.startReply(msgEl.dataset.messageId, msgEl);
      });
    }

    // –î–æ–±–∞–≤–∏ listener –∑–∞ delete
    const deleteBtn = msgEl.querySelector('.message-delete-btn');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const messageKey = deleteBtn.dataset.messageKey;
        this.deleteMessage(messageKey);
      });
    }
  }

  updateHeaderOnlineCount(count) {
    const onlineCountEl = this.container.querySelector('.chat-online-count');
    if (onlineCountEl) {
        onlineCountEl.textContent = `–ê–∫—Ç–∏–≤–Ω–∏: ${count || 1}`;
    }
  }

  updateActiveCount(data) {
    const badgeEl = document.querySelector('.chat-badge-count');
    
    // –ü–æ–∫–∞–∑–∏ –±—Ä–æ–π –Ω–µ–ø—Ä–æ—á–µ—Ç–µ–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –°–ê–ú–û –∞–∫–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ç–∞ —Å–∞ –≤–∫–ª—é—á–µ–Ω–∏ –ò —á–∞—Ç—ä—Ç –µ –∑–∞—Ç–≤–æ—Ä–µ–Ω
    if (badgeEl) {
      if (this.notificationsDisabled || this.isOpen) {
        badgeEl.style.display = 'none';
      } else {
        badgeEl.textContent = this.unreadCount;
        badgeEl.style.display = this.unreadCount > 0 ? 'flex' : 'none';
      }
    }
  }

  // updateNotificationButton removed (duplicate logic)


  updateActiveSidebar(users) {
    const sidebarEl = this.container.querySelector('.chat-active-users');
    if (!sidebarEl) return;

    const usersList = Object.values(users).slice(0, 5);
    sidebarEl.innerHTML = `
      <div class="active-users-header">–ê–∫—Ç–∏–≤–Ω–∏ —Å–µ–≥–∞:</div>
      ${usersList.map(user => `
        <div class="active-user" title="${user.userName}">
          <div class="active-user-badge" style="background-color: ${user.color}">
            ${user.userName.charAt(0)}
          </div>
          <span>${user.userName}</span>
        </div>
      `).join('')}
    `;
  }

  showNotification() {
    const icon = document.querySelector('.chat-icon');
    if (icon) {
      icon.classList.add('has-notification');
      setTimeout(() => {
        icon.classList.remove('has-notification');
      }, 3000);
    }
  }

  markAsRead() {
    const messages = this.chatFirebase.messages;
    if (messages.length > 0) {
      const lastMessage = messages[messages.length - 1];
      const newLastReadId = lastMessage.id;

      // –ê–∫–æ –≤–µ—á–µ –µ –º–∞—Ä–∫–∏—Ä–∞–Ω–æ –∫–∞—Ç–æ –ø—Ä–æ—á–µ—Ç–µ–Ω–æ, –Ω–µ –ø—Ä–∞–≤–∏ –Ω–∏—â–æ
      if (this.lastReadMessageId === newLastReadId) return;

      this.lastReadMessageId = newLastReadId;
      localStorage.setItem(`lastReadMessage_${this.documentId}`, newLastReadId);
      this.unreadCount = 0;
      this.updateActiveCount();
      
      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞–π —Å Firebase, –∑–∞ –¥–∞ –∑–Ω–∞—è—Ç –∏ –¥—Ä—É–≥–∏—Ç–µ —Å–µ—Å–∏–∏
      this.chatFirebase.setLastRead(currentUser.userName, newLastReadId);
    }
  }

  scrollToBottom() {
    const messagesContainer = this.container.querySelector('.chat-messages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  showReactionPicker(messageId) {
    // –ü—Ä–µ–º–∞—Ö–Ω–∏ —Å—Ç–∞—Ä picker –∞–∫–æ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
    const oldPicker = document.querySelector('.reaction-picker');
    if (oldPicker) oldPicker.remove();

    const emojis1 = ['üëç', 'üëé', 'üòÇ', '‚ù§Ô∏è', 'üòÆ', 'üêê'];
    const emojis2 = ['–ê', '–ë', '–í', '–ì', '–î', '–ï'];
    
    const picker = document.createElement('div');
    picker.className = 'reaction-picker';
    picker.style.cssText = `
      position: fixed;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 10000;
    `;

    const addEmojiButton = (emoji, messageId) => {
      const btn = document.createElement('button');
      btn.textContent = emoji;
      btn.style.cssText = `
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 2px 4px;
      `;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.addReaction(messageId, emoji);
        picker.remove();
        document.removeEventListener('click', closePicker);
      });
      return btn;
    };

    // –ü—ä—Ä–≤–∏ —Ä–µ–¥ –µ–º–æ–¥–∂–∏
    const row1 = document.createElement('div');
    row1.style.cssText = 'display: flex; gap: 4px; justify-content: space-around;';
    emojis1.forEach(emoji => {
      row1.appendChild(addEmojiButton(emoji, messageId));
    });
    picker.appendChild(row1);

    // –í—Ç–æ—Ä–∏ —Ä–µ–¥ –±—É–∫–≤–∏
    const row2 = document.createElement('div');
    row2.style.cssText = 'display: flex; gap: 4px; justify-content: space-around;';
    emojis2.forEach(emoji => {
      row2.appendChild(addEmojiButton(emoji, messageId));
    });
    picker.appendChild(row2);

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π picker –¥–æ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
    const msgEl = document.querySelector(`[data-message-id="${messageId}"]`);
    if (msgEl) {
      const rect = msgEl.getBoundingClientRect();
      picker.style.left = (rect.left + 50) + 'px';
      picker.style.top = (rect.top - 60) + 'px';
      document.body.appendChild(picker);
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ picker
    const closePicker = (e) => {
      // –ê–∫–æ –∫–ª–∏–∫–Ω–µ—à –∏–∑–≤—ä–Ω picker-–∞, –∑–∞—Ç–≤–æ—Ä–∏ –≥–æ.
      // –ü—Ä–∞–≤–∏–º –∏–∑–∫–ª—é—á–µ–Ω–∏–µ –∑–∞ –±—É—Ç–æ–Ω–∏—Ç–µ –∑–∞ —Ä–µ–∞–∫—Ü–∏–∏, –∑–∞—â–æ—Ç–æ —Ç–µ —Å–∞–º–∏ —É–ø—Ä–∞–≤–ª—è–≤–∞—Ç –ø–æ–∫–∞–∑–≤–∞–Ω–µ—Ç–æ/—Å–∫—Ä–∏–≤–∞–Ω–µ—Ç–æ.
      if (!picker.contains(e.target) && !e.target.closest('.message-reaction-btn')) {
        picker.remove();
        document.removeEventListener('click', closePicker);
      }
    };
    
    // –î–æ–±–∞–≤–∏ listener –∑–∞ –≤—Å–µ–∫–∏ –∫–ª–∏–∫
    document.addEventListener('click', closePicker);
  }

  async addReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.addReaction(messageId, emoji);
  }

  showReactionTooltip(badgeElement) {
    this.hideReactionTooltip(); // –°–∫—Ä–∏–π –ø—Ä–µ–¥–∏—à–Ω–∏, –∞–∫–æ –∏–º–∞

    const messageId = badgeElement.dataset.messageId;
    const emoji = badgeElement.dataset.emoji;

    if (!this.reactionsCache || !this.reactionsCache[messageId] || !this.reactionsCache[messageId][emoji]) {
      return;
    }

    const reactors = this.reactionsCache[messageId][emoji];
    const reactorIds = Object.keys(reactors).filter(id => reactors[id] === true);

    if (reactorIds.length === 0) {
      return;
    }

    // –°—ä–∑–¥–∞–π –∫–∞—Ä—Ç–∞ –Ω–∞ userId -> userName –æ—Ç –≤—Å–∏—á–∫–∏ –Ω–∞–ª–∏—á–Ω–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏
    const userMap = {};
    // 1. –û—Ç –∞–∫—Ç–∏–≤–Ω–∏—Ç–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ (–Ω–∞–π-–∞–∫—Ç—É–∞–ª–Ω–∏ –∏–º–µ–Ω–∞)
    for (const userId in this.activeUsers) {
        userMap[userId] = this.activeUsers[userId].userName;
    }
    // 2. –û—Ç –∏—Å—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞ (–∑–∞ –æ—Ñ–ª–∞–π–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏)
    this.chatFirebase.messages.forEach(msg => {
        if (!userMap[msg.userId]) {
            userMap[msg.userId] = msg.userName;
        }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–π ID-—Ç–∞—Ç–∞ –≤ –∏–º–µ–Ω–∞
    const reactorNames = reactorIds.map(id => {
        const rawName = userMap[id] || '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω';
        const resolvedName = this.resolveName(rawName);
        const isMe = this._getMyUserIds().includes(id);
        // –ú–∞—Ä–∫–∏—Ä–∞–π —Ç–µ–∫—É—â–∏—è –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª
        return isMe ? `<strong>${this.escapeHtml(resolvedName)} (–ê–∑)</strong>` : this.escapeHtml(resolvedName);
    }).join('<br>');

    const tooltip = document.createElement('div');
    tooltip.id = 'reaction-tooltip';
    tooltip.className = 'reaction-tooltip';
    tooltip.innerHTML = reactorNames;

    document.body.appendChild(tooltip);

    const badgeRect = badgeElement.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–π –Ω–∞–¥ –±—É—Ç–æ–Ω–∞, —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–Ω–æ
    let top = badgeRect.top - tooltipRect.height - 5;
    let left = badgeRect.left + (badgeRect.width / 2) - (tooltipRect.width / 2);

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
  }

  hideReactionTooltip() {
    const tooltip = document.getElementById('reaction-tooltip');
    if (tooltip) {
      tooltip.remove();
    }
  }

  renderAllReactions() {
    if (!this.reactionsCache) return;
    
    const messageElements = this.container.querySelectorAll('.chat-message[data-message-id]');
    messageElements.forEach(msgEl => {
        const messageId = msgEl.dataset.messageId;
        const reactionsContainer = msgEl.querySelector('.message-reactions');
        if (reactionsContainer) {
            reactionsContainer.innerHTML = this.getReactionsHTML(messageId);
            this.attachReactionBadgeListeners(msgEl);
        }
    });
  }

  getReactionsHTML(messageId) {
    const reactionsForMessage = this.reactionsCache ? this.reactionsCache[messageId] : null;
    if (!reactionsForMessage) return '';

    const reactionCounts = {};
    const myReactions = {};
    
    const myUserIds = this._getMyUserIds(); // –í–∑–µ–º–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ userId-—Ç–∞

    Object.keys(reactionsForMessage).forEach(emoji => {
        const usersObj = reactionsForMessage[emoji] || {};
        const userIdsWhoReacted = Object.keys(usersObj).filter(userId => usersObj[userId] === true);
        const count = userIdsWhoReacted.length;
        
        if (count > 0) {
            reactionCounts[emoji] = count;
            // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –Ω—è–∫–æ–µ –æ—Ç –º–æ–∏—Ç–µ userId-—Ç–∞ –µ —Ä–µ–∞–≥–∏—Ä–∞–ª–æ
            if (userIdsWhoReacted.some(id => myUserIds.includes(id))) {
                myReactions[emoji] = true;
            }
        }
    });
      
    if (Object.keys(reactionCounts).length === 0) {
        return '';
    }

    return Object.keys(reactionCounts).map(emoji => `
        <button class="reaction-badge" data-emoji="${emoji}" data-message-id="${messageId}" 
          style="background: ${myReactions[emoji] ? '#93c5fd' : '#f0f0f0'}; border: none; border-radius: 12px; padding: 4px 8px; margin-right: 4px; cursor: pointer; font-size: 12px; font-weight: ${myReactions[emoji] ? 'bold' : 'normal'};">
          ${emoji} <span>${reactionCounts[emoji]}</span>
        </button>
      `).join('');
  }

  attachReactionBadgeListeners(element) {
    const container = element.querySelector('.message-reactions');
    if (!container) return;

    container.querySelectorAll('.reaction-badge').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const emoji = btn.dataset.emoji;
        const msgId = btn.dataset.messageId;
        
        const reactionsForMessage = this.reactionsCache ? this.reactionsCache[msgId] : null;
        if (!reactionsForMessage) {
            this.addReaction(msgId, emoji);
            return;
        }

        const myUserIds = this._getMyUserIds();
        const reactorsForEmoji = reactionsForMessage[emoji] || {};
        
        const myReactingIds = myUserIds.filter(id => reactorsForEmoji[id] === true);

        if (myReactingIds.length > 0) {
          // –ü—Ä–µ–º–∞—Ö–Ω–∏ –≤—Å–∏—á–∫–∏ –º–æ–∏ —Ä–µ–∞–∫—Ü–∏–∏ –∑–∞ —Ç–æ–≤–∞ –µ–º–æ–¥–∂–∏
          this.chatFirebase.bulkRemoveReactions(msgId, emoji, myReactingIds);
        } else {
          // –î–æ–±–∞–≤–∏ –Ω–æ–≤–∞ —Ä–µ–∞–∫—Ü–∏—è
          this.addReaction(msgId, emoji);
        }
      });

      // –î–æ–±–∞–≤–∏ hover —Å–ª—É—à–∞—Ç–µ–ª–∏ –∑–∞ tooltip
      btn.addEventListener('mouseenter', e => {
        this.showReactionTooltip(e.currentTarget);
      });
      btn.addEventListener('mouseleave', () => {
        this.hideReactionTooltip();
      });
    });
  }

  async removeReaction(messageId, emoji) {
    // Just send the data, the listener will update the UI
    await this.chatFirebase.removeReaction(messageId, emoji);
  }

  startReply(messageId, messageEl) {
    // –ù–∞–º–µ—Ä–∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ
    const textEl = messageEl.querySelector('.message-text');
    const authorEl = messageEl.querySelector('.message-author');
    
    if (!textEl || !authorEl) return;

    const author = authorEl.textContent;
    const text = textEl.textContent;

    // –ü–æ—Å—Ç–∞–≤–∏ reply –∏–Ω—Ñ–æ –≤ input –ø–æ–ª–µ
    const input = this.container.querySelector('.chat-input');
    if (input) {
      input.dataset.replyTo = messageId;
      input.dataset.replyAuthor = author;
      input.dataset.replyText = text;
      
      // –î–æ–±–∞–≤—è–π –≤–∏–∑—É–∞–ª–Ω–∞ –∏–Ω–¥–∏–∫–∞—Ü–∏—è // Can be removed, internal logic
      const inputArea = this.container.querySelector('.chat-input-area');
      // Ensure layout is fixed before adding indicator
      this.fixInputLayout();
      
      let replyIndicator = inputArea.querySelector('.reply-indicator');
      
      if (!replyIndicator) {
        replyIndicator = document.createElement('div');
        replyIndicator.className = 'reply-indicator';
        inputArea.prepend(replyIndicator);
      }

      replyIndicator.style.cssText = `
        background: #f1f5f9; border-left: 3px solid #3b82f6;
        padding: 8px; margin-bottom: 8px; border-radius: 4px;
        font-size: 12px; display: flex; justify-content: space-between; align-items: center;
      `;

      replyIndicator.innerHTML = `
        <span>–û—Ç–≥–æ–≤–∞—Ä—è—à –Ω–∞ <b>${this.escapeHtml(author)}</b></span>
        <button onclick="const input = this.closest('.chat-input-area').querySelector('.chat-input'); if(input) { input.dataset.replyTo=''; input.dataset.replyAuthor=''; } this.closest('.reply-indicator').remove();" style="border:none;background:none;cursor:pointer;font-size:14px;color:#64748b;">‚úñ</button>
      `;

      input.focus();
    }
  }

  toggleChat() {
    if (!this.container) {
      console.error('Container –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }
    this.isOpen = !this.isOpen;
    const chatPanel = this.container.querySelector('.chat-panel');
    if (chatPanel) {
      chatPanel.classList.toggle('open', this.isOpen);
      if (this.isOpen) {
        const input = this.container.querySelector('.chat-input');
        // if (input) input.focus(); // Removed to prevent keyboard popup on mobile
        
        // –ú–∞—Ä–∫–∏—Ä–∞–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞ –∫–∞—Ç–æ –ø—Ä–æ—á–µ—Ç–µ–Ω–∏
        this.markAsRead();

        // –ü—Ä–µ–≤—ä—Ä—Ç–∏ –¥–æ –¥–æ–ª—É –≤–µ–¥–Ω–∞–≥–∞ –∏ —Å–ª–µ–¥ –º–∞–ª–∫–æ –∑–∞–∫—ä—Å–Ω–µ–Ω–∏–µ (–∑–∞—Ä–∞–¥–∏ –∞–Ω–∏–º–∞—Ü–∏—è—Ç–∞)
        this.scrollToBottom();
        setTimeout(() => this.scrollToBottom(), 100);
        setTimeout(() => this.scrollToBottom(), 300);
      }
    }
  }

  formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  linkifyText(text) {
    // –†–∞–∑–ø–æ–∑–Ω–∞–∏ URL-–∏ –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–π –≥–∏ –≤ –ª–∏–Ω–∫–æ–≤–µ
    const escaped = this.escapeHtml(text);
    // –ü—ä—Ä–≤–æ –∑–∞–º–µ–Ω–∏ –Ω–æ–≤–∏—Ç–µ —Ä–µ–¥–æ–≤–µ —Å <br>
    const withBreaks = escaped.replace(/\n/g, '<br>');
    // –°–ª–µ–¥ —Ç–æ–≤–∞ –¥–æ–±–∞–≤–∏ –ª–∏–Ω–∫–æ–≤–µ—Ç–µ
    const urlRegex = /(https?:\/\/[^\s<>\[\]{}|\\^`"]*)/g;
    return withBreaks.replace(urlRegex, (url) => {
      return `<a href="${url}" target="_blank" style="color: #4ade80; text-decoration: underline; cursor: pointer;">${url}</a>`;
    });
  }

  async deleteMessage(messageKey) {
        if (await this.chatFirebase.deleteMessage(messageKey)) {
            // –ü—Ä–µ–º–∞—Ö–Ω–∏ –ª–æ–∫–∞–ª–Ω–æ –≤–µ–¥–Ω–∞–≥–∞ —Å –∞–Ω–∏–º–∞—Ü–∏—è
            const messagesContainer = this.container.querySelector('.chat-messages');
            const messageEl = messagesContainer.querySelector(`[data-message-key="${messageKey}"]`);
            if (messageEl) {
                messageEl.style.opacity = '0';
                messageEl.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    messageEl.remove();
                }, 300);
            }
        } else {
            console.error('Failed to delete message via SDK');
        }
  }

  destroy() {
    this.chatFirebase.stop();
  }
}

// ============================================
// PART 4: INITIALIZATION
// ============================================

(async function initializeChat() {
  // console.log('Chat init...'); // Can be removed

  // Listen for changes in localStorage to sync user data across tabs
  window.addEventListener('storage', (event) => {
    if (event.key === 'loggedInUser' && event.newValue) {
      try {
        const newUserData = JSON.parse(event.newValue);
        // Check if the update is for the currently logged-in user
        if (window.currentUser && newUserData.uid === window.currentUser.userId) {
          // console.log('User data updated from another tab. Refreshing local state.'); // Can be removed
          
          // Update the global currentUser object
          Object.assign(window.currentUser, newUserData);
          
          // Force an immediate presence update with the new data (e.g., new color)
          if (window.chatManager && window.chatManager.chatFirebase) {
              window.chatManager.chatFirebase.forceUpdatePresence();
          }
        }
      } catch (e) { console.error('Error processing storage event:', e); }
    }
  });

  // Wait for the user identity to be resolved before doing anything else
  await window.currentUserPromise;
  
  let attempts = 0;
  const maxAttempts = 20;

  function tryInit() {
    attempts++;

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initChat);
    } else if (attempts < maxAttempts) {
      if (document.getElementById('chat-widget')) {
        initChat();
      } else {
        // Keep trying if widget is not yet in DOM
        setTimeout(tryInit, 100);
      }
    }
  }

  function initChat() {
    // console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º Chat UI...'); // Can be removed
    
    const chatWidget = document.getElementById('chat-widget');
    if (!chatWidget) {
      console.error('Chat widget –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω!');
      return;
    }

    // –ì–õ–û–ë–ê–õ–ï–ù –ß–ê–¢ –ó–ê –í–°–ò–ß–ö–ò –°–ê–ô–¢–û–í–ï
    const documentId = 'global-chat';

    let chatManager;
    try {
      chatManager = new ChatUIManager('chat-widget', documentId);
      window.chatManager = chatManager;
    //  console.log('‚úì‚úì‚úì Chat —Å–∏—Å—Ç–µ–º–∞ –ì–û–¢–û–í–ê!');
    } catch (error) {
      console.error('Chat init error:', error);
      return;
    }

    const chatIcon = document.getElementById('chat-toggle');
    if (chatIcon) {
      chatIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // console.log('üí¨ Click'); // Can be removed
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const chatCloseBtn = document.getElementById('chat-close');
    if (chatCloseBtn) {
      chatCloseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (window.chatManager) {
          window.chatManager.toggleChat();
        }
      });
    }

    const currentUserNameEl = document.getElementById('current-user-name');
    if (currentUserNameEl && window.currentUser) {
      currentUserNameEl.textContent = window.currentUser.userName;
    }

    // console.log('–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª:', window.currentUser.userName); // Can be removed
  }

  tryInit();
})();

// ============================================
// GLOBAL RESET FUNCTION - –¥–æ—Å—Ç—ä–ø–Ω–∞ –æ—Ç–≤—Å—è–∫—ä–¥–µ
// ============================================

window.resetChat = function() {
  localStorage.removeItem('userId');
  localStorage.removeItem('userName');
  localStorage.removeItem('userColor');
  console.log('‚úÖ –†–µ—Å–µ—Ç –∑–∞–≤—ä—Ä—à–µ–Ω! –ù–∞–ø–∏—à–∏ –≤ –∫–æ–Ω—Å–æ–ª–∞—Ç–∞: location.reload()');
};

window.deleteAllChatMessages = async function(password) {
  if (!password) {
    console.error('‚ùå –ü–∞—Ä–æ–ª–∞ –Ω–µ –µ –¥–∞–¥–µ–Ω–∞! –ò–∑–ø–æ–ª–∑–≤–∞–π: window.deleteAllChatMessages("admin")');
    return false;
  }

  if (password !== 'admin') {
    console.error('‚ùå –ì–†–ï–®–ù–ê –ü–ê–†–û–õ–ê!');
    return false;
  }

  try {
    const baseURL = 'https://med-student-chat-default-rtdb.europe-west1.firebasedatabase.app';
    const messagesRef = `${baseURL}/messages/global-chat.json`; // Fix: target global-chat
    const reactionsRef = `${baseURL}/reactions/global-chat.json`; // Fix: target global-chat

    // –ò–∑—Ç—Ä–∏–π —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞
    const msgResponse = await fetch(messagesRef, { method: 'DELETE' });
    if (!msgResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞');

    // –ò–∑—Ç—Ä–∏–π —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ
    const reactResponse = await fetch(reactionsRef, { method: 'DELETE' });
    if (!reactResponse.ok) throw new Error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Ä–µ–∞–∫—Ü–∏–∏—Ç–µ');

    console.log('‚úÖ –ß–ê–¢ –ò–ó–¢–†–ò–¢ –£–°–ü–ï–®–ù–û! –í—Å–∏—á–∫–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –∏ —Ä–µ–∞–∫—Ü–∏–∏ —Å–∞ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç–∏.');
    console.log('üí° –ù–∞–ø–∏—à–∏: location.reload() –∑–∞ –¥–∞ –≤–∏–¥–∏—à –ø—Ä–æ–º–µ–Ω–∏—Ç–µ');
    return true;
  } catch (error) {
    console.error('‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ —á–∞—Ç–∞:', error);
    return false;
  }
};

// console.log('üí° –ö–æ–º–∞–Ω–¥–∏: resetChat() - —Ä–µ—Å–µ—Ç –Ω–∞ –∏–º–µ');

// Cache buster
const CHAT_VERSION = '20260122_v2';
