<!DOCTYPE html>
<html lang="bg">
<head>
  <script src="js/auth-guard.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Course Viewer</title>
  <!-- Favicon -->
  <link rel="icon" href="favicon.svg?v=7" type="image/svg+xml">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  
  <!-- Firebase SDKs - Moved to head and using compat versions -->
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-database-compat.js"></script>
  
  <style>
    :root {
      --bg: #fafafa;
      --fg: #1f2937;
      --card: #ffffff;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    html { margin: 0; padding: 0; }
    html, body { margin: 0; padding: 0; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      font-size: 1em;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      padding: 10px 16px;
      margin: 0;
      flex-shrink: 0;
      display: flex; align-items: center; gap: 10px;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
    }
    header h1 {
      display: none;
    }
    header a.btn {
      display: inline-flex; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 6px; text-decoration: none;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
      transition: background 0.2s, transform 0.1s;
    }
    header button.btn {
      display: inline-flex; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 6px;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s, transform 0.1s;
    }
    header a.btn:hover, header button.btn:hover {
      background: #e0e7ff;
      transform: scale(1.05);
    }
    header a.btn:active, header button.btn:active {
      transform: scale(0.95);
    }
    header button.btn:hover {
      background: #e0e7ff;
      color: var(--link-hover);
    }
    header a.btn:nth-child(3) {
      display: none;
    }
    header button#summaryBtn {
      display: none !important;
    }
    header button#summaryBtn.visible {
      display: inline-flex !important;
    }
    header button#editBtn {
      display: none;
    }
    header button#editBtn.visible {
      display: inline-flex !important;
    }
    
    /* Navigation buttons visible on all devices, pushed to the right */
    header button#prevH1Btn {
      margin-left: auto;
    }
    
    header button#nextH1Btn {
      margin-right: 10px;
    }

    header a.btn:hover { background: #e0e7ff; color: var(--link-hover); }
    main { max-width: 1700px; margin: 0 auto; padding: 3px 3px; flex: 1; width: 100%; margin-top: 25px; }
    
    /* Hide edit button on mobile (screens 768px and smaller) */
    @media (max-width: 768px) {
      header button#editBtn,
      header button#editBtn.visible {
        display: none !important;
      }
    }

    /* Headings - match md-editor.html exactly */
    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4 {
      margin-top: 0.5em;
      margin-bottom: 0.15em;
      font-weight: 600;
    }

    .markdown-body h1 { font-size: 1.5em; color: #000000; }
    .markdown-body h2 { font-size: 1.3em; color: #000000; }
    .markdown-body h3 { font-size: 1.1em; color: #000000; margin-bottom: 0.1em; }
    .markdown-body h4 { font-size: 1.05em; color: #000000; margin-bottom: 0.1em; }

    /* Paragraphs - match md-editor.html */
    .markdown-body p {
      margin: 0.3em 0;
      white-space: pre-wrap;
    }

    /* Links */
    .markdown-body a { color: var(--link); text-decoration: underline; text-decoration-skip-ink: none; }
    .markdown-body a:hover { color: var(--link-hover); }
    
    /* Bold text */
    .markdown-body b,
    .markdown-body strong { font-weight: 600; }
    
    /* Italic text */
    .markdown-body em { font-style: italic; }

    /* Lists - CRITICAL: Fix for list formatting */
    .markdown-body ul,
    .markdown-body ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
      list-style-position: outside;
    }

    .markdown-body li {
      margin: 0.2em 0;
      padding: 0;
      display: list-item;
    }

    /* Remove <p> tags inside list items - they should not exist */
    .markdown-body li p {
      margin: 0 !important;
      padding: 0 !important;
      display: inline !important;
    }

    /* Prevent nested list paragraph issues */
    .markdown-body li > ul,
    .markdown-body li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }

    /* Ensure list structure is clean */
    .markdown-body ul ul, .markdown-body ul ol,
    .markdown-body ol ul, .markdown-body ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }

    /* Reduce space between paragraph and following list */
    .markdown-body p + ul,
    .markdown-body p + ol {
      margin-top: -0.5em;
    }

    /* Reduce space between heading and following content */
    .markdown-body h1 + p,
    .markdown-body h2 + p,
    .markdown-body h3 + p,
    .markdown-body h4 + p,
    .markdown-body h1 + ul,
    .markdown-body h2 + ul,
    .markdown-body h3 + ul,
    .markdown-body h4 + ul,
    .markdown-body h1 + ol,
    .markdown-body h2 + ol,
    .markdown-body h3 + ol,
    .markdown-body h4 + ol {
      margin-top: 0.1em;
    }

    /* Reduce space between h3 and h4 */
    .markdown-body h3 + h4 {
      margin-top: 0.3em;
    }

    /* Additional list styles */
    .markdown-body ul,
    .markdown-body ol {
      margin: 0.3em 0;
      padding-left: 1.5em;
    }

    .markdown-body li {
      margin: 0.15em 0;
    }

    .markdown-body ul ul {
      list-style-type: circle;
    }

    .markdown-body ul ul ul {
      list-style-type: square;
    }

    /* Add padding to content so h1 doesn't hide under fixed header */
    #content { padding-top: 20px; }

    /* Tables: make horizontally scrollable on small screens */
    .table-scroll { overflow-x: auto; margin: 0.5em 0; }
    .table-scroll table { min-width: 560px; }

    .markdown-body table { width: 100%; border-collapse: collapse; margin: 0.2em 0; table-layout: auto; }
    .markdown-body th, .markdown-body td { border: 1px solid rgba(146, 64, 14, 0.35); padding: 6px 10px; text-align: left; vertical-align: top; height: 24px; line-height: 1.2; }
    .markdown-body thead th { background: rgba(196, 127, 9, 0.08); font-weight: 600; }
    .markdown-body tbody tr:nth-child(odd) { background: rgba(146, 64, 14, 0.03); }

    pre, code { font-family: Consolas, 'Courier New', monospace; }
    pre { background: var(--bg); padding: 12px; border-radius: 6px; overflow-x: auto; border: 1px solid var(--border); color: var(--fg); }
    code { background: var(--bg); padding: 2px 6px; border-radius: 4px; color: var(--fg); }

    /* Note styles for viewing exported HTML files */
    .markdown-body .editor-note {
      text-decoration: underline dotted #a3b18a;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
      text-decoration-skip-ink: none;
      cursor: help;
      position: relative;
    }

    #noteTooltipViewer {
      position: absolute;
      display: none;
      background-color: #f0f7f0;
      color: #1f2937;
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      max-width: 500px;
      word-wrap: break-word;
      z-index: 10000;
      font-size: 0.9em;
      line-height: 1.4;
      border: 1px solid #588157;
    #noteTooltipViewer ul, #noteTooltipViewer ol {
      margin: 0 !important;
      padding-left: 20px !important;
    }
    #noteTooltipViewer li {
      margin: 0 0 0.1em 0 !important;
      padding: 0 !important;
      line-height: 1.2 !important;
    }
    #noteTooltipViewer li:last-child {
      margin-bottom: 0 !important;
    }

    @media (max-width: 768px) {
      main { padding: 12px; }
      .markdown-body { font-size: 0.83em; font-weight: 300; }
      .table-scroll table { font-size: 0.83em; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // Configure marked.js to handle custom image width
    marked.use({
      renderer: {
        image(href, title, text) {
          let dataWidth = '';

          if (title) {
            const widthMatch = title.match(/width=(\d+)%/);
            if (widthMatch && widthMatch[1]) {
              style = `max-width:${widthMatch[1]}%; height:auto;`; // min-width removed
              dataWidth = ` data-width="${widthMatch[1]}"`;
            }
          }
          // Remove the custom width from the title so it doesn't show as a tooltip
          const cleanTitle = title ? title.replace(/width=\d+%/g, '').trim() : '';

          // Add data-original-src for consistency if not already an online image
          const dataOriginalSrc = (href.startsWith('http://') || href.startsWith('https://'))
            ? `data-original-src="${href}"`
            : '';

          return `<img src="${href}" alt="${text}" style="${style}"${dataWidth}${dataOriginalSrc}${cleanTitle ? ` title="${cleanTitle}"` : ''}>`;
        }
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
</head>
<body>
  <header>
    <h1 id="docTitle">Преглед на документ</h1>
    <a class="btn" href="#" onclick="if (window.opener) { window.close(); } else if (document.referrer) { history.back(); } else { window.close(); } return false;" title="Назад">
      <img src="svg/md-viewer/icon-close.svg" alt="Назад" width="25" height="25">
    </a>
    <button id="summaryBtn" class="btn" title="Summary">
      <img src="svg/md-viewer/icon-summary.svg" alt="Summary" width="20" height="20">
    </button>
    <button id="editBtn" class="btn" title="Редактирай">
      <img src="svg/md-viewer/icon-edit.svg" alt="Редактирай" width="20" height="20">
    </button>
    <button id="fontSizeBtn" class="btn" title="Change Font Size">
      <img src="svg/md-viewer/icon-textsize.svg" alt="Change Font Size" width="20" height="20">
    </button>
    <button id="notes-toggle-btn" class="btn" title="Бележки">
      <img src="svg/md-viewer/icon-notes.svg" alt="Бележки" width="20" height="20">
    </button>
    <button id="prevH1Btn" class="btn" title="Предишно заглавие">
      <img src="svg/md-viewer/icon-arrow-left.svg" alt="Предишно" width="20" height="20">
    </button>
    <button id="nextH1Btn" class="btn" title="Следващо заглавие">
      <img src="svg/md-viewer/icon-arrow-right.svg" alt="Следващо" width="20" height="20">
    </button>
  </header>
  <main>
    <div id="content" class="markdown-body">Зареждане…</div>
  </main>
  <script>
    // Function to process table rowspans (convert ^ to rowspan)
    function processTableRowspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each column
        const maxCols = Math.max(...rows.map(row => row.cells.length));
        
        for (let colIndex = 0; colIndex < maxCols; colIndex++) {
          let spanStart = -1;
          let spanCount = 0;
          
          for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            const cell = rows[rowIndex].cells[colIndex];
            
            if (!cell) continue;
            
            const cellText = cell.textContent.trim();
            
            if (cellText === '^') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply rowspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = rows[spanStart].cells[colIndex];
                if (spanCell) {
                  spanCell.setAttribute('rowspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = rowIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = rows[spanStart].cells[colIndex];
            if (spanCell) {
              spanCell.setAttribute('rowspan', spanCount + 1);
            }
          }
        }
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table colspans (convert < to colspan)
    function processTableColspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each row
        rows.forEach(row => {
          const cells = Array.from(row.cells);
          let spanStart = -1;
          let spanCount = 0;
          
          for (let colIndex = 0; colIndex < cells.length; colIndex++) {
            const cell = cells[colIndex];
            const cellText = cell.innerHTML.trim();
            
            if (cellText === '&lt;') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete-colspan', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply colspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = cells[spanStart];
                if (spanCell) {
                  spanCell.setAttribute('colspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = colIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = cells[spanStart];
            if (spanCell) {
              spanCell.setAttribute('colspan', spanCount + 1);
            }
          }
        });
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete-colspan="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table cell alignment (>>text<<, <<text, text>>)
    function processTableAlignment(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const allCells = table.querySelectorAll('td, th');
        
        allCells.forEach(cell => {
          let content = cell.innerHTML.trim();
          
          // Check for center alignment >>text<<
          if (content.startsWith('&gt;&gt;') && content.endsWith('&lt;&lt;')) {
            cell.style.textAlign = 'center';
            cell.innerHTML = content.slice(8, -8); // Remove &gt;&gt; and &lt;&lt;
          }
          // Check for left alignment <<text
          else if (content.startsWith('&lt;&lt;')) {
            cell.style.textAlign = 'left';
            cell.innerHTML = content.slice(8); // Remove &lt;&lt;
          }
          // Check for right alignment text>>
          else if (content.endsWith('&gt;&gt;')) {
            cell.style.textAlign = 'right';
            cell.innerHTML = content.slice(0, -8); // Remove &gt;&gt;
          }
        });
      });
      
      return doc.body.innerHTML;
    }

    // Function to load summary file
    function loadSummary(summaryPath) {
      console.log('loadSummary function called with:', summaryPath);
      const decodedPath = decodeURIComponent(summaryPath);
      const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
      const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
        ? new URL(encodedPath, window.location.origin).href
        : encodedPath;
      
      console.log('Fetching from:', absoluteUrl);

      fetch(absoluteUrl).then(r=>{ 
        if(!r.ok) throw new Error('HTTP '+r.status); 
        return r.text(); 
      })
        .then(content => {
          let html;
          
          if (/\.html$/i.test(decodedPath)) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract CSS from <style> tags
            const styles = doc.head.querySelectorAll('style');
            let cssContent = '';
            styles.forEach(style => {
              cssContent += style.textContent;
            });
            
            // Add !important to override md-viewer styles
            if (cssContent) {
              const existingStyles = document.querySelectorAll('style');
              let styleExists = false;
              existingStyles.forEach(s => {
                if (s.textContent.includes('/* Imported from file */')) {
                  styleExists = true;
                  s.remove();
                }
              });
              
              cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
              cssContent = '/* Imported from file */\n' + cssContent;
              const styleTag = document.createElement('style');
              styleTag.textContent = cssContent;
              document.head.appendChild(styleTag);
            }
            
            html = doc.body.innerHTML;
          } else {
            html = marked.parse(content);
          }
          
          const root = document.getElementById('content');
          root.innerHTML = html;
          
          // Render LaTeX
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
          
          root.querySelectorAll('a').forEach(a => a.target = '_blank');
        })
        .catch(err => {
          console.error('Error loading summary:', err);
        });
    }

    (function(){
      function getParam(name){ const u=new URL(window.location.href); return u.searchParams.get(name); }
      const path = getParam('path');
      const loadFromHash = getParam('loadFromHash') === 'true';
      if(!path){ document.getElementById('content').textContent = 'Липсва параметър path.'; return; }
      const decodedPath = decodeURIComponent(path);
      const title = decodedPath.split('/').pop()
        .replace(/^\d+-msg-/, '') // Remove "NUMBER-msg-" prefix
        .replace(/\.(html|md|txt)$/i, ''); // Remove extension
      document.title = title;
      document.getElementById('docTitle').textContent = title;
      const dl = document.getElementById('downloadLink');
      dl.href = decodedPath;

      // Check if content is passed via sessionKey (sessionStorage)
      const sessionKey = getParam('sessionKey');
      let contentPromise;
      
      if (sessionKey && window.sessionStorage) {
        // Content passed via sessionStorage - use it directly (no fetch needed)
        const htmlContent = sessionStorage.getItem(sessionKey);
        if (htmlContent) {
          contentPromise = Promise.resolve(htmlContent);
        } else {
          // Fallback to fetch if sessionStorage is empty
          const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
          const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
            ? new URL(encodedPath, window.location.origin).href
            : encodedPath;
          contentPromise = fetch(absoluteUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
        }
      } else if (loadFromHash && window.location.hash) {
        // If content is passed in hash, use it directly (no fetch needed)
        try {
          const htmlContent = decodeURIComponent(window.location.hash.substring(1));
          const root = document.getElementById('content');
          root.innerHTML = htmlContent;
          
          // Render LaTeX with auto-render
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
        } catch (err) {
          document.getElementById('content').textContent = 'Грешка при зареждане на съдържанието: ' + err.message;
        }
        return;
      } else {
        // Fetch from URL
        const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
        const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
          ? new URL(encodedPath, window.location.origin).href
          : encodedPath;
        
        // Add cache buster to ensure fresh content
        const fetchUrl = absoluteUrl + (absoluteUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
        contentPromise = fetch(fetchUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
      }

      contentPromise.then(content => {
          let html;
          
          // If it's an HTML file, extract body content directly
          if (/\.html$/i.test(decodedPath)) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract CSS from <style> tags in <head>
            const styles = doc.head.querySelectorAll('style');
            let cssContent = '';
            styles.forEach(style => {
              cssContent += style.textContent;
            });
            
            // Inject CSS into current document if found
            if (cssContent) {
              const styleTag = document.createElement('style');
              // Add !important to all rules to override md-viewer styles but preserve font-size
              cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
              styleTag.textContent = cssContent;
              document.head.appendChild(styleTag);
            }
            
            html = doc.body.innerHTML;
          } else {
            // Otherwise parse as Markdown
            html = marked.parse(content);
            
            // Convert ~~~ paragraphs to dashed <hr>
            html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
            
            // Process tables to support rowspan with ^ syntax (only if needed)
            if (html.includes('^')) {
              html = processTableRowspans(html);
            }
            
            // Process tables to support cell alignment with >>text<<, <<text, text>> (BEFORE colspan!)
            if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) {
              html = processTableAlignment(html);
            }
            
            // Process tables to support colspan with < syntax (only if needed)
            if (html.includes('&lt;')) {
              html = processTableColspans(html);
            }
          }
          
          const root = document.getElementById('content');
          root.innerHTML = html;
          
          // Images now use relative paths like "assets/image.png" which resolve correctly
          // from md-viewer.html location since all assets are in the central assets/ folder
          // No path fixing needed!
          
          // Render LaTeX with auto-render - simple and direct
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
          
          // Make all links open in new tab
          root.querySelectorAll('a').forEach(a => a.target = '_blank');
          
          // Setup summary toggle button
          const summaryBtn = document.getElementById('summaryBtn');
          if (!summaryBtn) {
            console.error('Summary button not found!');
          } else {
            // Summary button handler is set up outside IIFE
          }
        })
        .catch(err => {
          console.warn('Initial fetch failed, attempting to recover from courses data:', err);
          
          const contentDiv = document.getElementById('content');
          // Don't show error yet, keep "Зареждане..." or show a softer message if needed
          // contentDiv.textContent = 'Зареждане от локални данни...'; 

          // Polling mechanism to wait for courses.generated.js
          let attempts = 0;
          const maxAttempts = 50; // 5 seconds (50 * 100ms)
          
          const pollCourses = setInterval(() => {
            attempts++;
            
            if (typeof courses !== 'undefined') {
              clearInterval(pollCourses);
              recoverContentFromCourses();
            } else if (attempts >= maxAttempts) {
              clearInterval(pollCourses);
              showError(err);
            }
          }, 100);

          function recoverContentFromCourses() {
            const path = getParam('path');
            if (!path) { showError(err); return; }
            
            const decodedPath = decodeURIComponent(path);
            const normalizedPath = decodedPath.replace(/\\/g, '/');
            
            // Search logic (duplicated for resilience inside this closure)
            let fileData = null;
            
            // Helper to search sections
            const searchSection = (section) => {
              if (section.files) {
                for (const file of section.files) {
                  if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) return file;
                }
              }
              if (section.msgNotes) {
                for (const note of section.msgNotes) {
                  if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) return note;
                }
              }
              if (section.subsections) {
                for (const subsection of section.subsections) {
                  const result = searchSection(subsection);
                  if (result) return result;
                }
              }
              return null;
            };

            for (const course of courses) {
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) {
                    fileData = result;
                    break;
                  }
                }
              }
              if (fileData) break;
            }

            if (fileData && fileData.content) {
              console.log('Successfully recovered content from courses data');
              // Render content
              let html;
              if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
                 const parser = new DOMParser();
                 const doc = parser.parseFromString(fileData.content, 'text/html');
                 const styles = doc.head.querySelectorAll('style');
                 let cssContent = '';
                 styles.forEach(style => { cssContent += style.textContent; });
                 if (cssContent) {
                    const styleTag = document.createElement('style');
                    cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
                    styleTag.textContent = cssContent;
                    document.head.appendChild(styleTag);
                 }
                 html = doc.body.innerHTML;
              } else {
                 html = marked.parse(fileData.content);
                 html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
                 if (html.includes('^')) html = processTableRowspans(html);
                 if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) html = processTableAlignment(html);
                 if (html.includes('&lt;')) html = processTableColspans(html);
              }
              
              contentDiv.innerHTML = html;
              
              if (typeof renderMathInElement !== 'undefined') {
                try { renderMathInElement(contentDiv, { delimiters: [{left: '$', right: '$', display: true}, {left: '
    })();
    
    // Setup summary button - outside IIFE so it always works
    const summaryBtn = document.getElementById('summaryBtn');
  //  console.log('Summary button setup starting, button exists:', !!summaryBtn);
    
    let originalPath = null;
    let isSummaryMode = false;
    let summaryPath = null;
    let buttonSetupDone = false;
    
    // Setup button when page loads
    const setupButton = () => {
      if (buttonSetupDone) {
     //   console.log('Button already setup, skipping');
        return;
      }
      buttonSetupDone = true;
      if (!originalPath) {
        const urlParams = new URLSearchParams(window.location.search);
        const pathParam = urlParams.get('path');
        if (pathParam) {
          originalPath = decodeURIComponent(pathParam);
        }
      }
      
      if (!originalPath || !summaryBtn || typeof courses === 'undefined') {
        console.log('Cannot setup button:', { originalPath, summaryBtn: !!summaryBtn, courses: typeof courses });
        return;
      }
      
      summaryPath = originalPath.replace(/(-msg-)(.*)(\.(html|md|txt))$/i, '$1summary-$2$3');
      console.log('Summary path:', summaryPath);
      
      // Check if summary file exists in courses
      let summaryFileExists = false;
      const normalizedPath = summaryPath.replace(/\\/g, '/');
      
      outerLoop: for (const course of courses) {
        function searchSection(section) {
          if (section.files) {
            for (const file of section.files) {
              if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                return true;
              }
            }
          }
          if (section.msgNotes) {
            for (const note of section.msgNotes) {
              if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                return true;
              }
            }
          }
          if (section.subsections) {
            for (const subsection of section.subsections) {
              if (searchSection(subsection)) return true;
            }
          }
          return false;
        }
        
        if (course.sections) {
          for (const section of course.sections) {
            if (searchSection(section)) {
              summaryFileExists = true;
              break outerLoop;
            }
          }
        }
      }
      
      console.log('Summary file exists:', summaryFileExists);
      if (summaryFileExists) {
        summaryBtn.classList.add('visible');
      } else {
        summaryBtn.classList.remove('visible');
      }
      
      // Setup click handler
      summaryBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (originalPath) {
          isSummaryMode = !isSummaryMode;
          const pathToLoad = isSummaryMode ? summaryPath : originalPath;
          console.log('Loading:', pathToLoad);
          
          // Find and display content
          function findFileContent(filePath) {
            const normalizedPath = filePath.replace(/\\/g, '/');
            
            for (const course of courses) {
              function searchSection(section) {
                if (section.files) {
                  for (const file of section.files) {
                    if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                      return file;
                    }
                  }
                }
                if (section.msgNotes) {
                  for (const note of section.msgNotes) {
                    if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                      return note;
                    }
                  }
                }
                if (section.subsections) {
                  for (const subsection of section.subsections) {
                    const result = searchSection(subsection);
                    if (result) return result;
                  }
                }
                return null;
              }
              
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) return result;
                }
              }
            }
            return null;
          }
          
          const fileData = findFileContent(pathToLoad);
          if (fileData && fileData.content) {
            const root = document.getElementById('content');
            
            if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(fileData.content, 'text/html');
              
              const styles = doc.head.querySelectorAll('style');
              const existingStyles = document.querySelectorAll('style');
              existingStyles.forEach(s => {
                if (s.textContent.includes('/* Imported from file */')) {
                  s.remove();
                }
              });
              
              let cssContent = '';
              styles.forEach(style => {
                cssContent += style.textContent;
              });
              
              if (cssContent) {
                cssContent = cssContent.split('}').filter(rule => rule.trim()).map(rule => {
                  const selector = rule.split('{')[0].trim();
                  const styles = rule.split('{')[1] || '';
                  
                  // Skip only body, html, and :root selectors - include h1 and other tags
                  if (!selector || selector.match(/^(body|html|:root)$/i)) {
                    return rule + '}';
                  }
                  
                  // Scope to #content for everything else including h1
                  return `#content ${selector} { ${styles} }`;
                }).join('');
                
                cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
                cssContent = '/* Imported from file */\n' + cssContent;
                const styleTag = document.createElement('style');
                styleTag.textContent = cssContent;
                document.head.appendChild(styleTag);
              }
              
              root.innerHTML = doc.body.innerHTML;
            } else {
              root.innerHTML = fileData.content;
            }
            
            window.scrollTo(0, 0);
          }
        }
      });
    };
    
    // Call setup when DOM is ready and courses is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupButton);
    } else {
      setupButton();
    }
    
    // Also try to setup after a short delay to ensure courses is loaded
    setTimeout(setupButton, 100);
    
    // Font size control - outside IIFE so it works immediately
    const fontSizeBtn = document.getElementById('fontSizeBtn');
    const contentDiv = document.getElementById('content');
    
    // Load saved font size from localStorage
    const savedFontSize = localStorage.getItem('mdViewerFontSize');
    if (savedFontSize && contentDiv) {
      contentDiv.style.fontSize = savedFontSize;
    }
    
    // Detect if mobile
    const isMobile = window.innerWidth <= 768;
    
    // Font size increment levels - different for mobile and desktop
    const fontSizes = isMobile 
      ? ['0.6em', '0.75em', '0.9em', '1em'] // Mobile sizes (smaller)
      : ['0.8em', '1em', '1.2em', '1.4em']; // Desktop sizes
    
    let currentSizeIndex = fontSizes.findIndex(size => {
      if (savedFontSize) return size === savedFontSize;
      return isMobile ? size === '0.75em' : size === '1em'; // Default
    });
    if (currentSizeIndex === -1) currentSizeIndex = isMobile ? 1 : 1;
    
    fontSizeBtn.addEventListener('click', () => {
      currentSizeIndex = (currentSizeIndex + 1) % fontSizes.length;
      const newSize = fontSizes[currentSizeIndex];
      
      contentDiv.style.fontSize = newSize;
      
      // Save to localStorage
      localStorage.setItem('mdViewerFontSize', newSize);
      
      // Visual feedback
      fontSizeBtn.style.transform = 'scale(1.1)';
      setTimeout(() => {
        fontSizeBtn.style.transform = 'scale(1)';
      }, 200);
    });
    
    // Add transition to button
    fontSizeBtn.style.transition = 'transform 0.2s ease';
    
    // Edit button handler
    let currentEditPath = null;
    let currentEditContent = null;
    
    function setupEditButton() {
      const editBtn = document.getElementById('editBtn');
      if (!editBtn) return;
      
      // Get the current file path from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const filePath = urlParams.get('path');
      
      if (filePath) {
        currentEditPath = filePath;
        // Make button visible on desktop/tablet
        if (window.innerWidth > 768) {
          editBtn.classList.add('visible');
        }
        
        editBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          // Find file content from courses data
          const normalizedPath = filePath.replace(/\\/g, '/');
          let fileData = null;
          
          function searchSection(section) {
            if (section.files) {
              for (const file of section.files) {
                if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                  return file;
                }
              }
            }
            if (section.msgNotes) {
              for (const note of section.msgNotes) {
                if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                  return note;
                }
              }
            }
            if (section.subsections) {
              for (const subsection of section.subsections) {
                const result = searchSection(subsection);
                if (result) return result;
              }
            }
            return null;
          }
          
          // Search through courses
          if (typeof courses !== 'undefined') {
            for (const course of courses) {
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) {
                    fileData = result;
                    break;
                  }
                }
              }
              if (fileData) break;
            }
          }
          
          if (fileData && fileData.content) {
            // Store content in sessionStorage to avoid URL length limits
            sessionStorage.setItem('editFileContent', fileData.content);
            sessionStorage.setItem('editFilePath', filePath);
            
            // Navigate to md-editor
            window.location.href = `text-editor.html?editMode=true`;
          } else {
            alert('Не беше намерено содържанието на файла. Файлът може да не е включен в courses.generated.js');
          }
        });
      }
    }
    
    // Setup edit button when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupEditButton);
    } else {
      setupEditButton();
    }
    
    // Also try to setup after a short delay
    setTimeout(setupEditButton, 100);
  </script>
  
  <!-- Load courses data for summary file detection -->
  <script src="courses.generated.js?v=20260128l5d"></script>

  <!-- ============================================
       CHAT SYSTEM - Firebase & Notes
       ============================================ -->


  
<script src="js/user-identity.js?v=20260125"></script>
  <script src="js/chat.js?v=20260125"></script>
  <script src="js/presence.js?v=20260125"></script>

  <!-- Chat Widget HTML -->
  <div id="chat-widget" class="chat-widget">
    <button class="chat-icon" id="chat-toggle" title="Отвори чат">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
      </svg>
      <span class="chat-badge-count" style="display: none;">0</span>
      <span class="chat-notification-pulse"></span>
    </button>

    <div class="chat-panel">
          <div class="chat-header">
            <div class="chat-header-title">
                      <div style="font-size: 18px; font-weight: bold; margin: 0;">Чат</div>
                      <span class="chat-online-count" style="font-size: 13px;">Активни: 1</span>
                    </div>            <div style="display: flex; gap: 8px;">
              <button class="chat-header-btn" id="chat-members-toggle" title="Активни членове">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                  <circle cx="9" cy="7" r="4"></circle>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
              </button>
              <button class="chat-close-btn" id="chat-close" title="Затвори чат">✕</button>
            </div>
          </div>
      <div class="chat-container">
        <div class="chat-messages-wrapper">
          <div class="chat-messages"></div>
        </div>
        <div class="chat-active-users"></div>
      </div>

      <div class="chat-input-area">
        <textarea
          class="chat-input"
          placeholder="Напиши съобщение..."
          rows="1"
          maxlength="500"
        ></textarea>
        <button class="chat-send-btn" title="Изпрати">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
            <path d="M16.6915026,12.4744748 L3.50612381,13.2599618 C3.19218622,13.2599618 3.03521743,13.4170592 3.03521743,13.5741566 L1.15159189,20.0151496 C0.8376543,20.8006365 0.99,21.89 1.77946707,22.52 C2.41,22.99 3.50612381,23.1 4.13399899,22.8429026 L21.714504,14.0454487 C22.6563168,13.5741566 23.1272231,12.6315722 22.9702544,11.6889879 L4.13399899,1.16151496 C3.34915502,0.9 2.40734225,0.9 1.77946707,1.4429026 C0.994623095,2.08 0.837654326,3.0226 1.15159189,3.97788954 L3.03521743,10.4188814 C3.03521743,10.5759788 3.34915502,10.7330762 3.50612381,10.7330762 L16.6915026,11.5185631 C16.6915026,11.5185631 17.1624089,11.5185631 17.1624089,12.0598639 C17.1624089,12.4744748 16.6915026,12.4744748 16.6915026,12.4744748 Z"></path>
          </svg>
        </button>
      </div>

      <!-- User info removed -->
    </div>
  </div>

  <!-- Notes Widget HTML -->
  <!-- <div id="notes-widget" class="notes-widget">
    <div class="notes-panel">
      <div class="notes-header">
        <div class="notes-header-title">
          <div style="font-size: 18px; font-weight: bold; margin: 0;">Бележки</div>
        </div>
        <button class="notes-close-btn" id="notes-close" title="Затвори бележки">✕</button>
      </div>

      <div class="notes-container">
        <div class="notes-list" style="flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px;"></div>
      </div>

      <div class="notes-input-area">
        <textarea class="notes-input" placeholder="Напиши бележка..." style="max-height: 80px; resize: vertical;"></textarea>
        <button class="notes-send-btn" title="Добави бележка">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
            <path d="M16.6915026,12.4744748 L3.50612381,13.2599618 C3.19218622,13.2599618 3.03521743,13.4170592 3.03521743,13.5741566 L1.15159189,20.0151496 C0.8376543,20.8006365 0.99,21.89 1.77946707,22.52 C2.41,22.99 3.50612381,23.1 4.13399899,22.8429026 L21.714504,14.0454487 C22.6563168,13.5741566 23.1272231,12.6315722 22.9702544,11.6889879 L4.13399899,1.16151496 C3.34915502,0.9 2.40734225,0.9 1.77946707,1.4429026 C0.994623095,2.08 0.837654326,3.0226 1.15159189,3.97788954 L3.03521743,10.4188814 C3.03521743,10.5759788 3.34915502,10.7330762 3.50612381,10.7330762 L16.6915026,11.5185631 C16.6915026,11.5185631 17.1624089,11.5185631 17.1624089,12.0598639 C17.1624089,12.4744748 16.6915026,12.4744748 16.6915026,12.4744748 Z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div> -->

  <style>
    /* Notes Widget Styles */
    #notes-widget { --notes-primary: #588157; --notes-secondary: #efebe9; --notes-border: #588157; --notes-text: #2c1810; --notes-text-light: #6d4c41; }
    .notes-widget { position: fixed; bottom: 20px; left: 20px; z-index: 4999; font-family: 'Open Sans', Arial, sans-serif; }
    .notes-panel { position: fixed; bottom: 90px; left: 20px; width: 400px; height: 500px; background: white; border-radius: 12px; box-shadow: 0 5px 40px rgba(0, 0, 0, 0.16); display: flex; flex-direction: column; opacity: 0; pointer-events: none; transform: translateY(20px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .notes-header { padding: 16px; border-bottom: 1px solid var(--notes-border); display: flex; justify-content: space-between; align-items: flex-start; background: linear-gradient(135deg, #588157 0%, #588157 100%); color: white; border-radius: 12px 12px 0 0; }
    .notes-header-title h3 { margin: 0 0 4px 0; font-size: 16px; font-weight: 600; }
    .notes-close-btn { background: rgba(255, 255, 255, 0.15); border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 6px; transition: background 0.2s; }
    .notes-close-btn:hover { background: rgba(255, 255, 255, 0.25); }
    .notes-container { display: flex; flex: 1; min-height: 0; overflow: hidden; }
    .notes-list { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
    .notes-input-area { display: flex; gap: 8px; padding: 12px; border-top: 1px solid color#588157; background: #fafafa; flex-direction: column; border-radius: 0 0 12px 12px; }
    .notes-input { flex: 1; border: 1px solid color #588157; border-radius: 8px; padding: 8px 12px; font-size: 13px; font-family: inherit; outline: none; transition: all 0.2s; resize: vertical; max-height: 80px; min-height: 40px; }
    .notes-input:focus { border-color: #588157; box-shadow: 0 0 0 3px rgba(88, 129, 87, 0.1); }
    .notes-send-btn { width: 36px; height: 36px; border: none; background: #588157; color: white; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; align-self: flex-end; }
    .notes-send-btn:hover { background: #588157; transform: scale(1.05); }
    .notes-send-btn:active { transform: scale(0.95); }
    
    /* Note item styles */
    .note-item { animation: slideIn 0.3s ease; }
    .note-reply { animation: slideIn 0.3s ease; }
    
    @media (max-width: 900px) { 
      .notes-widget, .notes-panel { bottom: 20px; left: 20px; } 
      .notes-panel { width: calc(100vw - 40px); max-width: 400px; bottom: 90px; left: 20px; right: auto; }
    }
    .notes-list::-webkit-scrollbar { width: 6px; }
    .notes-list::-webkit-scrollbar-track { background: transparent; }
    .notes-list::-webkit-scrollbar-thumb { background: var(--notes-border); border-radius: 3px; }
  </style>

  <!-- Chat Initialization -->
  <script src="js/chat-init.js?v=202404231000"></script>

  <!-- Notes Initialization -->
  <script src="js/notes-init.js?v=20260125"></script>

  <!-- H1 Navigation with Arrow Keys -->
  <script>
    (function() {
      let h1Elements = [];
      let currentH1Index = -1;
      
      // Function to update h1 elements list
      function updateH1List() {
        h1Elements = Array.from(document.querySelectorAll('#content h1'));
     //   console.log('Found', h1Elements.length, 'h1 elements');
      }
      
      // Function to scroll to h1 element
      function scrollToH1(index) {
        if (index >= 0 && index < h1Elements.length) {
          const h1 = h1Elements[index];
          const headerHeight = document.querySelector('header').offsetHeight || 0;
          const yOffset = -headerHeight - 20; // Add some extra padding
          const y = h1.getBoundingClientRect().top + window.pageYOffset + yOffset;
          
          window.scrollTo({ top: y, behavior: 'auto' });
          currentH1Index = index;
          
          // Visual feedback - briefly highlight the h1
          h1.style.transition = 'background-color 0.3s ease';
          const originalBg = h1.style.backgroundColor;
          h1.style.backgroundColor = 'rgba(124, 58, 237, 0.1)';
          setTimeout(() => {
            h1.style.backgroundColor = originalBg;
          }, 600);
        }
      }
      
      // Function to find current h1 based on scroll position
      function findCurrentH1() {
        const scrollPosition = window.scrollY + 100; // Offset for header
        
        for (let i = h1Elements.length - 1; i >= 0; i--) {
          if (h1Elements[i].offsetTop <= scrollPosition) {
            return i;
          }
        }
        return 0;
      }
      
      // Button Handlers for Mobile
      const prevH1Btn = document.getElementById('prevH1Btn');
      const nextH1Btn = document.getElementById('nextH1Btn');

      if (prevH1Btn) {
        prevH1Btn.addEventListener('click', (e) => {
          e.preventDefault();
          // Update list if needed (in case content changed)
          if (h1Elements.length === 0) {
            updateH1List();
          }
          if (h1Elements.length === 0) return;

          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const prevIndex = (currentH1Index - 1 + h1Elements.length) % h1Elements.length;
          scrollToH1(prevIndex);
        });
      }

      if (nextH1Btn) {
        nextH1Btn.addEventListener('click', (e) => {
          e.preventDefault();
          // Update list if needed (in case content changed)
          if (h1Elements.length === 0) {
            updateH1List();
          }
          if (h1Elements.length === 0) return;

          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const nextIndex = (currentH1Index + 1) % h1Elements.length;
          scrollToH1(nextIndex);
        });
      }

      // Listen for arrow key presses
      document.addEventListener('keydown', (e) => {
        // Ignore if user is typing in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }
        
        // Update list if needed (in case content changed)
        if (h1Elements.length === 0) {
          updateH1List();
        }
        
        if (h1Elements.length === 0) return;
        
        // Right Arrow - next h1
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const nextIndex = (currentH1Index + 1) % h1Elements.length;
          scrollToH1(nextIndex);
        }
        
        // Left Arrow - previous h1
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const prevIndex = (currentH1Index - 1 + h1Elements.length) % h1Elements.length;
          scrollToH1(prevIndex);
        }
      });
      
      // Initialize h1 list when content loads
      function initH1Navigation() {
        setTimeout(() => {
          updateH1List();
        }, 500);
      }
      
      // Watch for content changes
      const contentDiv = document.getElementById('content');
      if (contentDiv) {
        const observer = new MutationObserver(() => {
          updateH1List();
        });
        
        observer.observe(contentDiv, {
          childList: true,
          subtree: true
        });
      }
      
      // Initialize on page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initH1Navigation);
      } else {
        initH1Navigation();
      }
    })();
  </script>

  <script>
    // Note tooltip functionality for viewing exported HTML files
    let noteTooltip = null;

    function createNoteTooltipViewer() {
      if (!noteTooltip) {
        noteTooltip = document.createElement('div');
        noteTooltip.id = 'noteTooltipViewer';
        document.body.appendChild(noteTooltip);
      }
    }

    function parseNoteMarkdown(text) {
      if (!text) return '';
      
      let lines = text.split('\n');
      let html = [];
      let inUl = false;
      let inOl = false;
      
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        
        if (/^\s*[-*]\s+(.+)/.test(line)) {
          if (!inUl) {
            if (inOl) {
              html.push('</ol>');
              inOl = false;
            }
            html.push('<ul>');
            inUl = true;
          }
          let match = line.match(/^\s*[-*]\s+(.+)/);
          html.push('<li>' + match[1] + '</li>');
        }
        else if (/^\s*\d+\.\s+(.+)/.test(line)) {
          if (!inOl) {
            if (inUl) {
              html.push('</ul>');
              inUl = false;
            }
            html.push('<ol>');
            inOl = true;
          }
          let match = line.match(/^\s*\d+\.\s+(.+)/);
          html.push('<li>' + match[1] + '</li>');
        }
        else {
          if (inUl) {
            html.push('</ul>');
            inUl = false;
          }
          if (inOl) {
            html.push('</ol>');
            inOl = false;
          }
          if (line.trim()) {
            html.push(line + '<br>');
          } else {
            html.push('<br>');
          }
        }
      }
      
      if (inUl) html.push('</ul>');
      if (inOl) html.push('</ol>');
      
      let result = html.join('')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/__(.+?)__/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/_(.+?)_/g, '<em>$1</em>')
        .replace(/\`(.+?)\`/g, '<code>$1</code>')
        .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank">$1</a>');
      
      result = result
        .replace(/<br><ul>/g, '<ul>')
        .replace(/<br><ol>/g, '<ol>')
        .replace(/<\/ul><br>/g, '</ul>')
        .replace(/<\/ol><br>/g, '</ol>');
      
      return result;
    }

    document.addEventListener('DOMContentLoaded', () => {
      createNoteTooltipViewer();

      // Event delegation on the content area
      document.addEventListener('mouseover', (e) => {
        if (e.target.classList && e.target.classList.contains('editor-note')) {
          const noteContent = e.target.dataset.note;
          if (noteContent && noteTooltip) {
            noteTooltip.innerHTML = parseNoteMarkdown(noteContent);
            noteTooltip.style.display = 'block';
            const rect = e.target.getBoundingClientRect();
            noteTooltip.style.left = `${rect.left + window.scrollX}px`;
            noteTooltip.style.top = `${rect.bottom + window.scrollY + 5}px`;
          }
        }
      });

      document.addEventListener('mouseout', (e) => {
        if (e.target.classList && e.target.classList.contains('editor-note')) {
          if (noteTooltip) {
            setTimeout(() => {
              if (!noteTooltip.matches(':hover')) {
                noteTooltip.style.display = 'none';
              }
            }, 100);
          }
        }
      });

      // Hide tooltip when mouse leaves it
      document.addEventListener('mouseover', (e) => {
        if (e.target === noteTooltip) {
          // Keep it visible
        }
      });

      document.addEventListener('mouseout', (e) => {
        if (e.target === noteTooltip) {
          noteTooltip.style.display = 'none';
        }
      });
    });
  </script>

  <style>
#chat-widget { --chat-primary: #588157; --chat-secondary: #f0ede2; --chat-border: #a3b18a; --chat-text: #000000; --chat-text-light: #000000; }
.chat-widget { position: fixed; bottom: 20px; right: 20px; z-index: 5000; font-family: 'Open Sans', Arial, sans-serif; }
.chat-icon { width: 56px; height: 56px; border-radius: 50%; background: var(--chat-primary); color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3); transition: all 0.3s ease; position: relative; }
.chat-icon:hover { background: #588157; box-shadow: 0 6px 16px #f0ede2; transform: scale(1.1); }
.chat-badge-count { position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3); }
.chat-notification-pulse { position: absolute; top: -6px; right: -6px; width: 16px; height: 16px; background: #22c55e; border-radius: 50%; border: 2px solid white; opacity: 0; transition: opacity 0.3s ease; }
.chat-icon.has-notification .chat-notification-pulse { animation: pulse 0.6s ease-out; }
@keyframes pulse { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(1.5); } }
.chat-panel { position: fixed; bottom: 90px; right: 20px; width: 400px; height: 500px; background: white; border-radius: 12px; box-shadow: 0 5px 40px rgba(0, 0, 0, 0.16); display: flex; flex-direction: column; opacity: 0; pointer-events: none; transform: translateY(20px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
.chat-panel.open { opacity: 1; pointer-events: auto; transform: translateY(0); }
.chat-header { padding: 16px; border-bottom: 1px solid var(--chat-border); display: flex; justify-content: space-between; align-items: flex-start; background: var(--chat-primary); color: white; border-radius: 12px 12px 0 0; }
.chat-header-title h3 { margin: 0 0 4px 0; font-size: 16px; font-weight: 600; }
.chat-online-count { font-size: 12px; opacity: 0.9; display: none; }
.chat-header-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  transition: background 0.2s;
}

.chat-header-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

#chat-members-toggle {
  position: relative;
}

.chat-panel:not(.show-members) #chat-members-toggle::after {
  content: "";
  position: absolute;
  top: 15%;
  left: 50%;
  width: 2px;
  height: 70%;
  background: white;
  transform: translateX(-50%) rotate(-45deg);
  border-radius: 1px;
  box-shadow: 0 0 2px rgba(0,0,0,0.3);
}

.chat-close-btn { background: rgba(255, 255, 255, 0.2); border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 6px; transition: background 0.2s; }
.chat-close-btn:hover { background: rgba(255, 255, 255, 0.3); }
.chat-container { display: flex; flex: 1; min-height: 0; gap: 0; }
.chat-messages-wrapper { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.chat-messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
.chat-message { display: flex; gap: 8px; animation: slideIn 0.3s ease; }
@keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.message-avatar { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px; flex-shrink: 0; }
.message-content { flex: 1; display: flex; flex-direction: column; gap: 2px; }
.message-header { display: flex; gap: 8px; align-items: baseline; }
.message-author { font-weight: 600; font-size: 13px; color: var(--chat-text); }
.message-time { font-size: 11px; color: var(--chat-text-light); }
.message-text { font-size: 13px; color: var(--chat-text); word-break: break-word; background: #f0ede2; padding: 8px 10px; border-radius: 8px; line-height: 1.4; }
.chat-active-users { width: 150px; padding: 12px 8px; border-left: 1px solid var(--chat-border); overflow-y: auto; background: #fafafa; display: none; flex-direction: column; gap: 8px; min-width: 0; }
.chat-panel.show-members .chat-active-users { display: flex; }
.active-users-header { font-size: 11px; font-weight: 600; color: var(--chat-text-light); padding: 0 4px; text-transform: uppercase; }
.active-user { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--chat-text); padding: 4px; border-radius: 6px; cursor: pointer; transition: background 0.2s; min-width: 0; }
.active-user:hover { background: var(--chat-secondary); }
.active-user-badge { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 11px; flex-shrink: 0; }
.active-user span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 11px; }
.chat-input-area { display: flex; gap: 8px; padding: 12px; border-top: 1px solid var(--chat-border); background: #fafafa; }
.chat-input { flex: 1; border: 1px solid var(--chat-border); border-radius: 8px; padding: 8px 12px; font-size: 13px; font-family: inherit; outline: none; transition: all 0.2s; resize: none; }
.chat-input:focus { border-color: var(--chat-primary); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1); }
.chat-send-btn { width: 36px; height: 36px; border: none; background: var(--chat-primary); color: white; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; }
.chat-send-btn:hover { transform: scale(1.05); }
.chat-send-btn:active { transform: scale(0.95); }
.chat-user-info { padding: 8px 12px; font-size: 11px; color: var(--chat-text-light); border-top: 1px solid var(--chat-border); background: #fafafa; border-radius: 0 0 12px 12px; }
#current-user-name { color: var(--chat-primary); font-weight: 600; }
@media (max-width: 600px) { .chat-panel { width: calc(100vw - 40px); height: 65vh; bottom: 100px; right: 20px; left: 20px; max-width: none; } .chat-panel.show-members .chat-active-users { display: flex; position: absolute; right: 0; top: 75px; bottom: 67px; z-index: 10; box-shadow: -2px 0 10px rgba(0,0,0,0.1); } .chat-online-count { display: block; } .chat-active-users { display: none; } .chat-widget { bottom: 10px; right: 10px; } .chat-icon { width: 48px; height: 48px; } }
.chat-messages::-webkit-scrollbar, .chat-active-users::-webkit-scrollbar { width: 6px; }
.chat-messages::-webkit-scrollbar-track, .chat-active-users::-webkit-scrollbar-track { background: transparent; }
.chat-messages::-webkit-scrollbar-thumb, .chat-active-users::-webkit-scrollbar-thumb { background: var(--chat-border); border-radius: 3px; }
.chat-messages::-webkit-scrollbar-thumb:hover, .chat-active-users::-webkit-scrollbar-thumb:hover { background: var(--chat-text-light); }
</style>
<script src="js/version-check.js"></script>
<!-- Hydration Script: Ensures fresh content on reload even if sessionKey is present -->
<script>
  (function() {
    // Only run if courses data is available
    if (typeof courses === 'undefined') return;

    function getParam(name){ const u=new URL(window.location.href); return u.searchParams.get(name); }
    const path = getParam('path');
    if (!path) return;

    const decodedPath = decodeURIComponent(path);
    const normalizedPath = decodedPath.replace(/\\/g, '/');

    // Recursive search function
    function findFileInCourses(fileList) {
      for (const course of fileList) {
        if (course.sections) {
          for (const section of course.sections) {
            const result = searchSection(section);
            if (result) return result;
          }
        }
      }
      return null;
    }

    function searchSection(section) {
      if (section.files) {
        for (const file of section.files) {
          if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
            return file;
          }
        }
      }
      if (section.msgNotes) {
        for (const note of section.msgNotes) {
          if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
            return note;
          }
        }
      }
      if (section.subsections) {
        for (const subsection of section.subsections) {
          const result = searchSection(subsection);
          if (result) return result;
        }
      }
      return null;
    }

    // Attempt to find the file in the fresh courses data
    const fileData = findFileInCourses(courses);

    // If we found the file and it has content (e.g. msgNote), force update the view
    // This overrides whatever might have been loaded from stale sessionStorage
    if (fileData && fileData.content) {
      console.log('Hydrating content from fresh courses data for:', normalizedPath);
      
      const root = document.getElementById('content');
      let html;

      if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(fileData.content, 'text/html');
         // Extract CSS... (simplified for hydration, assuming styles already loaded or we just replace body)
         // For robustness, we re-run the style extraction logic briefly if needed, 
         // but for text notes, usually body innerHTML is enough.
         html = doc.body.innerHTML;
      } else {
         // Re-parse markdown
         html = marked.parse(fileData.content);
         html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
         if (html.includes('^')) html = processTableRowspans(html);
         if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) html = processTableAlignment(html);
         if (html.includes('&lt;')) html = processTableColspans(html);
      }

      root.innerHTML = html;

      // Re-run KaTeX
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(root, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ],
          throwOnError: false
        });
      }

      // Re-wrap tables
      root.querySelectorAll('table').forEach(tbl => {
        if(!tbl.parentElement.classList.contains('table-scroll')){
          const wrap = document.createElement('div');
          wrap.className = 'table-scroll';
          tbl.parentElement.insertBefore(wrap, tbl);
          wrap.appendChild(tbl);
        }
      });
      
      root.querySelectorAll('a').forEach(a => a.target = '_blank');
    }
  })();
</script>
</body>
</html>
