<!DOCTYPE html>
<html lang="bg">
<head>
  <script src="js/auth-guard.js?v=202602021hnm"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Course Viewer</title>
  <!-- Favicon -->
  <link rel="icon" href="favicon.svg?v=7" type="image/svg+xml">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  <!-- Mobile Navigation CSS -->
  <link rel="stylesheet" href="css/mobile-nav.css?v=20260131">
  
  <!-- Firebase SDKs - Moved to head and using compat versions -->
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-database-compat.js"></script>
  
  <style>
    :root {
      --bg: #fafafa;
      --fg: #1f2937;
      --card: #ffffff;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    html { margin: 0; padding: 0; }
    html, body { margin: 0; padding: 0; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      font-size: 1em;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      padding: 10px 16px;
      margin: 0;
      flex-shrink: 0;
      display: flex; align-items: center; gap: 10px;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
    }
    header h1 {
      display: none;
    }
    header a.btn {
      display: inline-flex; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 6px; text-decoration: none;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
      transition: background 0.2s, transform 0.1s;
    }
    header button.btn {
      display: inline-flex; align-items: center; justify-content: center;
      width: 40px; height: 40px; border-radius: 6px;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s, transform 0.1s;
    }
    header a.btn:hover, header button.btn:hover {
      background: #e0e7ff;
      transform: scale(1.05);
    }
    header a.btn:active, header button.btn:active {
      transform: scale(0.95);
    }
    header button.btn:hover {
      background: #e0e7ff;
      color: var(--link-hover);
    }
    header a.btn:nth-child(3) {
      display: none;
    }
    header button#summaryBtn {
      display: none !important;
    }
    header button#summaryBtn.visible {
      display: inline-flex !important;
    }
    header button#editBtn {
      display: none;
    }
    header button#editBtn.visible {
      display: inline-flex !important;
    }
    
    /* Navigation buttons visible on all devices, pushed to the right */
    header button#prevH1Btn {
      margin-left: auto;
    }
    
    header button#nextH1Btn {
      margin-right: 10px;
    }

    header a.btn:hover { background: #e0e7ff; color: var(--link-hover); }
    main { max-width: 1700px; margin: 0 auto; padding: 3px 3px; flex: 1; width: 100%; margin-top: 25px; }
    
    /* Hide edit button on mobile (screens 768px and smaller) */
    @media (max-width: 768px) {
      header button#editBtn,
      header button#editBtn.visible {
        display: none !important;
      }
    }

    /* Headings - match md-editor.html exactly */
    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4 {
      margin-top: 0.5em;
      margin-bottom: 0.15em;
      font-weight: 600;
    }

    .markdown-body h1 { font-size: 1.5em; color: #000000; }
    .markdown-body h2 { font-size: 1.3em; color: #000000; }
    .markdown-body h3 { font-size: 1.1em; color: #000000; margin-bottom: 0.1em; }
    .markdown-body h4 { font-size: 1.05em; color: #000000; margin-bottom: 0.1em; }

    /* Paragraphs - match md-editor.html */
    .markdown-body p {
      margin: 0.3em 0;
      white-space: pre-wrap;
    }

    /* Links */
    .markdown-body a { color: var(--link); text-decoration: underline; text-decoration-skip-ink: none; }
    .markdown-body a:hover { color: var(--link-hover); }
    
    /* Bold text */
    .markdown-body b,
    .markdown-body strong { font-weight: 600; }
    
    /* Italic text */
    .markdown-body em { font-style: italic; }

    /* Lists - CRITICAL: Fix for list formatting */
    .markdown-body ul,
    .markdown-body ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
      list-style-position: outside;
    }

    .markdown-body li {
      margin: 0.2em 0;
      padding: 0;
      display: list-item;
    }

    /* Remove <p> tags inside list items - they should not exist */
    .markdown-body li p {
      margin: 0 !important;
      padding: 0 !important;
      display: inline !important;
    }

    /* Prevent nested list paragraph issues */
    .markdown-body li > ul,
    .markdown-body li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }

    /* Ensure list structure is clean */
    .markdown-body ul ul, .markdown-body ul ol,
    .markdown-body ol ul, .markdown-body ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }

    /* Reduce space between paragraph and following list */
    .markdown-body p + ul,
    .markdown-body p + ol {
      margin-top: -0.5em;
    }

    /* Reduce space between heading and following content */
    .markdown-body h1 + p,
    .markdown-body h2 + p,
    .markdown-body h3 + p,
    .markdown-body h4 + p,
    .markdown-body h1 + ul,
    .markdown-body h2 + ul,
    .markdown-body h3 + ul,
    .markdown-body h4 + ul,
    .markdown-body h1 + ol,
    .markdown-body h2 + ol,
    .markdown-body h3 + ol,
    .markdown-body h4 + ol {
      margin-top: 0.1em;
    }

    /* Reduce space between h3 and h4 */
    .markdown-body h3 + h4 {
      margin-top: 0.3em;
    }

    /* Additional list styles */
    .markdown-body ul,
    .markdown-body ol {
      margin: 0.3em 0;
      padding-left: 1.5em;
    }

    .markdown-body li {
      margin: 0.15em 0;
    }

    .markdown-body ul ul {
      list-style-type: circle;
    }

    .markdown-body ul ul ul {
      list-style-type: square;
    }

    /* Add padding to content so h1 doesn't hide under fixed header */
    #content { padding-top: 20px; }

    /* Tables: make horizontally scrollable on small screens */
    .table-scroll { overflow-x: auto; margin: 0.5em 0; }
    .table-scroll table { min-width: 560px; }

    .markdown-body table { width: 100%; border-collapse: collapse; margin: 0.2em 0; table-layout: auto; }
    .markdown-body th, .markdown-body td { border: 1px solid rgba(146, 64, 14, 0.35); padding: 6px 10px; text-align: left; vertical-align: top; height: 24px; line-height: 1.2; }
    .markdown-body thead th { background: rgba(196, 127, 9, 0.08); font-weight: 600; }
    .markdown-body tbody tr:nth-child(odd) { background: rgba(146, 64, 14, 0.03); }

    pre, code { font-family: Consolas, 'Courier New', monospace; }
    pre { background: var(--bg); padding: 12px; border-radius: 6px; overflow-x: auto; border: 1px solid var(--border); color: var(--fg); }
    code { background: var(--bg); padding: 2px 6px; border-radius: 4px; color: var(--fg); }

    /* Note styles for viewing exported HTML files */
    .markdown-body .editor-note {
      text-decoration: underline dotted #a3b18a;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
      text-decoration-skip-ink: none;
      cursor: help;
      position: relative;
    }

    #noteTooltipViewer {
      position: absolute;
      display: none;
      background-color: #f0f7f0;
      color: #1f2937;
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      max-width: 500px;
      word-wrap: break-word;
      z-index: 10000;
      font-size: 0.9em;
      line-height: 1.4;
      border: 1px solid #588157;
    }
    #noteTooltipViewer ul, #noteTooltipViewer ol {
      margin: 0 !important;
      padding-left: 20px !important;
    }
    #noteTooltipViewer li {
      margin: 0 0 0.1em 0 !important;
      padding: 0 !important;
      line-height: 1.2 !important;
    }
    #noteTooltipViewer li:last-child {
      margin-bottom: 0 !important;
    }

    /* Annotation styles */
    .annotation-highlight {
      background-color: rgba(88, 129, 87, 0.2); /* ~Fern with transparency */
      border-bottom: 2px solid #588157;
      cursor: pointer;
      position: relative;
      transition: background-color 0.2s;
    }
    .annotation-highlight:hover {
      background-color: rgba(88, 129, 87, 0.4);
    }
    .annotation-highlight::after {
      content: '';
      font-size: 10px;
      position: absolute;
      top: -10px;
      right: -5px;
      opacity: 0.6;
    }
    
    .annotation-multi {
      border-bottom-width: 3px !important;
      border-bottom-style: double !important;
    }
    .annotation-multi::after {
      content: '‚Ä¢‚Ä¢' !important; /* Two dots to indicate multiple */
      font-weight: bold;
      color: #588157;
      top: -12px;
    }

    #floating-comment-btn {
      position: absolute;
      z-index: 9999;
      background: #588157;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: none;
      align-items: center;
      gap: 4px;
      pointer-events: auto;
      white-space: nowrap;
    }
    #floating-comment-btn:hover {
      background: #466c43;
    }

    .annotation-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.4);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }
    .annotation-modal.open { display: flex; }
    .annotation-modal-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    .annotation-modal-header {
      font-weight: bold;
      margin-bottom: 12px;
      color: #588157;
      display: flex;
      justify-content: space-between;
    }
    #annotation-text-preview {
      font-size: 12px;
      color: #666;
      font-style: italic;
      margin-bottom: 12px;
      padding: 8px;
      background: #f9f9f9;
      border-radius: 4px;
      border-left: 3px solid #ddd;
      max-height: 60px;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .annotation-modal-input {
      width: 100%;
      height: 100px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 12px;
      font-family: inherit;
      resize: none;
    }
    .annotation-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .annotation-btn-save { background: #588157; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; }
    .annotation-btn-cancel { background: #eee; color: #333; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; }

    @media (max-width: 768px) {
      main { padding: 12px; }
      .markdown-body { font-size: 0.83em; font-weight: 300; }
      .table-scroll table { font-size: 0.83em; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // Configure marked.js to handle custom image width
    marked.use({
      renderer: {
        image(href, title, text) {
          let dataWidth = '';

          if (title) {
            const widthMatch = title.match(/width=(\d+)%/);
            if (widthMatch && widthMatch[1]) {
              style = `max-width:${widthMatch[1]}%; height:auto;`; // min-width removed
              dataWidth = ` data-width="${widthMatch[1]}"`;
            }
          }
          // Remove the custom width from the title so it doesn't show as a tooltip
          const cleanTitle = title ? title.replace(/width=\d+%/g, '').trim() : '';

          // Add data-original-src for consistency if not already an online image
          const dataOriginalSrc = (href.startsWith('http://') || href.startsWith('https://'))
            ? `data-original-src="${href}"`
            : '';

          return `<img src="${href}" alt="${text}" style="${style}"${dataWidth}${dataOriginalSrc}${cleanTitle ? ` title="${cleanTitle}"` : ''}>`;
        }
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
</head>
<body>
  <header>
    <h1 id="docTitle">–ü—Ä–µ–≥–ª–µ–¥ –Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç</h1>
    <a class="btn" href="#" onclick="if (window.opener) { window.close(); } else if (document.referrer) { history.back(); } else { window.close(); } return false;" title="–ù–∞–∑–∞–¥">
      <img src="svg/md-viewer/icon-close.svg" alt="–ù–∞–∑–∞–¥" width="25" height="25">
    </a>
    <button id="summaryBtn" class="btn" title="Summary">
      <img src="svg/md-viewer/icon-summary.svg" alt="Summary" width="20" height="20">
    </button>
    <button id="editBtn" class="btn" title="–†–µ–¥–∞–∫—Ç–∏—Ä–∞–π">
      <img src="svg/md-viewer/icon-edit.svg" alt="–†–µ–¥–∞–∫—Ç–∏—Ä–∞–π" width="20" height="20">
    </button>
    <button id="fontSizeBtn" class="btn" title="Change Font Size">
      <img src="svg/md-viewer/icon-textsize.svg" alt="Change Font Size" width="20" height="20">
    </button>
    <button id="notes-toggle-btn" class="btn" title="–ë–µ–ª–µ–∂–∫–∏">
      <img src="svg/md-viewer/icon-notes.svg" alt="–ë–µ–ª–µ–∂–∫–∏" width="20" height="20">
    </button>
    <button id="prevH1Btn" class="btn" title="–ü—Ä–µ–¥–∏—à–Ω–æ –∑–∞–≥–ª–∞–≤–∏–µ">
      <img src="svg/md-viewer/icon-arrow-left.svg" alt="–ü—Ä–µ–¥–∏—à–Ω–æ" width="20" height="20">
    </button>
    <button id="nextH1Btn" class="btn" title="–°–ª–µ–¥–≤–∞—â–æ –∑–∞–≥–ª–∞–≤–∏–µ">
      <img src="svg/md-viewer/icon-arrow-right.svg" alt="–°–ª–µ–¥–≤–∞—â–æ" width="20" height="20">
    </button>
  </header>
  <main>
    <div id="content" class="markdown-body">–ó–∞—Ä–µ–∂–¥–∞–Ω–µ‚Ä¶</div>
  </main>

  <script>
    // Font size button setup - runs after content div exists
    (function() {
      const SIZES = ['0.8em', '1em', '1.2em', '1.4em'];
      let idx = 1;
      const btn = document.getElementById('fontSizeBtn');
      const content = document.getElementById('content');
      
      if (btn && content) {
        const saved = localStorage.getItem('mdViewerFontSize');
        if (saved) {
          content.style.fontSize = saved;
          const i = SIZES.indexOf(saved);
          if (i !== -1) idx = i;
        }
        
        btn.onclick = () => {
          // If at the top of the page, stay at top
          if (window.scrollY < 100) {
            idx = (idx + 1) % SIZES.length;
            content.style.fontSize = SIZES[idx];
            localStorage.setItem('mdViewerFontSize', SIZES[idx]);
            return;
          }
          
          // Find element currently in viewport to maintain position
          const elements = content.querySelectorAll('h1, h2, h3, p, li, td');
          let targetElement = null;
          let minDistance = Infinity;
          
          const viewportCenter = window.scrollY + window.innerHeight / 3;
          
          elements.forEach(el => {
            const rect = el.getBoundingClientRect();
            const elTop = rect.top + window.scrollY;
            const distance = Math.abs(elTop - viewportCenter);
            
            if (distance < minDistance) {
              minDistance = distance;
              targetElement = el;
            }
          });
          
          // Change font size
          idx = (idx + 1) % SIZES.length;
          content.style.fontSize = SIZES[idx];
          localStorage.setItem('mdViewerFontSize', SIZES[idx]);
          
          // Restore scroll position to target element
          if (targetElement) {
            setTimeout(() => {
              const headerHeight = 100;
              const y = targetElement.getBoundingClientRect().top + window.scrollY - headerHeight;
              window.scrollTo({ top: y, behavior: 'auto' });
            }, 10);
          }
        };
      }
    })();
  </script>

  <button id="floating-comment-btn">üí¨ –ö–æ–º–µ–Ω—Ç–∏—Ä–∞–π</button>

  <div id="annotation-modal" class="annotation-modal">
    <div class="annotation-modal-content">
      <div class="annotation-modal-header">
        <span id="annotation-modal-title">–ë–µ–ª–µ–∂–∫–∏</span>
        <button id="close-annotation-modal" style="background:none;border:none;cursor:pointer;font-size:18px;">‚úï</button>
      </div>
      
      <!-- Text Context Preview -->
      <div id="annotation-text-preview" style="border-bottom: 1px solid #eee; margin-bottom: 10px; padding-bottom: 5px; font-weight: 500; color: #444;"></div>
      
      <!-- List of existing notes -->
      <div id="annotation-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px; display: flex; flex-direction: column; gap: 10px;">
        <!-- Notes will be injected here -->
      </div>

      <!-- Add new note area -->
      <div style="border-top: 1px solid #eee; padding-top: 10px;">
        <textarea id="annotation-input" class="annotation-modal-input" placeholder="–î–æ–±–∞–≤–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä..." style="height: 60px; margin-bottom: 8px;"></textarea>
        <div class="annotation-modal-actions">
          <button id="save-annotation" class="annotation-btn-save" style="width: 100%;">–ò–∑–ø—Ä–∞—Ç–∏</button>
        </div>
        <div style="display:none;">
            <button id="delete-annotation-btn">Hidden Delete</button>
            <button id="cancel-annotation">Hidden Cancel</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Function to process table rowspans (convert ^ to rowspan)
    function processTableRowspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each column
        const maxCols = Math.max(...rows.map(row => row.cells.length));
        
        for (let colIndex = 0; colIndex < maxCols; colIndex++) {
          let spanStart = -1;
          let spanCount = 0;
          
          for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            const cell = rows[rowIndex].cells[colIndex];
            
            if (!cell) continue;
            
            const cellText = cell.textContent.trim();
            
            if (cellText === '^') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply rowspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = rows[spanStart].cells[colIndex];
                if (spanCell) {
                  spanCell.setAttribute('rowspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = rowIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = rows[spanStart].cells[colIndex];
            if (spanCell) {
              spanCell.setAttribute('rowspan', spanCount + 1);
            }
          }
        }
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table colspans (convert < to colspan)
    function processTableColspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each row
        rows.forEach(row => {
          const cells = Array.from(row.cells);
          let spanStart = -1;
          let spanCount = 0;
          
          for (let colIndex = 0; colIndex < cells.length; colIndex++) {
            const cell = cells[colIndex];
            const cellText = cell.innerHTML.trim();
            
            if (cellText === '&lt;') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete-colspan', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply colspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = cells[spanStart];
                if (spanCell) {
                  spanCell.setAttribute('colspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = colIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = cells[spanStart];
            if (spanCell) {
              spanCell.setAttribute('colspan', spanCount + 1);
            }
          }
        });
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete-colspan="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table cell alignment (>>text<<, <<text, text>>)
    function processTableAlignment(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const allCells = table.querySelectorAll('td, th');
        
        allCells.forEach(cell => {
          let content = cell.innerHTML.trim();
          
          // Check for center alignment >>text<<
          if (content.startsWith('&gt;&gt;') && content.endsWith('&lt;&lt;')) {
            cell.style.textAlign = 'center';
            cell.innerHTML = content.slice(8, -8); // Remove &gt;&gt; and &lt;&lt;
          }
          // Check for left alignment <<text
          else if (content.startsWith('&lt;&lt;')) {
            cell.style.textAlign = 'left';
            cell.innerHTML = content.slice(8); // Remove &lt;&lt;
          }
          // Check for right alignment text>>
          else if (content.endsWith('&gt;&gt;')) {
            cell.style.textAlign = 'right';
            cell.innerHTML = content.slice(0, -8); // Remove &gt;&gt;
          }
        });
      });
      
      return doc.body.innerHTML;
    }

    // Function to load summary file
    function loadSummary(summaryPath) {
      console.log('loadSummary function called with:', summaryPath);
      const decodedPath = decodeURIComponent(summaryPath);
      const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
      const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
        ? new URL(encodedPath, window.location.origin).href
        : encodedPath;
      
      console.log('Fetching from:', absoluteUrl);

      fetch(absoluteUrl).then(r=>{ 
        if(!r.ok) throw new Error('HTTP '+r.status); 
        return r.text(); 
      })
        .then(content => {
          let html;
          
          if (/\.html$/i.test(decodedPath)) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract CSS from <style> tags
            const styles = doc.head.querySelectorAll('style');
            let cssContent = '';
            styles.forEach(style => {
              cssContent += style.textContent;
            });
            
            // Add !important to override md-viewer styles
            if (cssContent) {
              const existingStyles = document.querySelectorAll('style');
              let styleExists = false;
              existingStyles.forEach(s => {
                if (s.textContent.includes('/* Imported from file */')) {
                  styleExists = true;
                  s.remove();
                }
              });
              
              cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
              cssContent = '/* Imported from file */\n' + cssContent;
              const styleTag = document.createElement('style');
              styleTag.textContent = cssContent;
              document.head.appendChild(styleTag);
            }
            
            html = doc.body.innerHTML;
          } else {
            html = marked.parse(content);
          }
          
          const root = document.getElementById('content');
          root.innerHTML = html;
          
          // Render LaTeX
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
          
          root.querySelectorAll('a').forEach(a => a.target = '_blank');
        })
        .catch(err => {
          console.error('Error loading summary:', err);
        });
    }

    (function(){
      function getParam(name){ const u=new URL(window.location.href); return u.searchParams.get(name); }
      const path = getParam('path');
      const loadFromHash = getParam('loadFromHash') === 'true';
      if(!path){ document.getElementById('content').textContent = '–õ–∏–ø—Å–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä path.'; return; }
      const decodedPath = decodeURIComponent(path);
      const title = decodedPath.split('/').pop()
        .replace(/^\d+-msg-/, '') // Remove "NUMBER-msg-" prefix
        .replace(/\.(html|md|txt)$/i, ''); // Remove extension
      document.title = title;
      document.getElementById('docTitle').textContent = title;
      const dl = document.getElementById('downloadLink');
      dl.href = decodedPath;

      // Check if content is passed via sessionKey (sessionStorage)
      const sessionKey = getParam('sessionKey');
      let contentPromise;
      
      if (sessionKey && window.sessionStorage) {
        // Content passed via sessionStorage - use it directly (no fetch needed)
        const htmlContent = sessionStorage.getItem(sessionKey);
        if (htmlContent) {
          contentPromise = Promise.resolve(htmlContent);
        } else {
          // Fallback to fetch if sessionStorage is empty
          const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
          const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
            ? new URL(encodedPath, window.location.origin).href
            : encodedPath;
          contentPromise = fetch(absoluteUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
        }
      } else if (loadFromHash && window.location.hash) {
        // If content is passed in hash, use it directly (no fetch needed)
        try {
          const htmlContent = decodeURIComponent(window.location.hash.substring(1));
          const root = document.getElementById('content');
          root.innerHTML = htmlContent;
          
          // Render LaTeX with auto-render
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
        } catch (err) {
          document.getElementById('content').textContent = '–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ: ' + err.message;
        }
        return;
      } else {
        // Fetch from URL
        const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
        const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
          ? new URL(encodedPath, window.location.origin).href
          : encodedPath;
        
        // Add cache buster to ensure fresh content
        const fetchUrl = absoluteUrl + (absoluteUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
        contentPromise = fetch(fetchUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
      }

      contentPromise.then(content => {
          let html;
          
          // If it's an HTML file, extract body content directly
          if (/\.html$/i.test(decodedPath)) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract CSS from <style> tags in <head>
            const styles = doc.head.querySelectorAll('style');
            let cssContent = '';
            styles.forEach(style => {
              cssContent += style.textContent;
            });
            
            // Inject CSS into current document if found
            if (cssContent) {
              const styleTag = document.createElement('style');
              // Add !important to all rules to override md-viewer styles but preserve font-size
              cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
              styleTag.textContent = cssContent;
              document.head.appendChild(styleTag);
            }
            
            html = doc.body.innerHTML;
          } else {
            // Otherwise parse as Markdown
            html = marked.parse(content);
            
            // Convert ~~~ paragraphs to dashed <hr>
            html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
            
            // Process tables to support rowspan with ^ syntax (only if needed)
            if (html.includes('^')) {
              html = processTableRowspans(html);
            }
            
            // Process tables to support cell alignment with >>text<<, <<text, text>> (BEFORE colspan!)
            if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) {
              html = processTableAlignment(html);
            }
            
            // Process tables to support colspan with < syntax (only if needed)
            if (html.includes('&lt;')) {
              html = processTableColspans(html);
            }
          }
          
          const root = document.getElementById('content');
          root.innerHTML = html;
          
          // Images now use relative paths like "assets/image.png" which resolve correctly
          // from md-viewer.html location since all assets are in the central assets/ folder
          // No path fixing needed!
          
          // Render LaTeX with auto-render - simple and direct
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
          
          // Make all links open in new tab
          root.querySelectorAll('a').forEach(a => a.target = '_blank');
          
          // Setup summary toggle button
          const summaryBtn = document.getElementById('summaryBtn');
          if (!summaryBtn) {
            console.error('Summary button not found!');
          } else {
            // Summary button handler is set up outside IIFE
          }
        })
        .catch(err => {
          console.warn('Initial fetch failed, attempting to recover from courses data:', err);
          
          const contentDiv = document.getElementById('content');
          // Don't show error yet, keep "–ó–∞—Ä–µ–∂–¥–∞–Ω–µ..." or show a softer message if needed
          // contentDiv.textContent = '–ó–∞—Ä–µ–∂–¥–∞–Ω–µ –æ—Ç –ª–æ–∫–∞–ª–Ω–∏ –¥–∞–Ω–Ω–∏...'; 

          // Polling mechanism to wait for courses.generated.js
          let attempts = 0;
          const maxAttempts = 50; // 5 seconds (50 * 100ms)
          
          const pollCourses = setInterval(() => {
            attempts++;
            
            if (typeof courses !== 'undefined') {
              clearInterval(pollCourses);
              recoverContentFromCourses();
            } else if (attempts >= maxAttempts) {
              clearInterval(pollCourses);
              showError(err);
            }
          }, 100);

          function recoverContentFromCourses() {
            const path = getParam('path');
            if (!path) { showError(err); return; }
            
            const decodedPath = decodeURIComponent(path);
            const normalizedPath = decodedPath.replace(/\\/g, '/');
            
            // Search logic (duplicated for resilience inside this closure)
            let fileData = null;
            
            // Helper to search sections
            const searchSection = (section) => {
              if (section.files) {
                for (const file of section.files) {
                  if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) return file;
                }
              }
              if (section.msgNotes) {
                for (const note of section.msgNotes) {
                  if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) return note;
                }
              }
              if (section.subsections) {
                for (const subsection of section.subsections) {
                  const result = searchSection(subsection);
                  if (result) return result;
                }
              }
              return null;
            };

            for (const course of courses) {
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) {
                    fileData = result;
                    break;
                  }
                }
              }
              if (fileData) break;
            }

            if (fileData && fileData.content) {
              console.log('Successfully recovered content from courses data');
              // Render content
              let html;
              if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
                 const parser = new DOMParser();
                 const doc = parser.parseFromString(fileData.content, 'text/html');
                 const styles = doc.head.querySelectorAll('style');
                 let cssContent = '';
                 styles.forEach(style => { cssContent += style.textContent; });
                 if (cssContent) {
                    const styleTag = document.createElement('style');
                    cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
                    styleTag.textContent = cssContent;
                    document.head.appendChild(styleTag);
                 }
                 html = doc.body.innerHTML;
              } else {
                 html = marked.parse(fileData.content);
                 html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
                 if (html.includes('^')) html = processTableRowspans(html);
                 if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) html = processTableAlignment(html);
                 if (html.includes('&lt;')) html = processTableColspans(html);
              }
              
              contentDiv.innerHTML = html;
              
              if (typeof renderMathInElement !== 'undefined') {
                try { renderMathInElement(contentDiv, { delimiters: [{left: '$', right: '$', display: true}, {left: '
    })();
    
    // Setup summary button - outside IIFE so it always works
    const summaryBtn = document.getElementById('summaryBtn');
  //  console.log('Summary button setup starting, button exists:', !!summaryBtn);
    
    let originalPath = null;
    let isSummaryMode = false;
    let summaryPath = null;
    let buttonSetupDone = false;
    
    // Setup button when page loads
    const setupButton = () => {
      if (buttonSetupDone) {
     //   console.log('Button already setup, skipping');
        return;
      }
      buttonSetupDone = true;
      if (!originalPath) {
        const urlParams = new URLSearchParams(window.location.search);
        const pathParam = urlParams.get('path');
        if (pathParam) {
          originalPath = decodeURIComponent(pathParam);
        }
      }
      
      if (!originalPath || !summaryBtn || typeof courses === 'undefined') {
        console.log('Cannot setup button:', { originalPath, summaryBtn: !!summaryBtn, courses: typeof courses });
        return;
      }
      
      summaryPath = originalPath.replace(/(-msg-)(.*)(\.(html|md|txt))$/i, '$1summary-$2$3');
      console.log('Summary path:', summaryPath);
      
      // Check if summary file exists in courses
      let summaryFileExists = false;
      const normalizedPath = summaryPath.replace(/\\/g, '/');
      
      outerLoop: for (const course of courses) {
        function searchSection(section) {
          if (section.files) {
            for (const file of section.files) {
              if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                return true;
              }
            }
          }
          if (section.msgNotes) {
            for (const note of section.msgNotes) {
              if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                return true;
              }
            }
          }
          if (section.subsections) {
            for (const subsection of section.subsections) {
              if (searchSection(subsection)) return true;
            }
          }
          return false;
        }
        
        if (course.sections) {
          for (const section of course.sections) {
            if (searchSection(section)) {
              summaryFileExists = true;
              break outerLoop;
            }
          }
        }
      }
      
      console.log('Summary file exists:', summaryFileExists);
      if (summaryFileExists) {
        summaryBtn.classList.add('visible');
      } else {
        summaryBtn.classList.remove('visible');
      }
      
      // Setup click handler
      summaryBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (originalPath) {
          isSummaryMode = !isSummaryMode;
          const pathToLoad = isSummaryMode ? summaryPath : originalPath;
          console.log('Loading:', pathToLoad);
          
          // Find and display content
          function findFileContent(filePath) {
            const normalizedPath = filePath.replace(/\\/g, '/');
            
            for (const course of courses) {
              function searchSection(section) {
                if (section.files) {
                  for (const file of section.files) {
                    if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                      return file;
                    }
                  }
                }
                if (section.msgNotes) {
                  for (const note of section.msgNotes) {
                    if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                      return note;
                    }
                  }
                }
                if (section.subsections) {
                  for (const subsection of section.subsections) {
                    const result = searchSection(subsection);
                    if (result) return result;
                  }
                }
                return null;
              }
              
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) return result;
                }
              }
            }
            return null;
          }
          
          const fileData = findFileContent(pathToLoad);
          if (fileData && fileData.content) {
            const root = document.getElementById('content');
            
            if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(fileData.content, 'text/html');
              
              const styles = doc.head.querySelectorAll('style');
              const existingStyles = document.querySelectorAll('style');
              existingStyles.forEach(s => {
                if (s.textContent.includes('/* Imported from file */')) {
                  s.remove();
                }
              });
              
              let cssContent = '';
              styles.forEach(style => {
                cssContent += style.textContent;
              });
              
              if (cssContent) {
                cssContent = cssContent.split('}').filter(rule => rule.trim()).map(rule => {
                  const selector = rule.split('{')[0].trim();
                  const styles = rule.split('{')[1] || '';
                  
                  // Skip only body, html, and :root selectors - include h1 and other tags
                  if (!selector || selector.match(/^(body|html|:root)$/i)) {
                    return rule + '}';
                  }
                  
                  // Scope to #content for everything else including h1
                  return `#content ${selector} { ${styles} }`;
                }).join('');
                
                cssContent = cssContent.replace(/;(?!important)/g, ' !important;');
                cssContent = '/* Imported from file */\n' + cssContent;
                const styleTag = document.createElement('style');
                styleTag.textContent = cssContent;
                document.head.appendChild(styleTag);
              }
              
              root.innerHTML = doc.body.innerHTML;
            } else {
              root.innerHTML = fileData.content;
            }
            
            window.scrollTo(0, 0);
          }
        }
      });
    };
    
    // Call setup when DOM is ready and courses is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupButton);
    } else {
      setupButton();
    }
    
    // Also try to setup after a short delay to ensure courses is loaded
    setTimeout(setupButton, 100);
    
    // Edit button handler
    let currentEditPath = null;
    let currentEditContent = null;
    
    function setupEditButton() {
      const editBtn = document.getElementById('editBtn');
      if (!editBtn) return;
      
      // Get the current file path from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const filePath = urlParams.get('path');
      
      if (filePath) {
        currentEditPath = filePath;
        // Make button visible on desktop/tablet
        if (window.innerWidth > 768) {
          editBtn.classList.add('visible');
        }
        
        editBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          // Find file content from courses data
          const normalizedPath = filePath.replace(/\\/g, '/');
          let fileData = null;
          
          function searchSection(section) {
            if (section.files) {
              for (const file of section.files) {
                if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
                  return file;
                }
              }
            }
            if (section.msgNotes) {
              for (const note of section.msgNotes) {
                if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
                  return note;
                }
              }
            }
            if (section.subsections) {
              for (const subsection of section.subsections) {
                const result = searchSection(subsection);
                if (result) return result;
              }
            }
            return null;
          }
          
          // Search through courses
          if (typeof courses !== 'undefined') {
            for (const course of courses) {
              if (course.sections) {
                for (const section of course.sections) {
                  const result = searchSection(section);
                  if (result) {
                    fileData = result;
                    break;
                  }
                }
              }
              if (fileData) break;
            }
          }
          
          if (fileData && fileData.content) {
            // Store content in sessionStorage to avoid URL length limits
            sessionStorage.setItem('editFileContent', fileData.content);
            sessionStorage.setItem('editFilePath', filePath);
            
            // Navigate to md-editor
            window.location.href = `text-editor.html?editMode=true`;
          } else {
            alert('–ù–µ –±–µ—à–µ –Ω–∞–º–µ—Ä–µ–Ω–æ —Å–æ–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ —Ñ–∞–π–ª–∞. –§–∞–π–ª—ä—Ç –º–æ–∂–µ –¥–∞ –Ω–µ –µ –≤–∫–ª—é—á–µ–Ω –≤ courses.generated.js');
          }
        });
      }
    }
    
    // Setup edit button when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupEditButton);
    } else {
      setupEditButton();
    }
    
    // Also try to setup after a short delay
    setTimeout(setupEditButton, 100);
  </script>
  
  <!-- Load courses data for summary file detection -->
  <script src="courses.generated.js?v=202602021hnm"></script>

  <!-- ============================================
       CHAT SYSTEM - Firebase & Notes
       ============================================ -->


  
<script src="js/user-identity.js?v=20260125"></script>
    <!-- CHAT SYSTEM -->
    <script src="js/chat.js?v=202602021hnm"></script>
  <script src="js/presence.js?v=20260125"></script>
  <script src="js/notes-init.js?v=20260131"></script>

  <!-- H1 Navigation with Arrow Keys -->
  <script>
    (function() {
      let h1Elements = [];
      let currentH1Index = -1;
      
      // Function to update h1 elements list
      function updateH1List() {
        h1Elements = Array.from(document.querySelectorAll('#content h1'));
      }
      
      // Function to scroll to h1 element
      function scrollToH1(index) {
        if (index >= 0 && index < h1Elements.length) {
          const h1 = h1Elements[index];
          const headerHeight = document.querySelector('header').offsetHeight || 0;
          const yOffset = -headerHeight - 20; // Add some extra padding
          const y = h1.getBoundingClientRect().top + window.pageYOffset + yOffset;
          
          window.scrollTo({ top: y, behavior: 'auto' });
          currentH1Index = index;
          
          // Visual feedback - briefly highlight the h1
          h1.style.transition = 'background-color 0.3s ease';
          const originalBg = h1.style.backgroundColor;
          h1.style.backgroundColor = 'rgba(124, 58, 237, 0.1)';
          setTimeout(() => {
            h1.style.backgroundColor = originalBg;
          }, 600);
        }
      }
      
      // Function to find current h1 based on scroll position
      function findCurrentH1() {
        const scrollPosition = window.scrollY + 100; // Offset for header
        
        for (let i = h1Elements.length - 1; i >= 0; i--) {
          if (h1Elements[i].offsetTop <= scrollPosition) {
            return i;
          }
        }
        return 0;
      }
      
      // Button Handlers for Mobile
      const prevH1Btn = document.getElementById('prevH1Btn');
      const nextH1Btn = document.getElementById('nextH1Btn');

      if (prevH1Btn) {
        prevH1Btn.addEventListener('click', (e) => {
          e.preventDefault();
          // Update list if needed (in case content changed)
          if (h1Elements.length === 0) {
            updateH1List();
          }
          if (h1Elements.length === 0) return;

          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const prevIndex = (currentH1Index - 1 + h1Elements.length) % h1Elements.length;
          scrollToH1(prevIndex);
        });
      }

      if (nextH1Btn) {
        nextH1Btn.addEventListener('click', (e) => {
          e.preventDefault();
          // Update list if needed (in case content changed)
          if (h1Elements.length === 0) {
            updateH1List();
          }
          if (h1Elements.length === 0) return;

          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const nextIndex = (currentH1Index + 1) % h1Elements.length;
          scrollToH1(nextIndex);
        });
      }

      // Listen for arrow key presses
      document.addEventListener('keydown', (e) => {
        // Ignore if user is typing in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }
        
        // Update list if needed (in case content changed)
        if (h1Elements.length === 0) {
          updateH1List();
        }
        
        if (h1Elements.length === 0) return;
        
        // Right Arrow - next h1
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const nextIndex = (currentH1Index + 1) % h1Elements.length;
          scrollToH1(nextIndex);
        }
        
        // Left Arrow - previous h1
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          if (currentH1Index === -1) {
            currentH1Index = findCurrentH1();
          }
          const prevIndex = (currentH1Index - 1 + h1Elements.length) % h1Elements.length;
          scrollToH1(prevIndex);
        }
      });
      
      // Initialize h1 list when content loads
      function initH1Navigation() {
        setTimeout(() => {
          updateH1List();
        }, 500);
      }
      
      // Watch for content changes
      const contentDiv = document.getElementById('content');
      if (contentDiv) {
        const observer = new MutationObserver(() => {
          updateH1List();
        });
        
        observer.observe(contentDiv, {
          childList: true,
          subtree: true
        });
      }
      
      // Initialize on page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initH1Navigation);
      } else {
        initH1Navigation();
      }
    })();
  </script>

  <!-- Notes Widget HTML -->
  <!-- <div id="notes-widget" class="notes-widget">
    <div class="notes-panel">
      <div class="notes-header">
        <div class="notes-header-title">
          <div style="font-size: 18px; font-weight: bold; margin: 0;">–ë–µ–ª–µ–∂–∫–∏</div>
        </div>
        <button class="notes-close-btn" id="notes-close" title="–ó–∞—Ç–≤–æ—Ä–∏ –±–µ–ª–µ–∂–∫–∏">‚úï</button>
      </div>

      <div class="notes-container">
        <div class="notes-list" style="flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px;"></div>
      </div>

      <div class="notes-input-area">
        <textarea class="notes-input" placeholder="–ù–∞–ø–∏—à–∏ –±–µ–ª–µ–∂–∫–∞..." style="max-height: 80px; resize: vertical;"></textarea>
        <button class="notes-send-btn" title="–î–æ–±–∞–≤–∏ –±–µ–ª–µ–∂–∫–∞">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
            <path d="M16.6915026,12.4744748 L3.50612381,13.2599618 C3.19218622,13.2599618 3.03521743,13.4170592 3.03521743,13.5741566 L1.15159189,20.0151496 C0.8376543,20.8006365 0.99,21.89 1.77946707,22.52 C2.41,22.99 3.50612381,23.1 4.13399899,22.8429026 L21.714504,14.0454487 C22.6563168,13.5741566 23.1272231,12.6315722 22.9702544,11.6889879 L4.13399899,1.16151496 C3.34915502,0.9 2.40734225,0.9 1.77946707,1.4429026 C0.994623095,2.08 0.837654326,3.0226 1.15159189,3.97788954 L3.03521743,10.4188814 C3.03521743,10.5759788 3.34915502,10.7330762 3.50612381,10.7330762 L16.6915026,11.5185631 C16.6915026,11.5185631 17.1624089,11.5185631 17.1624089,12.0598639 C17.1624089,12.4744748 16.6915026,12.4744748 16.6915026,12.4744748 Z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div> -->

  <style>
    /* Notes Widget Styles */
    #notes-widget { --notes-primary: #588157; --notes-secondary: #efebe9; --notes-border: #588157; --notes-text: #2c1810; --notes-text-light: #6d4c41; }
    .notes-widget { position: fixed; bottom: 20px; left: 20px; z-index: 4999; font-family: 'Open Sans', Arial, sans-serif; }
    .notes-panel { position: fixed; bottom: 90px; left: 20px; width: 400px; height: 500px; background: white; border-radius: 12px; box-shadow: 0 5px 40px rgba(0, 0, 0, 0.16); display: flex; flex-direction: column; opacity: 0; pointer-events: none; transform: translateY(20px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .notes-header { padding: 16px; border-bottom: 1px solid var(--notes-border); display: flex; justify-content: space-between; align-items: flex-start; background: linear-gradient(135deg, #588157 0%, #588157 100%); color: white; border-radius: 12px 12px 0 0; }
    .notes-header-title h3 { margin: 0 0 4px 0; font-size: 16px; font-weight: 600; }
    .notes-close-btn { background: rgba(255, 255, 255, 0.15); border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 6px; transition: background 0.2s; }
    .notes-close-btn:hover { background: rgba(255, 255, 255, 0.25); }
    .notes-container { display: flex; flex: 1; min-height: 0; overflow: hidden; }
    .notes-list { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
    .notes-input-area { display: flex; gap: 8px; padding: 12px; border-top: 1px solid color#588157; background: #fafafa; flex-direction: column; border-radius: 0 0 12px 12px; }
    .notes-input { flex: 1; border: 1px solid color #588157; border-radius: 8px; padding: 8px 12px; font-size: 13px; font-family: inherit; outline: none; transition: all 0.2s; resize: vertical; max-height: 80px; min-height: 40px; }
    .notes-input:focus { border-color: #588157; box-shadow: 0 0 0 3px rgba(88, 129, 87, 0.1); }
    .notes-send-btn { width: 36px; height: 36px; border: none; background: #588157; color: white; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; align-self: flex-end; }
    .notes-send-btn:hover { background: #588157; transform: scale(1.05); }
    .notes-send-btn:active { transform: scale(0.95); }
    
    /* Note item styles */
    .note-item { animation: slideIn 0.3s ease; }
    .note-reply { animation: slideIn 0.3s ease; }
    
    @media (max-width: 900px) { 
      .notes-widget, .notes-panel { bottom: 20px; left: 20px; } 
      .notes-panel { width: calc(100vw - 40px); max-width: 400px; bottom: 90px; left: 20px; right: auto; }
    }
    .notes-list::-webkit-scrollbar { width: 6px; }
    .notes-list::-webkit-scrollbar-track { background: transparent; }
    .notes-list::-webkit-scrollbar-thumb { background: var(--notes-border); border-radius: 3px; }
  </style>
<script src="js/version-check.js"></script>
<!-- Hydration Script: Ensures fresh content on reload even if sessionKey is present -->
<script>
  (function() {
    // Only run if courses data is available
    if (typeof courses === 'undefined') return;

    function getParam(name){ const u=new URL(window.location.href); return u.searchParams.get(name); }
    const path = getParam('path');
    if (!path) return;

    const decodedPath = decodeURIComponent(path);
    const normalizedPath = decodedPath.replace(/\\/g, '/');

    // Recursive search function
    function findFileInCourses(fileList) {
      for (const course of fileList) {
        if (course.sections) {
          for (const section of course.sections) {
            const result = searchSection(section);
            if (result) return result;
          }
        }
      }
      return null;
    }

    function searchSection(section) {
      if (section.files) {
        for (const file of section.files) {
          if (file.path === normalizedPath || file.path.replace(/\\/g, '/') === normalizedPath) {
            return file;
          }
        }
      }
      if (section.msgNotes) {
        for (const note of section.msgNotes) {
          if (note.path === normalizedPath || note.path.replace(/\\/g, '/') === normalizedPath) {
            return note;
          }
        }
      }
      if (section.subsections) {
        for (const subsection of section.subsections) {
          const result = searchSection(subsection);
          if (result) return result;
        }
      }
      return null;
    }

    // Attempt to find the file in the fresh courses data
    const fileData = findFileInCourses(courses);

    // If we found the file and it has content (e.g. msgNote), force update the view
    // This overrides whatever might have been loaded from stale sessionStorage
    if (fileData && fileData.content) {
      console.log('Hydrating content from fresh courses data for:', normalizedPath);
      
      const root = document.getElementById('content');
      let html;

      if (fileData.type === 'html' || fileData.content.includes('<!DOCTYPE')) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(fileData.content, 'text/html');
         // Extract CSS... (simplified for hydration, assuming styles already loaded or we just replace body)
         // For robustness, we re-run the style extraction logic briefly if needed, 
         // but for text notes, usually body innerHTML is enough.
         html = doc.body.innerHTML;
      } else {
         // Re-parse markdown
         html = marked.parse(fileData.content);
         html = html.replace(/<p>~~~<\/p>/g, '<hr style="border: none; border-top: 2px dashed #8B6F47;">');
         if (html.includes('^')) html = processTableRowspans(html);
         if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) html = processTableAlignment(html);
         if (html.includes('&lt;')) html = processTableColspans(html);
      }

      root.innerHTML = html;

      // Re-run KaTeX
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(root, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ],
          throwOnError: false
        });
      }

      // Re-wrap tables
      root.querySelectorAll('table').forEach(tbl => {
        if(!tbl.parentElement.classList.contains('table-scroll')){
          const wrap = document.createElement('div');
          wrap.className = 'table-scroll';
          tbl.parentElement.insertBefore(wrap, tbl);
          wrap.appendChild(tbl);
        }
      });
      
      root.querySelectorAll('a').forEach(a => a.target = '_blank');
    }
  })();

  // ============================================
  // ANNOTATION SYSTEM LOGIC
  // ============================================
  (function() {
    let currentSelection = null;
    let docId = '';

    function getDocumentId() {
      const urlParams = new URLSearchParams(window.location.search);
      const pathParam = urlParams.get('path');
      if (pathParam) {
        let path = decodeURIComponent(pathParam);
        path = path.replace(/^files\//, '').replace(/\[–ê–†–•–ò–í\]\s*/g, '').replace(/\[ARCHIVE\]\s*/g, '');
        return 'doc_' + path.replace(/[.#$[\]/]/g, '_');
      }
      return 'doc_general';
    }

    const floatingBtn = document.getElementById('floating-comment-btn');
    const modal = document.getElementById('annotation-modal');
    const modalTitle = document.getElementById('annotation-modal-title');
    const annotationList = document.getElementById('annotation-list');
    const input = document.getElementById('annotation-input');
    const preview = document.getElementById('annotation-text-preview');
    const saveBtn = document.getElementById('save-annotation');
    const cancelBtn = document.getElementById('cancel-annotation');
    const closeBtn = document.getElementById('close-annotation-modal');
    const deleteBtn = document.getElementById('delete-annotation-btn');

    let isEditing = false;
    let currentAnnotationKey = null;

    // Show floating button on selection (mouseup is more reliable for completion)
    const handleSelection = () => {
      const selection = window.getSelection();
      const content = document.getElementById('content');
      
      console.log('Selection event fired:', selection.toString());

      if (selection.rangeCount > 0 && selection.toString().trim().length > 0 && content.contains(selection.anchorNode)) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        
        currentSelection = {
          text: selection.toString(),
          range: range.cloneRange(),
          containerText: range.startContainer.parentElement.innerText,
          offset: range.startOffset
        };

        // Calculate position relative to the document
        const scrollX = window.scrollX || window.pageXOffset;
        const scrollY = window.scrollY || window.pageYOffset;
        const viewportWidth = window.innerWidth;
        const btnWidth = floatingBtn.offsetWidth || 120; // fallback width if hidden

        let left = rect.left + scrollX + (rect.width / 2) - (btnWidth / 2);
        
        // Constrain to viewport edges
        if (left < 10) left = 10;
        if (left + btnWidth > document.documentElement.clientWidth - 10) {
            left = document.documentElement.clientWidth - btnWidth - 10;
        }

        console.log('Displaying button at:', left, rect.top + scrollY);

        floatingBtn.style.display = 'flex';
        floatingBtn.style.left = `${left}px`;
        // Position above the selection
        floatingBtn.style.top = `${rect.top + scrollY - 40}px`; 
      } else {
        // Hide only if we are clicking outside and not on the button itself
        // setTimeout to allow button click to register
        setTimeout(() => {
           if (!modal.classList.contains('open')) {
             floatingBtn.style.display = 'none';
           }
        }, 200);
      }
    };

    document.getElementById('content').addEventListener('mouseup', handleSelection);
    document.addEventListener('selectionchange', () => {
        // Optional: Hide on deselection immediately
        const selection = window.getSelection();
        if (!selection.toString().trim()) {
             if (!modal.classList.contains('open')) {
                floatingBtn.style.display = 'none';
             }
        }
    });

    floatingBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      openModal(currentSelection.text, currentSelection.containerText, []);
      floatingBtn.style.display = 'none';
    });

    const openModal = (text, context, existingNotes = []) => {
      currentGroupContext = { text, context }; // Store context for new notes
      preview.textContent = `"${text}"`;
      input.value = '';
      
      // Render list
      renderNotesList(existingNotes);
      
      modal.classList.add('open');
      setTimeout(() => input.focus(), 100);
    };

    const timeAgo = (timestamp) => {
        const seconds = Math.floor((new Date() - timestamp) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " –≥.";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " –º–µ—Å.";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " –¥.";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " —á.";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " –º–∏–Ω.";
        return "—Ç–æ–∫—É-—â–æ";
    };

    const renderNotesList = (notes) => {
      annotationList.innerHTML = '';
      const user = JSON.parse(localStorage.getItem('loggedInUser'));

      notes.forEach(note => {
        const div = document.createElement('div');
        const authorColor = note.authorColor || '#ccc';
        div.style.cssText = "background: #f9f9f9; padding: 12px; border-radius: 8px; margin-bottom: 8px; border: 1px solid #eee; border-left: 4px solid " + authorColor;
        
        const isAuthor = user && (user.username === note.author || user.displayName === note.author);
        
        // Use saved avatar, or fallback to current user's avatar if they are the author
        let avatarSrc = note.authorAvatar;
        if (!avatarSrc && isAuthor && user.avatar) {
            avatarSrc = user.avatar;
        }

        let avatarHtml = '';
        if (avatarSrc) {
            avatarHtml = `<img src="${avatarSrc}" style="width:24px; height:24px; border-radius:50%; object-fit:cover; margin-right:8px; border:1px solid #ddd;">`;
        } else {
            // Fallback to colored circle with initial
            const initial = (note.author || "?")[0].toUpperCase();
            avatarHtml = `<div style="width:24px; height:24px; background:${authorColor}; color:white; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; margin-right:8px; flex-shrink:0;">${initial}</div>`;
        }

        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
            <div style="display:flex; align-items:center;">
                ${avatarHtml}
                <strong style="font-size:13px; color:#333;">${note.author}</strong>
            </div>
            <span style="font-size:11px; color:#888;">${timeAgo(note.timestamp)}</span>
          </div>
          <div style="font-size:14px; white-space: pre-wrap; color:#444;">${note.comment}</div>
          ${isAuthor ? `
            <div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;">
               <button class="small-btn-edit" style="font-size:11px; cursor:pointer; color:#2563eb; background:#eff6ff; border:1px solid #bfdbfe; padding:2px 8px; border-radius:4px; transition:all 0.2s;">‚úé –†–µ–¥–∞–∫—Ç–∏—Ä–∞–π</button>
               <button class="small-btn-delete" style="font-size:11px; cursor:pointer; color:#dc2626; background:#fef2f2; border:1px solid #fecaca; padding:2px 8px; border-radius:4px; transition:all 0.2s;">‚úï –ò–∑—Ç—Ä–∏–π</button>
            </div>
          ` : ''}
        `;

        if (isAuthor) {
            const editBtn = div.querySelector('.small-btn-edit');
            const delBtn = div.querySelector('.small-btn-delete');
            
            // Hover effects
            editBtn.onmouseenter = () => { editBtn.style.background = '#dbeafe'; };
            editBtn.onmouseleave = () => { editBtn.style.background = '#eff6ff'; };
            delBtn.onmouseenter = () => { delBtn.style.background = '#fee2e2'; };
            delBtn.onmouseleave = () => { delBtn.style.background = '#fef2f2'; };

            delBtn.addEventListener('click', () => deleteNote(note.key));
            editBtn.addEventListener('click', () => {
                input.value = note.comment;
                input.dataset.editingKey = note.key; // Mark input as editing
                input.focus();
            });
        }

        annotationList.appendChild(div);
      });
    };

    const deleteNote = async (key) => {
        if(!confirm('–ò–∑—Ç—Ä–∏–≤–∞–Ω–µ?')) return;
        docId = getDocumentId();
        try {
            await firebase.database().ref(`annotations/${docId}/${key}`).remove();
        } catch(e) { console.error(e); }
    };

    const closeModal = () => {
      modal.classList.remove('open');
      window.getSelection().removeAllRanges();
      input.dataset.editingKey = ''; 
    };

    cancelBtn.addEventListener('click', closeModal);
    closeBtn.addEventListener('click', closeModal);

    saveBtn.addEventListener('click', async () => {
      const comment = input.value.trim();
      if (!comment) return;

      docId = getDocumentId();
      const user = JSON.parse(localStorage.getItem('loggedInUser')) || { username: 'Guest', color: '#588157' };

      // Editing existing note?
      if (input.dataset.editingKey) {
          try {
            await firebase.database().ref(`annotations/${docId}/${input.dataset.editingKey}`).update({
                comment: comment,
                lastEdited: firebase.database.ServerValue.TIMESTAMP
            });
            input.value = '';
            input.dataset.editingKey = '';
            // Close handled by user or they can add more
          } catch (e) { alert('–ì—Ä–µ—à–∫–∞.'); }
          return;
      }

      // Creating new note
      const annotationData = {
        text: currentGroupContext.text, // Use stored context
        context: currentGroupContext.context, 
        comment: comment,
        author: user.displayName || user.username,
        authorColor: user.color,
        authorAvatar: user.avatar || null,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      };

      try {
        await firebase.database().ref(`annotations/${docId}`).push(annotationData);
        input.value = ''; // Clear input
      } catch (e) {
        console.error('Error saving annotation:', e);
        alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å –Ω–∞ –±–µ–ª–µ–∂–∫–∞—Ç–∞.');
      }
    });

    // Legacy delete btn cleanup (hidden/unused now)
    if (deleteBtn) deleteBtn.style.display = 'none';

    // Function to render highlights from DB (Realtime)
    function loadAnnotations() {
      docId = getDocumentId();
      try {
        firebase.database().ref(`annotations/${docId}`).on('value', (snapshot) => {
            // 1. Cleanup existing highlights
            document.querySelectorAll('.annotation-highlight').forEach(span => {
                const parent = span.parentNode;
                while(span.firstChild) parent.insertBefore(span.firstChild, span);
                parent.removeChild(span);
                parent.normalize(); 
            });

            const groups = {};

            if (snapshot.exists()) {
              allAnnotations = snapshot.val();
              
              // 2. Group by text signature (trimmed)
              Object.keys(allAnnotations).forEach(key => {
                const ann = allAnnotations[key];
                ann.key = key; 
                const groupKey = (ann.text || "").trim(); 
                
                if (!groups[groupKey]) groups[groupKey] = [];
                groups[groupKey].push(ann);
              });

              // 3. Highlight groups
              Object.keys(groups).forEach(text => {
                highlightGroup(text, groups[text]);
              });
            }

            // 4. Update Modal if Open
            if (modal.classList.contains('open') && currentGroupContext) {
                const currentText = currentGroupContext.text.trim();
                const currentNotes = groups[currentText] || [];
                
                if (currentNotes.length === 0) {
                    closeModal(); // Auto-close if no notes left
                } else {
                    renderNotesList(currentNotes);
                }
            }
        });
      } catch (e) {
        console.error('Error loading annotations:', e);
      }
    }

    function hexToRgba(hex, alpha) {
      let r = 0, g = 0, b = 0;
      if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      } else if (hex.length === 7) {
        r = parseInt(hex.substring(1, 3), 16);
        g = parseInt(hex.substring(3, 5), 16);
        b = parseInt(hex.substring(5, 7), 16);
      }
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function highlightGroup(text, annotations) {
      const content = document.getElementById('content');
      const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null, false);
      let node;
      
      while (node = walker.nextNode()) {
        const index = node.textContent.indexOf(text);
        if (index !== -1) {
          // Context Check: verify if this node's parent context matches any annotation context
          const currentContext = node.parentElement.innerText.replace(/\s+/g, ' ').trim();
          
          // Filter annotations that belong to THIS context
          // We use a lenient check: does the DOM context contain the saved context snippet?
          // Or does the saved context (full paragraph) contain the DOM context?
          // Since we save 'containerText', it should be roughly equal.
          const relevantNotes = annotations.filter(ann => {
              const savedContext = (ann.context || "").replace(/\s+/g, ' ').trim();
              if (!savedContext) return true; // Legacy support
              return savedContext === currentContext || savedContext.includes(currentContext) || currentContext.includes(savedContext);
          });

          if (relevantNotes.length === 0) continue; // Not the right place for these notes

          const range = document.createRange();
          range.setStart(node, index);
          range.setEnd(node, index + text.length);
          
          // Check if already highlighted
          if (node.parentElement.classList.contains('annotation-highlight')) {
             continue; 
          }

          const span = document.createElement('span');
          span.className = 'annotation-highlight';
          
          // Use color of latest annotation
          const lastAnn = relevantNotes[relevantNotes.length - 1];
          const color = lastAnn.authorColor || '#588157';
          span.style.backgroundColor = hexToRgba(color, 0.2);
          span.style.borderBottomColor = color;
          
          if (relevantNotes.length > 1) {
             span.classList.add('annotation-multi');
             span.style.borderBottomStyle = 'double';
             span.title = `${relevantNotes.length} –±–µ–ª–µ–∂–∫–∏`;
          } else {
             span.title = `${lastAnn.author}: ${lastAnn.comment}`;
          }

          span.onclick = (e) => {
            e.stopPropagation();
            openModal(text, relevantNotes[0].context, relevantNotes);
          };
          
          try {
            range.surroundContents(span);
          } catch(e) { }
        }
      }
    }

    // Load after content is rendered
    setTimeout(loadAnnotations, 1500);
  })();
</script>
</body>
</html>
