<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Markdown Viewer</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  <style>
    :root {
      --bg: #fafafa;
      --fg: #1f2937;
      --accent: #7c3aed;
      --link: #6d28d9;
      --link-hover: #7c3aed;
      --card: #ffffff;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    html { margin: 0; padding: 0; }
    html, body { margin: 0; padding: 0; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      font-size: 1em;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      padding: 10px 16px;
      margin: 0;
      flex-shrink: 0;
      display: flex; align-items: center; gap: 10px;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
    }
    header h1 {
      display: none;
    }
    header a.btn {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 8px 12px; border-radius: 6px; text-decoration: none;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
    }
    header button.btn {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 8px 12px; border-radius: 6px;
      background: #eef2ff; color: var(--link); border: 1px solid #c7d2fe;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
    }
    header button.btn:hover {
      background: #e0e7ff;
      color: var(--link-hover);
    }
    header a.btn:nth-child(3) {
      display: none;
    }
    header a.btn:hover { background: #e0e7ff; color: var(--link-hover); }
    main { max-width: 1700px; margin: 0 auto; padding: 3px 3px; flex: 1; width: 100%; margin-top: 25px; }

    .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4 {
      margin-top: 0.05em; margin-bottom: 0.05em; font-weight: 600;
    }
    .markdown-body h1 { font-size: 1.7em; }
    .markdown-body h2 { font-size: 1.4em; }
    .markdown-body h3 { font-size: 1.2em;}
    .markdown-body h4 { font-size: 1.05em;}
    .markdown-body p { margin: 0.5em; }
    .markdown-body a { color: var(--link); text-decoration: underline; }
    .markdown-body a:hover { color: var(--link-hover); }

    /* Add padding to content so h1 doesn't hide under fixed header */
    #content { padding-top: 20px; }

    /* Tables: make horizontally scrollable on small screens */
    .table-scroll { overflow-x: auto; margin: 0.5em 0; }
    .table-scroll table { min-width: 560px; }

    .markdown-body table { width: 100%; border-collapse: collapse; margin: 0.2em 0; table-layout: auto; }
    .markdown-body th, .markdown-body td { border: 1px solid rgba(146, 64, 14, 0.35); padding: 6px 10px; text-align: left; vertical-align: top; height: 24px; line-height: 1.2; }
    .markdown-body thead th { background: rgba(196, 127, 9, 0.08); font-weight: 600; }
    .markdown-body tbody tr:nth-child(odd) { background: rgba(146, 64, 14, 0.03); }

    pre, code { font-family: Consolas, 'Courier New', monospace; }
    pre { background: var(--bg); padding: 12px; border-radius: 6px; overflow-x: auto; border: 1px solid var(--border); color: var(--fg); }
    code { background: var(--bg); padding: 2px 6px; border-radius: 4px; color: var(--fg); }

    @media (max-width: 768px) {
      main { padding: 12px; }
      .markdown-body { font-size: 0.83em; font-weight: 300; }
      .table-scroll table { font-size: 0.83em; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
</head>
<body>
  <header>
    <h1 id="docTitle">Преглед на документ</h1>
    <a class="btn" href="#" onclick="if (window.opener) { window.close(); } else if (document.referrer) { history.back(); } else { window.close(); } return false;" title="Назад">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="#6d28d9"><path d="M20,11H7.83l5.59-5.59L12,4l-8,8 8,8 1.41-1.41L7.83,13H20v-2z"/></svg>
      Назад
    </a>
    <a id="downloadLink" class="btn" href="#" download>
      <svg width="16" height="16" viewBox="0 0 24 24" fill="#6d28d9"><path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/></svg>
      Изтегли
    </a>
    <button id="fontSizeBtn" class="btn" title="Увеличи размер на текста">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="14" font-weight="bold">A</text></svg>
      A+
    </button>
  </header>
  <main>
    <div id="content" class="markdown-body">Зареждане…</div>
  </main>
  <script>
    // Function to process table rowspans (convert ^ to rowspan)
    function processTableRowspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each column
        const maxCols = Math.max(...rows.map(row => row.cells.length));
        
        for (let colIndex = 0; colIndex < maxCols; colIndex++) {
          let spanStart = -1;
          let spanCount = 0;
          
          for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            const cell = rows[rowIndex].cells[colIndex];
            
            if (!cell) continue;
            
            const cellText = cell.textContent.trim();
            
            if (cellText === '^') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply rowspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = rows[spanStart].cells[colIndex];
                if (spanCell) {
                  spanCell.setAttribute('rowspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = rowIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = rows[spanStart].cells[colIndex];
            if (spanCell) {
              spanCell.setAttribute('rowspan', spanCount + 1);
            }
          }
        }
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table colspans (convert < to colspan)
    function processTableColspans(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        
        // Process each row
        rows.forEach(row => {
          const cells = Array.from(row.cells);
          let spanStart = -1;
          let spanCount = 0;
          
          for (let colIndex = 0; colIndex < cells.length; colIndex++) {
            const cell = cells[colIndex];
            const cellText = cell.innerHTML.trim();
            
            if (cellText === '&lt;') {
              // Mark cell for deletion and count span
              cell.setAttribute('data-delete-colspan', 'true');
              spanCount++;
            } else {
              // If we were counting spans, apply colspan
              if (spanCount > 0 && spanStart >= 0) {
                const spanCell = cells[spanStart];
                if (spanCell) {
                  spanCell.setAttribute('colspan', spanCount + 1);
                }
              }
              // Reset for next potential span
              spanStart = colIndex;
              spanCount = 0;
            }
          }
          
          // Handle trailing spans
          if (spanCount > 0 && spanStart >= 0) {
            const spanCell = cells[spanStart];
            if (spanCell) {
              spanCell.setAttribute('colspan', spanCount + 1);
            }
          }
        });
        
        // Remove cells marked for deletion
        table.querySelectorAll('[data-delete-colspan="true"]').forEach(cell => cell.remove());
      });
      
      return doc.body.innerHTML;
    }

    // Function to process table cell alignment (>>text<<, <<text, text>>)
    function processTableAlignment(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table');
      
      tables.forEach(table => {
        const allCells = table.querySelectorAll('td, th');
        
        allCells.forEach(cell => {
          let content = cell.innerHTML.trim();
          
          // Check for center alignment >>text<<
          if (content.startsWith('&gt;&gt;') && content.endsWith('&lt;&lt;')) {
            cell.style.textAlign = 'center';
            cell.innerHTML = content.slice(8, -8); // Remove &gt;&gt; and &lt;&lt;
          }
          // Check for left alignment <<text
          else if (content.startsWith('&lt;&lt;')) {
            cell.style.textAlign = 'left';
            cell.innerHTML = content.slice(8); // Remove &lt;&lt;
          }
          // Check for right alignment text>>
          else if (content.endsWith('&gt;&gt;')) {
            cell.style.textAlign = 'right';
            cell.innerHTML = content.slice(0, -8); // Remove &gt;&gt;
          }
        });
      });
      
      return doc.body.innerHTML;
    }

    (function(){
      function getParam(name){ const u=new URL(window.location.href); return u.searchParams.get(name); }
      const path = getParam('path');
      const loadFromHash = getParam('loadFromHash') === 'true';
      if(!path){ document.getElementById('content').textContent = 'Липсва параметър path.'; return; }
      const decodedPath = decodeURIComponent(path);
      const title = decodedPath.split('/').pop();
      document.title = title + ' — Markdown Viewer';
      document.getElementById('docTitle').textContent = title;
      const dl = document.getElementById('downloadLink');
      dl.href = decodedPath;

      // If content is passed in hash, use it directly (no fetch needed)
      if (loadFromHash && window.location.hash) {
        try {
          const htmlContent = decodeURIComponent(window.location.hash.substring(1));
          const root = document.getElementById('content');
          root.innerHTML = htmlContent;
          
          // Render LaTeX with auto-render
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
        } catch (err) {
          document.getElementById('content').textContent = 'Грешка при зареждане на съдържанието: ' + err.message;
        }
        return;
      }

      const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
      const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
        ? new URL(encodedPath, window.location.origin).href
        : encodedPath;

      fetch(absoluteUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); })
        .then(content => {
          let html;
          
          // If it's an HTML file, extract body content directly
          if (/\.html$/i.test(decodedPath)) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            html = doc.body.innerHTML;
          } else {
            // Otherwise parse as Markdown
            html = marked.parse(content);
            
            // Process tables to support rowspan with ^ syntax (only if needed)
            if (html.includes('^')) {
              html = processTableRowspans(html);
            }
            
            // Process tables to support cell alignment with >>text<<, <<text, text>> (BEFORE colspan!)
            if (html.includes('&gt;&gt;') || html.includes('&lt;&lt;')) {
              html = processTableAlignment(html);
            }
            
            // Process tables to support colspan with < syntax (only if needed)
            if (html.includes('&lt;')) {
              html = processTableColspans(html);
            }
          }
          
          const root = document.getElementById('content');
          root.innerHTML = html;
          
          // Images now use relative paths like "assets/image.png" which resolve correctly
          // from md-viewer.html location since all assets are in the central assets/ folder
          // No path fixing needed!
          
          // Render LaTeX with auto-render - simple and direct
          if (typeof renderMathInElement !== 'undefined') {
            try {
              renderMathInElement(root, {
                delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false}
                ],
                throwOnError: false
              });
            } catch (e) {
              console.error('KaTeX error:', e);
            }
          }
          
          // Wrap tables for horizontal scroll on mobile
          root.querySelectorAll('table').forEach(tbl => {
            if(!tbl.parentElement.classList.contains('table-scroll')){
              const wrap = document.createElement('div');
              wrap.className = 'table-scroll';
              tbl.parentElement.insertBefore(wrap, tbl);
              wrap.appendChild(tbl);
            }
          });
          
          // Make all links open in new tab
          root.querySelectorAll('a').forEach(a => a.target = '_blank');
        })
        .catch(err => {
          const isFile = window.location.protocol === 'file:';
          const hint = isFile
            ? '<br><small>Съвет: Отвори сайта през локален HTTP сървър (напр. VS Code Live Server), тъй като браузърите блокират fetch от file://</small>'
            : '';
          document.getElementById('content').innerHTML = '<p style="color:#b91c1c">Грешка при зареждане: '+(err && err.message ? err.message : err)+'</p>'+hint;
        });
    })();
    
    // Font size control - outside IIFE so it works immediately
    const fontSizeBtn = document.getElementById('fontSizeBtn');
    const contentDiv = document.getElementById('content');
    
    // Load saved font size from localStorage
    const savedFontSize = localStorage.getItem('mdViewerFontSize');
    if (savedFontSize && contentDiv) {
      contentDiv.style.fontSize = savedFontSize;
    }
    
    // Detect if mobile
    const isMobile = window.innerWidth <= 768;
    
    // Font size increment levels - different for mobile and desktop
    const fontSizes = isMobile 
      ? ['0.6em', '0.75em', '0.9em', '1em'] // Mobile sizes (smaller)
      : ['0.8em', '1em', '1.2em', '1.4em']; // Desktop sizes
    
    let currentSizeIndex = fontSizes.findIndex(size => {
      if (savedFontSize) return size === savedFontSize;
      return isMobile ? size === '0.75em' : size === '1em'; // Default
    });
    if (currentSizeIndex === -1) currentSizeIndex = isMobile ? 1 : 1;
    
    fontSizeBtn.addEventListener('click', () => {
      currentSizeIndex = (currentSizeIndex + 1) % fontSizes.length;
      const newSize = fontSizes[currentSizeIndex];
      
      contentDiv.style.fontSize = newSize;
      
      // Save to localStorage
      localStorage.setItem('mdViewerFontSize', newSize);
      
      // Visual feedback
      fontSizeBtn.style.transform = 'scale(1.1)';
      setTimeout(() => {
        fontSizeBtn.style.transform = 'scale(1)';
      }, 200);
    });
    
    // Add transition to button
    fontSizeBtn.style.transition = 'transform 0.2s ease';
  </script>
</body>
</html>
