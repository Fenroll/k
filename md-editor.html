<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Markdown Editor - WYSIWYG</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Open Sans', Arial, sans-serif;
      background: #fafafa;
      display: flex;
      flex-direction: column;
    }

    /* Toolbar */
    .toolbar {
      position: sticky;
      top: 0;
      z-index: 100;
      background: #fff;
      border-bottom: 1px solid #e5e7eb;
      padding: 10px 16px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    .toolbar-group {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 0 8px;
      border-right: 1px solid #e5e7eb;
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar button {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      background: #fff;
      color: #374151;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .toolbar button:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }

    .toolbar button.active {
      background: #92400e;
      color: #fff;
      border-color: #92400e;
    }

    .toolbar select {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      background: #fff;
      color: #374151;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-family: 'Open Sans', Arial, sans-serif;
    }

    /* Main editor container */
    .editor-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* Editor area */
    #editor {
      flex: 1;
      padding: 12px 200px;
      font-size: 16px;
      font-family: 'Open Sans', Arial, sans-serif;
      outline: none;
      overflow-y: auto;
      background: #fff;
      color: #1f2937;
      line-height: 1.6;
      word-wrap: break-word;
      -webkit-user-select: text;
      user-select: text;
    }

    #editor:focus {
      outline: none;
    }

    /* Markdown content styling to match index.html */
    #editor h1,
    #editor h2,
    #editor h3,
    #editor h4 {
      color: #92400e;
      margin-top: 0.8em;
      margin-bottom: 0.3em;
      font-weight: 600;
    }

    #editor h1 { font-size: 1.5em; }
    #editor h2 { font-size: 1.3em; }
    #editor h3 { font-size: 1.1em; }
    #editor h4 { font-size: 1.05em; }

    #editor p {
      margin: 0.7em 0;
      white-space: pre-wrap;
    }

    /* Reduce space between paragraph and following list */
    #editor p + ul,
    #editor p + ol {
      margin-top: -0.5em;
    }

    /* Reduce space between heading and following content */
    #editor h1 + p,
    #editor h2 + p,
    #editor h3 + p,
    #editor h4 + p,
    #editor h1 + ul,
    #editor h2 + ul,
    #editor h3 + ul,
    #editor h4 + ul,
    #editor h1 + ol,
    #editor h2 + ol,
    #editor h3 + ol,
    #editor h4 + ol {
      margin-top: 0.1em;
    }

    /* Reduce space between h3 and h4 */
    #editor h3 + h4 {
      margin-top: 0.3em;
    }

    #editor ul,
    #editor ol {
      margin: 0.3em 0;
      padding-left: 1.5em;
    }

    #editor li {
      margin: 0.15em 0;
    }

    #editor ul ul {
      list-style-type: circle;
    }

    #editor ul ul ul {
      list-style-type: square;
    }

    #editor strong {
      font-weight: 600;
    }

    #editor em {
      font-style: italic;
    }

    #editor code {
      background: rgba(146, 64, 14, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    #editor pre {
      background: rgba(255, 255, 255, 0.5);
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
      font-family: 'Courier New', monospace;
    }

    #editor pre code {
      background: none;
      padding: 0;
    }

    #editor blockquote {
      border-left: 3px solid #f59e0b;
      padding-left: 1em;
      margin: 0.5em 0;
      font-style: italic;
      color: #78350f;
    }

    #editor a {
      color: #f59e0b;
      text-decoration: underline;
      cursor: pointer;
    }

    #editor a:hover {
      color: #d97706;
    }

    #editor table {
      border-collapse: collapse;
      margin: 0.75em 0;
      width: 100%;
      table-layout: auto;
    }

    #editor th,
    #editor td {
      border: 1px solid rgba(146, 64, 14, 0.35);
      padding: 6px 10px;
      text-align: left;
      vertical-align: top;
    }

    #editor thead th {
      background: rgba(196, 127, 9, 0.08);
      font-weight: 600;
    }

    #editor tbody tr:nth-child(odd) {
      background: rgba(146, 64, 14, 0.03);
    }

    /* Raw code modal */
    .raw-code-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #92400e;
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 1.2em;
      transition: all 0.3s;
      z-index: 200;
    }

    .raw-code-btn:hover {
      background: #b8520d;
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
      transform: scale(1.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 300;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 8px;
      width: 100%;
      max-width: 900px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 25px rgba(0,0,0,0.15);
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      margin: 0;
      color: #1f2937;
      font-size: 1.2em;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: #6b7280;
    }

    .modal-close:hover {
      color: #1f2937;
    }

    .modal-body {
      flex: 1;
      overflow: auto;
      padding: 16px 20px;
    }

    .raw-code {
      width: 100%;
      min-height: 300px;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      resize: vertical;
      line-height: 1.5;
    }

    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-footer button {
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      background: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s;
    }

    .modal-footer button:hover {
      background: #f3f4f6;
    }

    .modal-footer button.primary {
      background: #92400e;
      color: #fff;
      border-color: #92400e;
    }

    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* File list styles */
    .file-item {
      padding: 12px 16px;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .file-item:hover {
      background: #fef3c7;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-item-name {
      font-weight: 500;
      color: #1f2937;
      font-size: 0.95em;
    }

    .file-item-path {
      font-size: 0.85em;
      color: #6b7280;
    }

    .file-item.hidden {
      display: none;
    }

    /* Course group header */
    .course-header {
      padding: 10px 16px;
      background: #f59e0b;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      position: sticky;
      top: 0;
      z-index: 1;
      border-bottom: 2px solid #d97706;
    }

    .course-header.hidden {
      display: none;
    }

      font-size: 0.85em;
      color: #6b7280;
    }

    .file-item.hidden {
      display: none;
    }
    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* Keyboard shortcuts hint */
    .shortcuts-hint {
      padding: 8px 12px;
      background: #fef3c7;
      border: 1px solid #fcd34d;
      border-radius: 4px;
      font-size: 0.85em;
      color: #78350f;
      margin-left: auto;
    }

    @media (max-width: 768px) {
      .toolbar {
        padding: 8px 12px;
      }

      .toolbar button {
        padding: 5px 8px;
        font-size: 0.85em;
      }

      .shortcuts-hint {
        display: none;
      }

      #editor {
        padding: 16px;
      }

      .raw-code-btn {
        width: 45px;
        height: 45px;
        bottom: 15px;
        right: 15px;
      }
    }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolbar-group">
      <select id="formatSelect" title="Format (Ctrl+0-4)">
        <option value="p">Normal (Ctrl+0)</option>
        <option value="h1">Heading 1 (Ctrl+1)</option>
        <option value="h2">Heading 2 (Ctrl+2)</option>
        <option value="h3">Heading 3 (Ctrl+3)</option>
        <option value="h4">Heading 4 (Ctrl+4)</option>
      </select>
    </div>

    <div class="toolbar-group">
      <button id="boldBtn" title="Bold (Ctrl+B)"><strong>B</strong></button>
      <button id="italicBtn" title="Italic (Ctrl+I)"><em>I</em></button>
      <button id="underlineBtn" title="Underline (Ctrl+U)"><u>U</u></button>
      <button id="codeBtn" title="Code (Ctrl+`)"><code>`code`</code></button>
    </div>

    <div class="toolbar-group">
      <button id="ulBtn" title="Unordered List (Ctrl+Shift+U)">‚Ä¢ List</button>
      <button id="olBtn" title="Ordered List (Ctrl+Shift+O)">1. List</button>
      <button id="quoteBtn" title="Quote (Ctrl+Q)">¬ª  Quote</button>
    </div>

    <div class="toolbar-group">
      <button id="tableBtn" title="Table (Ctrl+T)">‚äû Table</button>
      <button id="linkBtn" title="Link (Ctrl+K)">üîó Link</button>
      <button id="hrBtn" title="Horizontal Line">‚îÅ‚îÅ Line</button>
    </div>

    <div class="toolbar-group">
      <button id="undoBtn" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
    </div>

    <div class="toolbar-group">
      <button id="openLocalBtn" title="Open .md file from computer">üìÇ Open Local</button>
      <button id="openCoursesBtn" title="Open .md file from courses">üìö Open Courses</button>
    </div>

    <div class="toolbar-group">
      <button id="downloadBtn" title="Download as .md file">‚¨á Download</button>
      <button id="clearBtn" title="Clear all content">üóë Clear</button>
      <button id="shortcutsBtn" title="Show keyboard shortcuts">‚å® Shortcuts</button>
    </div>
  </div>

  <!-- Hidden file input for local file opening -->
  <input type="file" id="fileInput" accept=".md,.txt" style="display:none;">

  <!-- Editor -->
  <div class="editor-container">
    <div id="editor" contenteditable="true" spellcheck="false">
      <p>Start typing here...</p>
    </div>
  </div>

  <!-- Raw code button -->
  <button class="raw-code-btn" id="rawCodeBtn" title="Show Raw Code">{ }</button>

  <!-- Raw code modal -->
  <div class="modal" id="rawCodeModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Raw Markdown Code</h2>
        <button class="modal-close" id="closeModalBtn">√ó</button>
      </div>
      <div class="modal-body">
        <textarea class="raw-code" id="rawCodeTextarea" spellcheck="false"></textarea>
      </div>
      <div class="modal-footer">
        <button id="copyBtn">üìã Copy</button>
        <button class="primary" id="updateBtn">Save</button>
        <button id="cancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Shortcuts modal -->
  <div class="modal" id="shortcutsModal">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Keyboard Shortcuts</h2>
        <button class="close-btn" id="closeShortcutsBtn">√ó</button>
      </div>
      <div class="modal-body" style="max-height: 500px; overflow-y: auto;">
        <h3>Formatting</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+0</strong> - Normal paragraph</li>
          <li style="margin: 8px 0;"><strong>Ctrl+1</strong> - Heading 1</li>
          <li style="margin: 8px 0;"><strong>Ctrl+2</strong> - Heading 2</li>
          <li style="margin: 8px 0;"><strong>Ctrl+3</strong> - Heading 3</li>
          <li style="margin: 8px 0;"><strong>Ctrl+4</strong> - Heading 4</li>
          <li style="margin: 8px 0;"><strong>Ctrl+B</strong> - Bold</li>
          <li style="margin: 8px 0;"><strong>Ctrl+I</strong> - Italic</li>
          <li style="margin: 8px 0;"><strong>Ctrl+U</strong> - Underline</li>
          <li style="margin: 8px 0;"><strong>Ctrl+`</strong> - Code</li>
        </ul>
        <h3>Lists & Blocks</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+U</strong> - Unordered list</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+O</strong> - Ordered list</li>
          <li style="margin: 8px 0;"><strong>Tab</strong> - Indent list item (move right)</li>
          <li style="margin: 8px 0;"><strong>Shift+Tab</strong> - Outdent list item (move left)</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Q</strong> - Quote</li>
          <li style="margin: 8px 0;"><strong>Ctrl+T</strong> - Table</li>
          <li style="margin: 8px 0;"><strong>Ctrl+K</strong> - Link</li>
        </ul>
        <h3>Editing</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+Z</strong> - Undo</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Y</strong> or <strong>Ctrl+Shift+Z</strong> - Redo</li>
        </ul>
      </div>
      <div class="modal-footer">
        <button class="primary" id="closeShortcutsBtn2">Close</button>
      </div>
    </div>
  </div>

  <!-- File Browser Modal -->
  <div id="fileBrowserModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
      <div class="modal-header">
        <h2>Open Markdown File from Courses</h2>
        <span class="close" id="closeFileBrowserBtn">&times;</span>
      </div>
      <div class="modal-body" style="max-height: 600px; overflow: hidden; display: flex; flex-direction: column;">
        <div style="margin-bottom: 12px;">
          <input type="text" id="fileSearchInput" placeholder="Search files..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div id="fileListContainer" style="flex: 1; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px;">
          <div id="fileList" style="padding: 0;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="closeFileBrowserBtn2">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Save File Modal -->
  <div id="saveFileModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Save Markdown File</h2>
        <span class="close" id="closeSaveModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <label for="fileNumberInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Number</label>
          <input type="text" id="fileNumberInput" placeholder="e.g., 1, 2, 3..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
          <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">Optional: Leave empty if not needed</div>
        </div>
        <div style="margin-bottom: 16px;">
          <label for="fileNameInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Name</label>
          <input type="text" id="fileNameInput" placeholder="e.g., –•–û–ë–ë, –ë–µ–ª–æ–¥—Ä–æ–±–µ–Ω –∫–∞—Ä—Ü–∏–Ω–æ–º" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="padding: 10px; background: #f3f4f6; border-radius: 4px; font-size: 0.9em; color: #4b5563;">
          <strong>Preview:</strong> <span id="fileNamePreview" style="color: #92400e; font-family: monospace;">document.md</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelSaveBtn">Cancel</button>
        <button class="primary" id="confirmSaveBtn">Download</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
  <script src="courses.generated.js"></script>

  <script>
    const editor = document.getElementById('editor');
    const rawCodeBtn = document.getElementById('rawCodeBtn');
    const rawCodeModal = document.getElementById('rawCodeModal');
    const rawCodeTextarea = document.getElementById('rawCodeTextarea');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const copyBtn = document.getElementById('copyBtn');
    const updateBtn = document.getElementById('updateBtn');
    
    const shortcutsBtn = document.getElementById('shortcutsBtn');
    const shortcutsModal = document.getElementById('shortcutsModal');
    const closeShortcutsBtn = document.getElementById('closeShortcutsBtn');
    const closeShortcutsBtn2 = document.getElementById('closeShortcutsBtn2');

    let isRawMode = false;
    let editorContent = '';
    let rawContent = '';
    let originalHtml = '<p>Start typing here...</p>';
    
    // Global base path for images
    let globalImageBasePath = '';
    
    // Track current file info
    let currentFileInfo = {
      name: '',
      number: '',
      isFromCourses: false
    };
    
    // Flag to prevent auto-save during file loading
    let isLoadingFile = false;

    // History for undo/redo
    let history = ['<p>Start typing here...</p>'];
    let historyIndex = 0;

    // Save current state to history
    function saveToHistory() {
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(editor.innerHTML);
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    // Toolbar functions
    function insertFormat(tag) {
      const selection = window.getSelection();
      if (selection.toString().length > 0) {
        document.execCommand('formatBlock', false, tag);
      }
    }

    function insertInline(tag) {
      const selection = window.getSelection();
      if (selection.toString().length > 0) {
        if (tag === 'code') {
          document.execCommand('formatBlock', false, 'code');
        } else {
          document.execCommand(tag, false, null);
        }
      }
      saveToHistory();
      editor.focus();
    }

    function insertList(type) {
      if (type === 'ul') {
        document.execCommand('insertUnorderedList', false, null);
      } else {
        document.execCommand('insertOrderedList', false, null);
      }
      saveToHistory();
      editor.focus();
    }

    function insertBlockquote() {
      document.execCommand('formatBlock', false, 'blockquote');
      saveToHistory();
      editor.focus();
    }

    function insertTable() {
      const rows = prompt('Number of rows:', '3');
      const cols = prompt('Number of columns:', '3');
      if (rows && cols) {
        const rowNum = parseInt(rows);
        const colNum = parseInt(cols);
        let table = '<table><thead><tr>';
        for (let i = 0; i < colNum; i++) {
          table += '<th>Header ' + (i + 1) + '</th>';
        }
        table += '</tr></thead><tbody>';
        for (let i = 0; i < rowNum - 1; i++) {
          table += '<tr>';
          for (let j = 0; j < colNum; j++) {
            table += '<td>Cell</td>';
          }
          table += '</tr>';
        }
        table += '</tbody></table>';
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const fragment = document.createRange().createContextualFragment(table);
          range.insertNode(fragment);
        }
        saveToHistory();
      }
      editor.focus();
    }

    function insertLink() {
      const url = prompt('Enter URL:', 'https://');
      const text = window.getSelection().toString() || 'Link';
      if (url) {
        document.execCommand('createLink', false, url);
      }
      saveToHistory();
      editor.focus();
    }

    function insertHR() {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const hr = document.createElement('hr');
      range.insertNode(hr);
      range.setStartAfter(hr);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
      saveToHistory();
      editor.focus();
    }

    // Toolbar button events
    document.getElementById('formatSelect').addEventListener('change', (e) => {
      const format = e.target.value;
      insertFormat(format);
      saveToHistory();
      // Reset dropdown to "Normal" so it can be used again
      e.target.value = 'p';
      editor.focus();
    });

    document.getElementById('boldBtn').addEventListener('click', () => {
      document.execCommand('bold', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('italicBtn').addEventListener('click', () => {
      document.execCommand('italic', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('underlineBtn').addEventListener('click', () => {
      document.execCommand('underline', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('codeBtn').addEventListener('click', () => {
      const selection = window.getSelection();
      if (selection.toString().length > 0) {
        const range = selection.getRangeAt(0);
        const span = document.createElement('code');
        range.surroundContents(span);
        editor.focus();
        saveToHistory();
      }
    });

    document.getElementById('ulBtn').addEventListener('click', () => {
      insertList('ul');
    });

    document.getElementById('olBtn').addEventListener('click', () => {
      insertList('ol');
    });

    document.getElementById('quoteBtn').addEventListener('click', () => {
      insertBlockquote();
    });

    document.getElementById('tableBtn').addEventListener('click', () => {
      insertTable();
    });

    document.getElementById('linkBtn').addEventListener('click', () => {
      insertLink();
    });

    document.getElementById('hrBtn').addEventListener('click', () => {
      insertHR();
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        editor.innerHTML = history[historyIndex];
      }
    });

    document.getElementById('redoBtn').addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        editor.innerHTML = history[historyIndex];
      }
    });

    document.getElementById('downloadBtn').addEventListener('click', () => {
      // Populate modal with current file info
      document.getElementById('fileNumberInput').value = currentFileInfo.number || '';
      document.getElementById('fileNameInput').value = currentFileInfo.name || '';
      updateFileNamePreview();
      
      // Show modal
      document.getElementById('saveFileModal').style.display = 'flex';
      document.getElementById('fileNameInput').focus();
    });

    // Open local .md file from computer
    document.getElementById('openLocalBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        const markdownContent = event.target.result;
        
        // Set global base path for images (use file's directory)
        if (file.name) {
          // For local files, we can't reliably set base path, but we try
          globalImageBasePath = '';
        }
        
        // Convert markdown to HTML
        isLoadingFile = true;
        const html = markdownToHtml(markdownContent);
        editor.innerHTML = html;
        saveToHistory();
        setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
        
        // Extract file info for saving later
        const fileName = file.name.replace(/\.(md|txt)$/i, '');
        const numberMatch = fileName.match(/^(\d+(\.\d+)?)-/);
        const nameWithoutNumber = fileName.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '');
        
        currentFileInfo = {
          name: nameWithoutNumber,
          number: numberMatch ? numberMatch[1] : '',
          isFromCourses: false
        };
        
        // Update page title
        document.title = fileName + ' ‚Äî Markdown Editor';
      };
      reader.readAsText(file);
      
      // Reset file input
      e.target.value = '';
    });

    // Open .md file from courses.generated.js
    document.getElementById('openCoursesBtn').addEventListener('click', () => {
      // Check if courses data is available
      if (typeof courses === 'undefined') {
        alert('Courses data not found. Please make sure you are running this from index.html or include courses.generated.js');
        return;
      }
      
      // Group files by course
      const filesByCourse = {};
      courses.forEach(course => {
        const courseName = course.title || course.name || 'Unknown';
        filesByCourse[courseName] = [];
        
        course.sections.forEach(section => {
          if (section.msgNotes) {
            section.msgNotes.forEach(note => {
              if (note.path && /\.md$/i.test(note.path) && note.type === 'markdown') {
                filesByCourse[courseName].push({
                  name: note.name,
                  path: note.path,
                  content: note.content,
                  courseName: courseName,
                  sectionName: section.name
                });
              }
            });
          }
        });
      });
      
      // Populate file list with course headers
      const fileList = document.getElementById('fileList');
      fileList.innerHTML = '';
      
      Object.keys(filesByCourse).forEach(courseName => {
        const files = filesByCourse[courseName];
        if (files.length === 0) return;
        
        // Add course header
        const courseHeader = document.createElement('div');
        courseHeader.className = 'course-header';
        courseHeader.textContent = courseName;
        courseHeader.setAttribute('data-course', courseName);
        fileList.appendChild(courseHeader);
        
        // Add files for this course
        files.forEach((file, idx) => {
          const fileItem = document.createElement('div');
          fileItem.className = 'file-item';
          fileItem.setAttribute('data-course', courseName);
          fileItem.setAttribute('data-search-text', (file.courseName + ' ' + file.sectionName + ' ' + file.name).toLowerCase());
          
          // Clean up file name: remove msg-, number prefix (including decimals like 2.4), and .md extension
          const cleanName = file.name
            .replace(/^\d+(\.\d+)?-/, '')   // Remove number prefix (e.g., "1-", "2.4-")
            .replace(/^msg-/i, '')          // Remove "msg-" prefix
            .replace(/\.(md|txt)$/i, '');   // Remove .md or .txt extension
          
          fileItem.innerHTML = `
            <div class="file-item-name">${cleanName}</div>
            <div class="file-item-path">${file.sectionName}</div>
          `;
          
          fileItem.addEventListener('click', () => {
            loadFileFromCourses(file);
            document.getElementById('fileBrowserModal').style.display = 'none';
          });
          
          fileList.appendChild(fileItem);
        });
      });
      
      // Show modal
      document.getElementById('fileBrowserModal').style.display = 'flex';
      document.getElementById('fileSearchInput').value = '';
      document.getElementById('fileSearchInput').focus();
    });

    // File search functionality
    document.getElementById('fileSearchInput').addEventListener('input', (e) => {
      const searchText = e.target.value.toLowerCase();
      const fileItems = document.querySelectorAll('.file-item');
      const courseHeaders = document.querySelectorAll('.course-header');
      
      // Track which courses have visible files
      const visibleCourses = new Set();
      
      fileItems.forEach(item => {
        const itemText = item.getAttribute('data-search-text');
        if (itemText.includes(searchText)) {
          item.classList.remove('hidden');
          visibleCourses.add(item.getAttribute('data-course'));
        } else {
          item.classList.add('hidden');
        }
      });
      
      // Show/hide course headers based on whether they have visible files
      courseHeaders.forEach(header => {
        const courseName = header.getAttribute('data-course');
        if (visibleCourses.has(courseName)) {
          header.classList.remove('hidden');
        } else {
          header.classList.add('hidden');
        }
      });
    });

    // Function to load file from courses
    function loadFileFromCourses(file) {
      // Set global base path for images
      const basePath = file.path.substring(0, file.path.lastIndexOf('/') + 1);
      if (window.location.protocol === 'file:') {
        const currentPath = window.location.pathname;
        const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
        globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
      } else {
        const currentOrigin = window.location.origin;
        globalImageBasePath = currentOrigin + '/' + basePath;
      }
      
      // Convert markdown to HTML
      isLoadingFile = true;
      const html = markdownToHtml(file.content);
      editor.innerHTML = html;
      saveToHistory();
      setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
      
      // Extract file info for saving later
      const numberMatch = file.name.match(/^(\d+(\.\d+)?)-/);
      const cleanName = file.name.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '').replace(/\.(md|txt)$/i, '');
      
      currentFileInfo = {
        name: cleanName,
        number: numberMatch ? numberMatch[1] : '',
        isFromCourses: true
      };
      
      // Update page title
      document.title = cleanName + ' ‚Äî Markdown Editor';
    }

    // Close file browser modal
    document.getElementById('closeFileBrowserBtn').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    document.getElementById('closeFileBrowserBtn2').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    // Close modal when clicking outside
    document.getElementById('fileBrowserModal').addEventListener('click', (e) => {
      if (e.target.id === 'fileBrowserModal') {
        document.getElementById('fileBrowserModal').style.display = 'none';
      }
    });

    // Save file modal functionality
    function updateFileNamePreview() {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      const preview = document.getElementById('fileNamePreview');
      
      let fileName = '';
      if (number) {
        fileName += number + '-msg-';
      }
      fileName += (name || 'document') + '.md';
      
      preview.textContent = fileName;
    }

    document.getElementById('fileNumberInput').addEventListener('input', updateFileNamePreview);
    document.getElementById('fileNameInput').addEventListener('input', updateFileNamePreview);

    document.getElementById('confirmSaveBtn').addEventListener('click', () => {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      
      if (!name) {
        alert('Please enter a file name');
        return;
      }
      
      const markdown = htmlToMarkdown(editor.innerHTML);
      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      
      // Format: number-msg-filename.md or just msg-filename.md
      let fileName = '';
      if (number) {
        fileName = number + '-msg-' + name + '.md';
      } else {
        fileName = name + '.md';
      }
      
      link.download = fileName;
      link.click();
      URL.revokeObjectURL(link.href);
      
      // Close modal
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('cancelSaveBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('closeSaveModalBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('saveFileModal').addEventListener('click', (e) => {
      if (e.target.id === 'saveFileModal') {
        document.getElementById('saveFileModal').style.display = 'none';
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all content?')) {
        editor.innerHTML = '<p></p>';
        saveToHistory();
        editor.focus();
      }
    });

    // Shortcuts modal
    shortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.add('open');
    });

    closeShortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    closeShortcutsBtn2.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    shortcutsModal.addEventListener('click', (e) => {
      if (e.target === shortcutsModal) {
        shortcutsModal.classList.remove('open');
      }
    });

    // Raw code modal - TOGGLE MODE
    // Function to apply syntax highlighting to markdown
    function highlightMarkdown(text) {
      // Escape HTML to prevent code execution
      let highlighted = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Headers (h1-h4)
      highlighted = highlighted.replace(/^(#{1,4})\s+(.*)$/gm, '<span style="color: #92400e; font-weight: 600;">$1</span> <span style="color: #78350f; font-weight: 600;">$2</span>');
      
      // Bold **text**
      highlighted = highlighted.replace(/\*\*([^*]+)\*\*/g, '<span style="color: #1f2937; font-weight: 600;">**</span><span style="color: #374151; font-weight: 600;">$1</span><span style="color: #1f2937; font-weight: 600;">**</span>');
      
      // Italic *text*
      highlighted = highlighted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span style="color: #6b7280;">*</span><span style="color: #6b7280; font-style: italic;">$1</span><span style="color: #6b7280;">*</span>');
      
      // Underline __text__
      highlighted = highlighted.replace(/__([^_]+)__/g, '<span style="color: #9ca3af;">__</span><span style="color: #9ca3af; text-decoration: underline;">$1</span><span style="color: #9ca3af;">__</span>');
      
      // Inline code `code`
      highlighted = highlighted.replace(/`([^`]+)`/g, '<span style="color: #059669;">`</span><span style="color: #059669; background: rgba(5, 150, 105, 0.1);">$1</span><span style="color: #059669;">`</span>');
      
      // Links [text](url)
      highlighted = highlighted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<span style="color: #2563eb;">[</span><span style="color: #3b82f6;">$1</span><span style="color: #2563eb;">](</span><span style="color: #60a5fa; text-decoration: underline;">$2</span><span style="color: #2563eb;">)</span>');
      
      // Images ![alt](url)
      highlighted = highlighted.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<span style="color: #7c3aed;">![</span><span style="color: #8b5cf6;">$1</span><span style="color: #7c3aed;">](</span><span style="color: #a78bfa; text-decoration: underline;">$2</span><span style="color: #7c3aed;">)</span>');
      
      // Unordered list - keep original - or * marker
      highlighted = highlighted.replace(/^(\s*)([-*])\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2</span> <span style="color: #374151;">$3</span>');
      
      // Ordered list
      highlighted = highlighted.replace(/^(\s*)(\d+)\.\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2.</span> <span style="color: #374151;">$3</span>');
      
      // Blockquote
      highlighted = highlighted.replace(/^(&gt;)\s+(.*)$/gm, '<span style="color: #d97706; font-weight: 600;">$1</span> <span style="color: #92400e; font-style: italic;">$2</span>');
      
      // Horizontal rule
      highlighted = highlighted.replace(/^---+$/gm, '<span style="color: #6b7280;">---</span>');
      
      return highlighted;
    }

    rawCodeBtn.addEventListener('click', () => {
      if (!isRawMode) {
        // Switch to raw mode - show markdown source with syntax highlighting
        isRawMode = true;
        originalHtml = editor.innerHTML;
        rawContent = htmlToMarkdown(originalHtml);
        
        // Apply syntax highlighting
        const highlighted = highlightMarkdown(rawContent);
        editor.innerHTML = highlighted;
        editor.contentEditable = 'true';
        editor.style.fontFamily = "'Courier New', monospace";
        editor.style.fontSize = '0.9em';
        editor.style.whiteSpace = 'pre-wrap';
        rawCodeBtn.style.background = '#d97706';
        rawCodeBtn.title = 'Switch to formatted view';
      } else {
        // Switch to formatted mode - convert raw markdown to HTML
        isRawMode = false;
        
        // Get text content (now it has correct - and * symbols)
        rawContent = editor.textContent;
        
        originalHtml = markdownToHtml(rawContent);
        editor.innerHTML = originalHtml;
        editor.style.fontFamily = "'Open Sans', Arial, sans-serif";
        editor.style.fontSize = '0.95em';
        editor.style.whiteSpace = 'normal';
        rawCodeBtn.style.background = '#92400e';
        rawCodeBtn.title = 'Show raw code';
      }
      editor.focus();
      saveToHistory();
    });

    // No modal needed - toggle is in editor directly

    // Keyboard shortcuts
    editor.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'b') {
          e.preventDefault();
          document.execCommand('bold', false, null);
          saveToHistory();
        } else if (e.key === 'i') {
          e.preventDefault();
          document.execCommand('italic', false, null);
          saveToHistory();
        } else if (e.key === '`') {
          e.preventDefault();
          document.execCommand('formatBlock', false, 'code');
          saveToHistory();
        } else if (e.key === '1') {
          e.preventDefault();
          insertFormat('h1');
          saveToHistory();
        } else if (e.key === '2') {
          e.preventDefault();
          insertFormat('h2');
          saveToHistory();
        } else if (e.key === '3') {
          e.preventDefault();
          insertFormat('h3');
          saveToHistory();
        } else if (e.key === '4') {
          e.preventDefault();
          insertFormat('h4');
          saveToHistory();
        } else if (e.key === '0') {
          e.preventDefault();
          insertFormat('p');
          saveToHistory();
        } else if (e.shiftKey && e.key === 'U') {
          e.preventDefault();
          document.execCommand('insertUnorderedList', false, null);
          saveToHistory();
        } else if (e.shiftKey && e.key === 'O') {
          e.preventDefault();
          document.execCommand('insertOrderedList', false, null);
          saveToHistory();
        } else if (e.key === 't') {
          e.preventDefault();
          insertTable();
        } else if (e.key === 'k') {
          e.preventDefault();
          insertLink();
        } else if (e.key === 'q') {
          e.preventDefault();
          insertBlockquote();
        } else if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          if (historyIndex > 0) {
            historyIndex--;
            editor.innerHTML = history[historyIndex];
          }
        } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
          e.preventDefault();
          if (historyIndex < history.length - 1) {
            historyIndex++;
            editor.innerHTML = history[historyIndex];
          }
        }
      }
    });

    // Save to history on input
    editor.addEventListener('input', () => {
      if (editor.textContent.trim().length > 0) {
        // Debounce history saving
        clearTimeout(editor.historyTimeout);
        editor.historyTimeout = setTimeout(() => {
          saveToHistory();
        }, 1000);
      }
    });

    // Click handler for links (Ctrl+Click to open)
    editor.addEventListener('click', (e) => {
      // Check if clicking on a link
      let target = e.target;
      
      // Find parent link if clicking on child element
      while (target && target !== editor) {
        if (target.tagName === 'A') {
          // Ctrl+Click or Cmd+Click to open link
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              window.open(href, '_blank');
              
              // Show notification
              const notification = document.createElement('div');
              notification.textContent = `üîó Opening: ${href}`;
              notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #2563eb; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
              document.body.appendChild(notification);
              
              setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
              }, 2000);
            }
          } else {
            // Regular click - show tooltip
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              const tooltip = document.createElement('div');
              tooltip.textContent = `Ctrl+Click to open: ${href}`;
              tooltip.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #374151; color: white; padding: 8px 14px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 12px;';
              document.body.appendChild(tooltip);
              
              setTimeout(() => {
                tooltip.style.transition = 'opacity 0.3s';
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
              }, 1500);
            }
          }
          break;
        }
        target = target.parentElement;
      }
    });

    // Drag and drop for images
    editor.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fef3c7';
    });

    editor.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fff';
    });

    editor.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fff';
      
      const files = e.dataTransfer.files;
      if (files.length === 0) return;
      
      // Get drop position
      let range;
      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(e.clientX, e.clientY);
      } else if (e.rangeParent) {
        range = document.createRange();
        range.setStart(e.rangeParent, e.rangeOffset);
      }
      
      // Process each dropped file
      Array.from(files).forEach(file => {
        if (file.type.startsWith('image/')) {
          console.log('Image dropped:', file.name);
          
          // Create FileReader to get base64 for preview
          const reader = new FileReader();
          reader.onload = (event) => {
            const base64 = event.target.result;
            const fileName = file.name;
            
            console.log('Image loaded, creating element...');
            
            // Create img element with base64 for preview
            const img = document.createElement('img');
            img.src = base64;
            img.alt = fileName.replace(/\.[^.]+$/, ''); // Remove extension for alt
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            
            // Store the relative path in data attribute
            img.setAttribute('data-original-src', 'assets/' + fileName);
            
            // Insert at drop position
            if (range) {
              range.insertNode(img);
              
              // Add a line break after image
              const br = document.createElement('br');
              range.setStartAfter(img);
              range.insertNode(br);
              
              // Move cursor after br
              range.setStartAfter(br);
              range.collapse(true);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            } else {
              // Fallback: append to editor
              editor.appendChild(img);
              editor.appendChild(document.createElement('br'));
            }
            
            saveToHistory();
            console.log('Image inserted successfully');
            
            // Show notification
            const notification = document.createElement('div');
            notification.textContent = `‚úì Image added: assets/${fileName}`;
            notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px; max-width: 400px;';
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.style.transition = 'opacity 0.3s';
              notification.style.opacity = '0';
              setTimeout(() => notification.remove(), 300);
            }, 3000);
          };
          reader.readAsDataURL(file);
        }
      });
    });

    // Prevent default drag & drop behavior on the whole page
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    // Escape HTML special characters
    function escapeHtml(text) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, m => map[m]);
    }

    // HTML to Markdown conversion
    function htmlToMarkdown(html) {
      let markdown = '';
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + html + '</div>', 'text/html');
      
      const processNode = (node) => {
        if (node.nodeType === 3) {
          // Text node
          return node.textContent;
        } else if (node.nodeType === 1) {
          const tag = node.tagName.toLowerCase();
          
          if (tag === 'h1') {
            return '# ' + processChildren(node) + '\n';
          } else if (tag === 'h2') {
            return '## ' + processChildren(node) + '\n';
          } else if (tag === 'h3') {
            return '### ' + processChildren(node) + '\n';
          } else if (tag === 'h4') {
            return '#### ' + processChildren(node) + '\n';
          } else if (tag === 'p') {
            return processChildren(node) + '\n';
          } else if (tag === 'strong' || tag === 'b') {
            return '**' + processChildren(node) + '**';
          } else if (tag === 'em' || tag === 'i') {
            return '*' + processChildren(node) + '*';
          } else if (tag === 'u') {
            return '__' + processChildren(node) + '__';
          } else if (tag === 'code') {
            return '`' + processChildren(node) + '`';
          } else if (tag === 'a') {
            return '[' + processChildren(node) + '](' + (node.href || '#') + ')';
          } else if (tag === 'img') {
            // ALWAYS use data-original-src for relative path (e.g., assets/image.png)
            // Never use the absolute src attribute which may contain file:// or http://
            const src = node.getAttribute('data-original-src') || '';
            const alt = node.getAttribute('alt') || '';
            // Skip if no original source (broken image)
            if (!src) return '';
            return '![' + alt + '](' + src + ')';
          } else if (tag === 'blockquote') {
            return '> ' + processChildren(node).trim() + '\n';
          } else if (tag === 'ul') {
            let items = '';
            node.querySelectorAll(':scope > li').forEach(li => {
              // Get only direct text content, excluding nested lists
              let textContent = '';
              for (let child of li.childNodes) {
                if (child.nodeType === 3) {
                  textContent += child.textContent;
                } else if (child.nodeType === 1) {
                  const childTag = child.tagName.toLowerCase();
                  if (childTag !== 'ul' && childTag !== 'ol') {
                    textContent += processNode(child);
                  }
                }
              }
              items += '- ' + textContent.trim() + '\n';
              
              // Process nested lists with indent
              const nestedUl = li.querySelector(':scope > ul');
              const nestedOl = li.querySelector(':scope > ol');
              if (nestedUl) {
                const nestedItems = processNode(nestedUl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
              if (nestedOl) {
                const nestedItems = processNode(nestedOl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
            });
            return items;
          } else if (tag === 'ol') {
            let items = '';
            let counter = 1;
            node.querySelectorAll(':scope > li').forEach(li => {
              // Get only direct text content, excluding nested lists
              let textContent = '';
              for (let child of li.childNodes) {
                if (child.nodeType === 3) {
                  textContent += child.textContent;
                } else if (child.nodeType === 1) {
                  const childTag = child.tagName.toLowerCase();
                  if (childTag !== 'ul' && childTag !== 'ol') {
                    textContent += processNode(child);
                  }
                }
              }
              items += counter + '. ' + textContent.trim() + '\n';
              counter++;
              
              // Process nested lists with indent
              const nestedUl = li.querySelector(':scope > ul');
              const nestedOl = li.querySelector(':scope > ol');
              if (nestedUl) {
                const nestedItems = processNode(nestedUl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
              if (nestedOl) {
                const nestedItems = processNode(nestedOl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
            });
            return items;
          } else if (tag === 'hr') {
            return '---\n';
          } else if (tag === 'table') {
            return processTable(node) + '\n';
          } else if (tag === 'br') {
            return '\n';
          } else if (tag === 'pre') {
            return '```\n' + node.textContent + '\n```\n';
          } else {
            return processChildren(node);
          }
        }
        return '';
      };
      
      const processChildren = (node) => {
        let result = '';
        for (let child of node.childNodes) {
          result += processNode(child);
        }
        return result;
      };
      
      const processTable = (table) => {
        let markdown = '';
        const rows = table.querySelectorAll('tr');
        
        rows.forEach((row, rowIdx) => {
          const cells = row.querySelectorAll('td, th');
          markdown += '| ';
          cells.forEach(cell => {
            // Process cell content and replace newlines with <br>
            let cellContent = processChildren(cell).replace(/\n/g, '<br>').trim();
            markdown += cellContent + ' | ';
          });
          markdown += '\n';
          
          if (rowIdx === 0) {
            markdown += '| ';
            for (let i = 0; i < cells.length; i++) {
              markdown += '--- | ';
            }
            markdown += '\n';
          }
        });
        
        return markdown;
      };
      
      markdown = processChildren(doc.querySelector('div'));
      
      // Clean up multiple consecutive newlines and trim
      return markdown.replace(/\n\n+/g, '\n').trim();
    }

    // Markdown to HTML conversion with proper nested lists
    function markdownToHtml(markdown) {
      let html = '';
      const lines = markdown.split(/\r?\n/);
      let i = 0;
      let iterations = 0;
      const MAX_ITERATIONS = 10000; // Safety limit
      
      while (i < lines.length && iterations < MAX_ITERATIONS) {
        iterations++;
        const line = lines[i];
        
        // Skip empty lines
        if (!line.trim()) {
          i++;
          continue;
        }
        
        // Headings
        if (line.startsWith('#### ')) {
          html += '<h4>' + applyInlineFormatting(line.substring(5)) + '</h4>';
          i++;
        } else if (line.startsWith('### ')) {
          html += '<h3>' + applyInlineFormatting(line.substring(4)) + '</h3>';
          i++;
        } else if (line.startsWith('## ')) {
          html += '<h2>' + applyInlineFormatting(line.substring(3)) + '</h2>';
          i++;
        } else if (line.startsWith('# ')) {
          html += '<h1>' + applyInlineFormatting(line.substring(2)) + '</h1>';
          i++;
        }
        // Blockquote
        else if (line.startsWith('> ')) {
          html += '<blockquote>' + applyInlineFormatting(line.substring(2)) + '</blockquote>';
          i++;
        }
        // Horizontal rule
        else if (line.trim() === '---' || line.trim() === '***' || line.trim() === '___') {
          html += '<hr>';
          i++;
        }
        // Lists - use processListBlock for proper nesting
        else if (line.match(/^\s*[-*]\s+/) || line.match(/^\s*\d+\.\s+/)) {
          const oldI = i;
          const listResult = processListBlock(lines, i);
          html += listResult.html;
          i = listResult.nextIndex;
          
          // Safety check: make sure i moved forward
          if (i <= oldI) {
            console.error('processListBlock did not advance! Breaking to prevent infinite loop.');
            i = oldI + 1; // Force advance
          }
        }
        // Tables
        else if (line.includes('|')) {
          let tableHtml = '<table><tbody>';
          let tableIterations = 0;
          while (i < lines.length && lines[i].includes('|') && tableIterations < 1000) {
            tableIterations++;
            const cells = lines[i].split('|').map(c => c.trim()).filter(c => c && !c.match(/^:?-+:?$/));
            if (cells.length > 0) {
              tableHtml += '<tr>';
              cells.forEach(cell => {
                tableHtml += '<td>' + applyInlineFormatting(cell) + '</td>';
              });
              tableHtml += '</tr>';
            }
            i++;
          }
          tableHtml += '</tbody></table>';
          html += tableHtml;
        }
        // Paragraphs
        else {
          html += '<p>' + applyInlineFormatting(line) + '</p>';
          i++;
        }
      }
      
      if (iterations >= MAX_ITERATIONS) {
        console.error('markdownToHtml: MAX_ITERATIONS reached! Returning partial HTML.');
      }
      
      return html;
    }
    
    // Process a block of list lines and create proper nested HTML
    function processListBlock(lines, startIndex) {
      let i = startIndex;
      let html = '';
      const stack = []; // Track open tags: [{tag: 'ul', level: 0}, ...]
      let iterations = 0;
      const MAX_ITERATIONS = 1000; // Safety limit
      
      console.log('processListBlock called at line', startIndex, 'content:', lines[startIndex]);
      console.log('First 10 chars as code points:', Array.from(lines[startIndex].substring(0, 10)).map(c => c.charCodeAt(0)));
      
      while (i < lines.length && iterations < MAX_ITERATIONS) {
        iterations++;
        const line = lines[i];
        // Match list items - allow empty content after marker
        const match = line.match(/^(\s*)([-*]|\d+\.)\s+(.*)$/);
        
        if (!match) {
          console.log('Line', i, 'does not match list pattern, breaking. Line:', line);
          console.log('Line char codes:', Array.from(line.substring(0, 20)).map(c => `${c}=${c.charCodeAt(0)}`).join(' '));
          break;
        }
        
        const indent = match[1].length;
        const level = Math.floor(indent / 2); // 2 spaces = 1 level
        const marker = match[2];
        const content = match[3];
        const tag = /^\d+\.$/.test(marker) ? 'ol' : 'ul';
        
        console.log('Processing list item:', {line: i, indent, level, marker, tag, content});
        
        // Close deeper levels
        while (stack.length > 0 && stack[stack.length - 1].level > level) {
          const last = stack.pop();
          html += '</' + last.tag + '></li>';
          console.log('Closed deeper level:', last);
        }
        
        // Close same level if different tag type
        if (stack.length > 0 && stack[stack.length - 1].level === level && stack[stack.length - 1].tag !== tag) {
          const last = stack.pop();
          html += '</' + last.tag + '>';
          stack.push({ tag, level });
          html += '<' + tag + '>';
          console.log('Changed tag type from', last.tag, 'to', tag);
        }
        
        // Open new level if needed
        if (stack.length === 0 || stack[stack.length - 1].level < level) {
          stack.push({ tag, level });
          html += '<' + tag + '>';
          console.log('Opened new level:', tag, 'at level', level);
        }
        
        // Add list item
        html += '<li>' + applyInlineFormatting(content);
        
        // Peek at next line
        const nextLine = i + 1 < lines.length ? lines[i + 1] : null;
        const nextMatch = nextLine ? nextLine.match(/^(\s*)([-*]|\d+\.)\s/) : null;
        const nextLevel = nextMatch ? Math.floor(nextMatch[1].length / 2) : -1;
        
        console.log('Next level:', nextLevel, 'current level:', level);
        
        // Close </li> only if next item is not deeper
        if (nextLevel <= level) {
          html += '</li>';
          console.log('Closed </li>');
        }
        
        i++;
      }
      
      if (iterations >= MAX_ITERATIONS) {
        console.error('processListBlock: MAX_ITERATIONS reached! Possible infinite loop prevented.');
      }
      
      // Close all remaining tags
      console.log('Closing remaining tags, stack length:', stack.length);
      while (stack.length > 0) {
        const last = stack.pop();
        html += '</' + last.tag + '>';
        if (stack.length > 0) html += '</li>';
        console.log('Closed tag:', last.tag);
      }
      
      console.log('processListBlock result:', html);
      
      return { html, nextIndex: i };
    }

    // Apply inline formatting (bold, italic, code, links, images)
    function applyInlineFormatting(text) {
      // Images must be processed before links
      text = text.replace(/!\[(.*?)\]\((.*?)\)/g, (match, alt, src) => {
        // If we have a base path and src is relative, create absolute path for display
        if (globalImageBasePath && !src.startsWith('http://') && !src.startsWith('https://') && !src.startsWith('data:') && !src.startsWith('file://')) {
          const absoluteSrc = globalImageBasePath + src;
          return `<img src="${absoluteSrc}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
        }
        // Always preserve the original src in data-original-src
        return `<img src="${src}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
      });
      text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/__(.*?)__/g, '<u>$1</u>');
      text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
      text = text.replace(/`(.*?)`/g, '<code>$1</code>');
      text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
      // Handle <br> tags
      text = text.replace(/<br\s*\/?>/gi, '<br>');
      return text;
    }

    // Load saved content from localStorage OR from URL parameter
    window.addEventListener('load', () => {
      // Check if there's a path parameter (coming from md-viewer)
      const urlParams = new URLSearchParams(window.location.search);
      const filePath = urlParams.get('path');
      const loadFromHash = urlParams.get('loadFromHash');
      
      if (loadFromHash === 'true' && window.location.hash) {
        // Load from URL hash (content passed from index.html)
        try {
          const markdownContent = decodeURIComponent(window.location.hash.substring(1));
          
          // Set global base path for images
          if (filePath) {
            const basePath = filePath.substring(0, filePath.lastIndexOf('/') + 1);
            
            // For file:// protocol, construct path differently
            if (window.location.protocol === 'file:') {
              // Get the directory of the current HTML file
              const currentPath = window.location.pathname;
              const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
              globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
            } else {
              // For http:// or https://
              const currentOrigin = window.location.origin;
              globalImageBasePath = currentOrigin + '/' + basePath;
            }
            
            console.log('Global Image Base Path:', globalImageBasePath);
          }
          
          // Convert markdown to HTML (now with absolute image paths built-in)
          isLoadingFile = true;
          const html = markdownToHtml(markdownContent);
          editor.innerHTML = html;
          setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
          
          history = [editor.innerHTML];
          historyIndex = 0;
          
          // Update page title
          if (filePath) {
            const fileName = filePath.split('/').pop();
            document.title = fileName.replace(/\.(md|txt)$/i, '').replace(/^\d+-/, '').replace(/^msg-/i, '') + ' ‚Äî Markdown Editor';
          }
          
          // Clear URL parameters to prevent auto-reload on refresh
          window.history.replaceState({}, document.title, window.location.pathname);
        } catch (err) {
          alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ: ' + err.message);
          console.error('Load error:', err);
        }
      } else if (filePath) {
        // Original fetch-based loading (kept for backward compatibility)
        const decodedPath = decodeURIComponent(filePath);
        const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
        const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
          ? new URL(encodedPath, window.location.origin).href
          : encodedPath;
        
        // Load file from path
        fetch(absoluteUrl)
          .then(r => {
            if (!r.ok) throw new Error('HTTP ' + r.status);
            return r.text();
          })
          .then(markdown => {
            // Convert markdown to HTML
            isLoadingFile = true;
            const html = markdownToHtml(markdown);
            editor.innerHTML = html;
            setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
            history = [html];
            historyIndex = 0;
            
            // Update page title
            const fileName = decodedPath.split('/').pop();
            document.title = fileName.replace(/\.(md|txt)$/i, '') + ' ‚Äî Markdown Editor';
          })
          .catch(err => {
            const isFile = window.location.protocol === 'file:';
            const hint = isFile
              ? '\n\n–°—ä–≤–µ—Ç: –û—Ç–≤–æ—Ä–∏ —Å–∞–π—Ç–∞ –ø—Ä–µ–∑ –ª–æ–∫–∞–ª–µ–Ω HTTP —Å—ä—Ä–≤—ä—Ä (–Ω–∞–ø—Ä. VS Code Live Server), —Ç—ä–π –∫–∞—Ç–æ –±—Ä–∞—É–∑—ä—Ä–∏—Ç–µ –±–ª–æ–∫–∏—Ä–∞—Ç fetch –æ—Ç file://'
              : '';
            alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ñ–∞–π–ª–∞: ' + err.message + hint);
            console.error('Load error:', err);
          });
      } else {
        // Load from localStorage if no path parameter
        const saved = localStorage.getItem('mdEditorContent');
        if (saved) {
          editor.innerHTML = saved;
          history = [saved];
          historyIndex = 0;
        }
      }
    });

    // Auto-save to localStorage (only when user is actually editing, not loading files)
    editor.addEventListener('input', () => {
      if (isLoadingFile) return; // Don't save during file load
      
      clearTimeout(editor.saveTimeout);
      editor.saveTimeout = setTimeout(() => {
        localStorage.setItem('mdEditorContent', editor.innerHTML);
      }, 2000);
    });
  </script>
</body>
</html>
