<!DOCTYPE html>
<html lang="en">
<head>
  <script src="js/auth-guard.js?v=202601314pk"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Markdown Editor - WYSIWYG</title>
  <!-- Favicon -->
  <link rel="icon" href="favicon.svg?v=7" type="image/svg+xml">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Open Sans', Arial, sans-serif;
      background: #fafafa;
      display: flex;
      flex-direction: column;
    }

    /* SuperDoc-inspired Minimal Toolbar */
    .toolbar {
      position: sticky;
      top: 0;
      z-index: 100;
      background: #ffffff;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 16px;
      display: flex;
      gap: 0;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    .toolbar-group {
      display: flex;
      gap: 0;
      align-items: center;
      padding: 0;
      background: transparent;
      border-radius: 0;
      border: none;
      border-right: 1px solid #e0e0e0;
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar-group:hover {
      background: transparent;
      border-color: #e0e0e0;
    }

    .toolbar button {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4a4a4a;
      border-radius: 0;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 400;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      position: relative;
      overflow: hidden;
      height: 36px;
      min-width: 36px;
    }

    .toolbar button img {
      width: 21px;
      height: 21px;
      stroke-width: 1.5;
      flex-shrink: 0;
    }

    /* UpToDate icon - larger size only */
    #uptodateBtn img {
      width: 29px;
      height: 29px;
    }

      #shortcutsBtn img {
      width: 23px;
      height: 23px;
    }

     #ulBtn img {
      width: 23px;
      height: 23px;
    }

     #olBtn img {
      width: 24px;
      height: 24px;
    }

    .toolbar button::before {
      display: none;
    }

    .toolbar button:hover {
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .toolbar button:active {
      background: #ececec;
    }

    .toolbar button.active {
      background: #e8e8e8;
      color: #1a1a1a;
      font-weight: 500;
    }

    .toolbar-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
    }

    /* Table options dropdown menu */
    .table-options-menu {
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      min-width: 220px;
      padding: 6px 0;
    }

    .table-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 0.95em;
      color: #4a4a4a;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.15s ease;
    }

    .table-menu-item:hover {
      background-color: #f0f0f0;
      color: #1a1a1a;
    }

    .table-options-trigger {
      padding: 8px 6px !important;
      min-width: 32px;
      font-size: 16px;
    }

    .toolbar select {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4a4a4a;
      border-radius: 0;
      cursor: pointer;
      font-size: 0.95em;
      font-family: 'Open Sans', Arial, sans-serif;
      font-weight: 400;
      transition: all 0.15s ease;
      height: 36px;
    }

    .toolbar select:hover {
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .toolbar select {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4b5563;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      font-family: 'Open Sans', Arial, sans-serif;
      font-weight: 500;
      transition: all 0.2s;
    }

    .toolbar select:hover {
      background: rgba(146, 64, 14, 0.08);
      color: #92400e;
    }

    /* Main editor container */
    .editor-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* Editor area */
    #editor {
      flex: 1;
      padding: 12px 200px;
      font-size: 16px;
      font-family: 'Open Sans', Arial, sans-serif;
      outline: none;
      overflow-y: auto;
      background: #fff;
      color: #1f2937;
      line-height: 1.6;
      word-wrap: break-word;
      -webkit-user-select: text;
      user-select: text;
    }

    #editor:focus {
      outline: none;
    }

    /* Markdown content styling to match index.html */
    #editor h1,
    #editor h2,
    #editor h3,
    #editor h4 {
      color: #92400e;
      margin-top: 0.8em;
      margin-bottom: 0.15em;
      font-weight: 600;
    }

    #editor h1 { font-size: 1.5em; color: #000000; }
    #editor h2 { font-size: 1.3em; color: #000000; }
    #editor h3 { font-size: 1.1em; color: #000000; margin-bottom: 0.1em; }
    #editor h4 { font-size: 1.05em; color: #000000; margin-bottom: 0.1em; }

    #editor p {
      margin: 0.3em 0;
      white-space: pre-wrap;
    }

    /* CRITICAL: Fix for list formatting - prevent <p> tags from breaking lists */
    #editor ul, #editor ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
      list-style-position: outside;
    }

    #editor li {
      margin: 0.2em 0;
      padding: 0;
      display: list-item;
    }

    /* Remove <p> tags inside list items - they should not exist */
    #editor li p {
      margin: 0;
      padding: 0;
      display: inline;
    }

    /* Prevent nested list paragraph issues */
    #editor li > ul,
    #editor li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }

    /* Ensure list structure is clean */
    #editor ul ul, #editor ul ol,
    #editor ol ul, #editor ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }
    }
    }

    /* Reduce space between paragraph and following list */
    #editor p + ul,
    #editor p + ol {
      margin-top: -0.5em;
    }

    /* Reduce space between heading and following content */
    #editor h1 + p,
    #editor h2 + p,
    #editor h3 + p,
    #editor h4 + p,
    #editor h1 + ul,
    #editor h2 + ul,
    #editor h3 + ul,
    #editor h4 + ul,
    #editor h1 + ol,
    #editor h2 + ol,
    #editor h3 + ol,
    #editor h4 + ol {
      margin-top: 0.1em;
    }

    /* Reduce space between h3 and h4 */
    #editor h3 + h4 {
      margin-top: 0.3em;
    }

    #editor ul,
    #editor ol {
      margin: 0.3em 0;
      padding-left: 1.5em;
    }

    #editor li {
      margin: 0.15em 0;
    }

    #editor ul ul {
      list-style-type: circle;
    }

    #editor ul ul ul {
      list-style-type: square;
    }

    #editor strong {
      font-weight: 600;
    }

    #editor em {
      font-style: italic;
    }

    #editor code {
      background: rgba(146, 64, 14, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    #editor pre {
      background: rgba(255, 255, 255, 0.5);
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
      font-family: 'Courier New', monospace;
    }

    #editor pre code {
      background: none;
      padding: 0;
    }

    #editor blockquote {
      border-left: 3px solid #f59e0b;
      padding-left: 1em;
      margin: 0.5em 0;
      font-style: italic;
      color: #78350f;
    }

    #editor a {
      color: #f59e0b;
      text-decoration: underline;
      cursor: pointer;
    }

    #editor a:hover {
      color: #d97706;
    }

    .heading-color-btn {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .heading-color-btn:hover:not(.active) {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .heading-color-btn.active {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .heading-color-btn.active:hover {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .heading-color-btn:focus,
    .heading-color-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3) !important;
      transform: scale(1.05) !important;
    }

    .text-color-btn {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .text-color-btn:hover:not(.active) {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .text-color-btn.active {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .text-color-btn.active:hover {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .text-color-btn:focus,
    .text-color-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3) !important;
      transform: scale(1.05) !important;
    }

    .highlight-color-btn {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .highlight-color-btn:hover:not(.active) {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .highlight-color-btn.active {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .highlight-color-btn.active:hover {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .highlight-color-btn:focus,
    .highlight-color-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3) !important;
      transform: scale(1.05) !important;
    }

    #editor table {
      border-collapse: collapse;
      margin: 0.75em 0;
      width: 100%;
      table-layout: auto;
    }

    #editor th,
    #editor td {
      border: 1px solid rgba(146, 64, 14, 0.35);
      padding: 6px 10px;
      text-align: left;
      vertical-align: top;
      height: 24px;
      line-height: 1.2;
    }

    #editor thead th {
      background: rgba(196, 127, 9, 0.08);
      font-weight: 600;
    }

    #editor tbody tr:nth-child(odd) {
      background: rgba(146, 64, 14, 0.03);
    }

    /* Raw code modal */
    .raw-code-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #92400e;
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 1.2em;
      transition: all 0.3s;
      z-index: 200;
    }

    .raw-code-btn:hover {
      background: #b8520d;
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
      transform: scale(1.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 300;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 8px;
      width: 100%;
      max-width: 1400px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 25px rgba(0,0,0,0.15);
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      margin: 0;
      color: #1f2937;
      font-size: 1.2em;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: #6b7280;
    }

    .modal-close:hover {
      color: #1f2937;
    }

    .modal-body {
      flex: 1;
      overflow: auto;
      padding: 16px 20px;
    }

    .raw-code {
      width: 100%;
      min-height: 300px;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      resize: vertical;
      line-height: 1.5;
    }

    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-footer button {
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      background: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s;
    }

    .modal-footer button:hover {
      background: #f3f4f6;
    }

    .modal-footer button.primary {
      background: #92400e;
      color: #fff;
      border-color: #92400e;
    }

    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* File list styles */
    .file-item {
      padding: 12px 16px;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .file-item:hover {
      background: #fef3c7;
    }

    .file-item[data-type="markdown"] {
      background: #fef8f0;
    }

    .file-item[data-type="html"] {
      background: #f5f3ff;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-item-name {
      font-weight: 500;
      color: #1f2937;
      font-size: 0.95em;
    }

    .file-item-path {
      font-size: 0.85em;
      color: #6b7280;
    }

    .file-item.hidden {
      display: none;
    }

    /* Course group header */
    .course-header {
      padding: 10px 16px;
      background: #f59e0b;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      position: sticky;
      top: 0;
      z-index: 1;
      border-bottom: 2px solid #d97706;
    }

    .course-header.hidden {
      display: none;
    }

    .file-item.hidden {
      display: none;
    }
    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* Keyboard shortcuts hint */
    .shortcuts-hint {
      padding: 8px 12px;
      background: #fef3c7;
      border: 1px solid #fcd34d;
      border-radius: 4px;
      font-size: 0.85em;
      color: #78350f;
      margin-left: auto;
    }

    /* Table context menu */
    .table-context-menu {
      position: fixed;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 4px 0;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .table-context-menu.active {
      display: block;
    }

    .table-context-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      border: none;
      background: white;
      color: #1f2937;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
    }

    .table-context-menu button:hover {
      background: #f3f4f6;
    }

    .table-context-menu button:first-child {
      border-radius: 6px 6px 0 0;
    }

    .table-context-menu button:last-child {
      border-radius: 0 0 6px 6px;
    }

    /* Table resize functionality */
    #editor table {
      border-collapse: collapse;
      margin: 10px 0;
      position: relative;
    }

    #editor table td,
    #editor table th {
      border: 1px solid #ccc;
      padding: 8px;
      min-width: 50px;
      position: relative;
    }

    #editor table td:after,
    #editor table th:after {
      content: '';
      position: absolute;
      top: 0;
      right: -4px;
      width: 8px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }

    #editor table td:hover:after,
    #editor table th:hover:after {
      background: rgba(66, 165, 245, 0.3);
    }

    /* Table cell focus/selection indicator */
    #editor table td:focus,
    #editor table th:focus {
      outline: 2px solid #7c3aed;
      outline-offset: -2px;
      background: rgba(124, 58, 237, 0.05);
    }

    /* Table row hover effect */
    #editor table tr:hover {
      background: rgba(124, 58, 237, 0.03);
    }

    /* Row/column hover indicators */
    #editor table {
      --hover-row: -1;
      --hover-col: -1;
    }

    /* Table row positioning */
    #editor table tr {
      position: relative;
    }

    @media (max-width: 768px) {
      .toolbar {
        padding: 8px 12px;
      }

      .toolbar button {
        padding: 5px 8px;
        font-size: 0.85em;
      }

      .shortcuts-hint {
        display: none;
      }

      #editor {
        padding: 16px;
      }

      .raw-code-btn {
        width: 45px;
        height: 45px;
        bottom: 15px;
        right: 15px;
      }

      /* Mobile font sizes for viewer */
      #editor h1 {
        font-size: 1.5em;
      }

      #editor h2 {
        font-size: 1.3em;
      }

      #editor h3 {
        font-size: 1.1em;
      }

      #editor h4 {
        font-size: 1em;
      }

      #editor h5,
      #editor h6 {
        font-size: 0.95em;
      }

      #editor p,
      #editor li,
      #editor div {
        font-size: 0.9em;
        line-height: 1.4;
      }

      #editor code {
        font-size: 0.8em;
      }

      #editor blockquote {
        font-size: 0.9em;
      }

      #editor table {
        font-size: 0.85em;
      }
    }

    /* HTML Editor Modal Styles */
    #htmlEditorModal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .html-editor-container {
      background-color: white;
      margin: 30px auto;
      padding: 20px;
      border: 1px solid #888;
      border-radius: 8px;
      width: 95%;
      max-width: 1200px;
      height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .html-editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 10px;
    }

    .html-editor-header h2 {
      margin: 0;
      color: #1f2937;
      font-size: 1.3em;
    }

    .html-editor-actions {
      display: flex;
      gap: 10px;
    }

    #htmlEditorTextarea {
      flex: 1;
      padding: 15px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      resize: none;
      color: #1f2937;
      background: #fafafa;
      white-space: pre;
      overflow-wrap: normal;
      overflow: auto;
    }

    #htmlEditorTextarea:focus {
      outline: none;
      border-color: #3b82f6;
      background: white;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .html-editor-button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s;
    }

    .html-editor-save {
      background-color: #10b981;
      color: white;
    }

    .html-editor-save:hover {
      background-color: #059669;
    }

    .html-editor-close {
      background-color: #ef4444;
      color: white;
    }

    .html-editor-close:hover {
      background-color: #dc2626;
    }

  </style>
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolbar-group" style="position: relative; display: inline-block;">
      <button id="formatToggleBtn" title="Format"><img src="svg/md-editor/icon-format.svg" alt="Format" class="toolbar-icon"></button>
      <div id="formatOptions" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; min-width: 180px;">
        <div class="format-option" data-format="p" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/md-editor/icon-format.svg" alt="Normal" class="toolbar-icon">
          <span>Normal</span>
        </div>
        <div class="format-option" data-format="h1" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/md-editor/icon-h1.svg" alt="H1" class="toolbar-icon">
          <span>Heading 1</span>
        </div>
        <div class="format-option" data-format="h2" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/md-editor/icon-h2.svg" alt="H2" class="toolbar-icon">
          <span>Heading 2</span>
        </div>
        <div class="format-option" data-format="h3" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/md-editor/icon-h3.svg" alt="H3" class="toolbar-icon">
          <span>Heading 3</span>
        </div>
        <div class="format-option" data-format="h4" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/md-editor/icon-h4.svg" alt="H4" class="toolbar-icon">
          <span>Heading 4</span>
        </div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="boldBtn" title="Bold (Ctrl+B)"><img src="svg/md-editor/icon-bold.svg" alt="Bold" class="toolbar-icon"></button>
      <button id="italicBtn" title="Italic (Ctrl+I)"><img src="svg/md-editor/icon-italic.svg" alt="Italic" class="toolbar-icon"></button>
      <button id="underlineBtn" title="Underline (Ctrl+U)"><img src="svg/md-editor/icon-underline.svg" alt="Underline" class="toolbar-icon"></button>
      <button id="strikeBtn" title="Strikethrough"><img src="svg/md-editor/icon-strikethrough.svg" alt="Strikethrough" class="toolbar-icon"></button>
      <button id="subscriptBtn" title="Subscript"><img src="svg/md-editor/icon-subscript.svg" alt="Subscript" class="toolbar-icon"></button>
      <button id="superscriptBtn" title="Superscript"><img src="svg/md-editor/icon-superscript.svg" alt="Superscript" class="toolbar-icon"></button>
      
      <!-- Text Color Button -->
      <div style="position: relative; display: inline-block;">
        <button id="textColorToggleBtn" title="Text Color"><img src="svg/md-editor/icon-text-color.svg" alt="Text Color" class="toolbar-icon"></button>
        <div id="textColorOptions" style="position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px; flex-direction: row; flex-wrap: wrap; max-width: 250px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; gap: 6px; display: none !important; flex: 1;">
          <button class="text-color-btn" data-color="#dd0a0ab7" title="Red" style="background-color: #dd0a0ab7; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#65a30d" title="Green" style="background-color: #65a30d; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#3b82f6" title="Blue" style="background-color: #3b82f6; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#eab308" title="Yellow" style="background-color: #eab308; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#7c2d12" title="Deep Orange" style="background-color: #7c2d12; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#7e22ce" title="Purple" style="background-color: #7e22ce; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#1f2937" title="Dark Gray" style="background-color: #1f2937; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button id="removeColorBtn" title="Remove Color" style="background-color: transparent; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #3b82f6; cursor: pointer; color: #3b82f6; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 16px; padding: 0;">✕</button>
          <input type="color" id="textColorControl" value="#1f2937" style="width: 40px; height: 34px; cursor: pointer; border: none; border-radius: 4px;">
        </div>
      </div>

      <!-- Heading Color Button -->
      <div style="position: relative; display: inline-block;">
        <button id="headingColorToggleBtn" title="Heading Color"><img src="svg/md-editor/icon-heading-clor.svg" alt="Heading Color" class="toolbar-icon"></button>
        <div id="headingColorOptions" style="position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px; flex-direction: row; flex-wrap: wrap; max-width: 250px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; gap: 6px; display: none !important; flex: 1;">
          <button class="heading-color-btn" data-color="#000000" title="Black" style="background-color: #000000; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#1f2937" title="Dark Gray" style="background-color: #1f2937; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#1e40af" title="Deep Blue" style="background-color: #1e40af; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#7c2d12" title="Deep Orange" style="background-color: #7c2d12; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#65a30d" title="Lime Green" style="background-color: #65a30d; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#7e22ce" title="Purple" style="background-color: #7e22ce; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
        </div>
      </div>

      <!-- Highlight Button -->
      <div style="position: relative; display: inline-block;">
        <button id="highlightToggleBtn" title="Highlight (H)"><img src="svg/md-editor/icon-highlight.svg" alt="Highlight" class="toolbar-icon"></button>
        <div id="highlightOptions" style="position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px; flex-direction: row; flex-wrap: wrap; max-width: 250px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; gap: 6px; display: none !important; flex: 1;">
          <button class="highlight-color-btn" data-color="#ffeb3b" title="Yellow" style="background-color: #ffeb3b; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#ff9800" title="Orange" style="background-color: #ff9800; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#f44336" title="Red" style="background-color: #f44336; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#e91e63" title="Pink" style="background-color: #e91e63; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#9c27b0" title="Purple" style="background-color: #9c27b0; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#2196f3" title="Blue" style="background-color: #2196f3; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#00bcd4" title="Cyan" style="background-color: #00bcd4; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="highlight-color-btn" data-color="#4caf50" title="Green" style="background-color: #4caf50; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button id="removeHighlightBtn" title="Remove Highlight" style="background-color: transparent; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #f44336; cursor: pointer; color: #f44336; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 16px; padding: 0;">✕</button>
          <input type="color" id="highlightColorControl" value="#ffeb3b" style="width: 40px; height: 34px; cursor: pointer; border: none; border-radius: 4px;">
        </div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="alignLeftBtn" title="Align Left"><img src="svg/md-editor/icon-align-left.svg" alt="Align Left" class="toolbar-icon"></button>
      <button id="alignCenterBtn" title="Align Center"><img src="svg/md-editor/icon-align-center.svg" alt="Align Center" class="toolbar-icon"></button>
      <button id="alignRightBtn" title="Align Right"><img src="svg/md-editor/icon-align-right.svg" alt="Align Right" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="ulBtn" title="Unordered List (Ctrl+Shift+U)"><img src="svg/md-editor/icon-unordered.svg" alt="Unordered List" class="toolbar-icon"></button>
      <button id="olBtn" title="Ordered List (Ctrl+Shift+O)"><img src="svg/md-editor/icon-ordered.svg" alt="Ordered List" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="outdentBtn" title="Outdent (Shift+Tab)"><img src="svg/md-editor/icon-outdent.svg" alt="Outdent" class="toolbar-icon"></button>
      <button id="indentBtn" title="Indent (Tab)"><img src="svg/md-editor/icon-indent.svg" alt="Indent" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group" style="position: relative;">
      <button id="tableBtn" title="Insert Table"><img src="svg/md-editor/icon-table.svg" alt="Table" class="toolbar-icon"></button>
      <button id="editTableBtn" title="Edit table with Tables Generator"><img src="svg/md-editor/icon-edit-table.svg" alt="Edit Table" class="toolbar-icon"></button>
      <!-- Table Options Dropdown Menu -->
      <div id="tableOptionsMenu" class="table-options-menu" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; min-width: 220px; white-space: nowrap;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableRowBefore(); closeTableMenu();"><img src="svg/md-editor/icon-add.svg"  alt="Table" class="toolbar-icon"> Insert row above</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableRowAfter(); closeTableMenu();"><img src="svg/md-editor/icon-add.svg"  alt="Table" class="toolbar-icon"> Insert row below</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableColumnBefore(); closeTableMenu();"><img src="svg/md-editor/icon-add.svg"  alt="Table" class="toolbar-icon"> Insert column left</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableColumnAfter(); closeTableMenu();"><img src="svg/md-editor/icon-add.svg"  alt="Table" class="toolbar-icon"> Insert column right</div>
      <hr style="margin: 4px 0; border: none; border-top: 1px solid #eee;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTableRow(); closeTableMenu();"><img src="svg/md-editor/icon-deleteTable.svg"  alt="Table" class="toolbar-icon">Remove Table Row</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTableColumn(); closeTableMenu();"><img src="svg/md-editor/icon-deleteTable.svg"  alt="Table" class="toolbar-icon"> Delete column</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTable(); closeTableMenu();"><img src="svg/md-editor/icon-deleteTable.svg"  alt="Table" class="toolbar-icon"> Delete table</div>
      <hr style="margin: 4px 0; border: none; border-top: 1px solid #eee;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); setCellBackgroundColor(); closeTableMenu();"><img src="svg/md-editor/icon-table-colors.svg"  alt="Table" class="toolbar-icon"> Set Cell Background Color</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); mergeTableCells(); closeTableMenu();"><img src="svg/md-editor/icon-cell-merge.svg"  alt="Table" class="toolbar-icon"> Merge cells</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); splitTableCell(); closeTableMenu();"><img src="svg/md-editor/icon-split-cells.svg"  alt="Table" class="toolbar-icon"> Split cell</div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="quoteBtn" title="Quote (Ctrl+Q)"><img src="svg/md-editor/icon-quote.svg" alt="Quote" class="toolbar-icon"></button>
      <button id="checklistBtn" title="Checkbox List"><img src="svg/md-editor/icon-checklist.svg" alt="Checklist" class="toolbar-icon"></button>
      <button id="symbolsBtn" title="Insert Symbols"><img src="svg/md-editor/icon-symbols.svg" alt="Symbols" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">

      <button id="linkBtn" title="Link"><img src="svg/md-editor/icon-link.svg" alt="Bold" class="toolbar-icon"></button>
      <button id="imageBtn" title="Add Image"><img src="svg/md-editor/icon-image.svg" alt="Image" class="toolbar-icon"></button>
      <button id="hrBtn" title="Horizontal Line"><svg width="18" height="18" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32s-14.33-32-32-32H64c-17.67 0-32 14.33-32 32z"/></svg></button>
      <button id="dashedLineBtn" title="Topic Divider (Dashed Line)"><img src="svg/md-editor/icon-dashed-line.svg" alt="Dashed Line" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="undoBtn" title="Undo (Ctrl+Z)"><img src="svg/md-editor/icon-undo.svg" alt="Undo" class="toolbar-icon"></button>
      <button id="redoBtn" title="Redo (Ctrl+Y)"><img src="svg/md-editor/icon-redo.svg" alt="Redo" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="openLocalBtn" title="Open file from computer"><img src="svg/md-editor/icon-open-local.svg" alt="Open Local" class="toolbar-icon"></button>
      <button id="openCoursesBtn" title="Open file from courses"><img src="svg/md-editor/icon-open-courses.svg" alt="Open Courses" class="toolbar-icon"></button>
      <button id="anchorLinkBtn" title="Create/Link Anchors"><img src="svg/md-editor/icon-anchor-link.svg" alt="Anchor Link" class="toolbar-icon"></button>
      <button id="htmlEditorBtn" title="Edit HTML/Source Code"><img src="svg/md-editor/icon-html-editor.svg" alt="HTML Editor" class="toolbar-icon"></button>
      <button id="combineFilesBtn" title="Combine HTML files"><img src="svg/md-editor/icon-combine-files.svg" alt="Combine Files" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="downloadBtn" title="Download as .html file"><img src="svg/md-editor/icon-download.svg" alt="Download" class="toolbar-icon"></button>
      <button id="clearBtn" title="Clear all content"><img src="svg/md-editor/icon-clear.svg" alt="Clear" class="toolbar-icon"></button>
      <button id="shortcutsBtn" title="Show keyboard shortcuts"><img src="svg/md-editor/icon-shortcuts.svg" alt="Shortcuts" class="toolbar-icon"></button>
      <button id="resetFontSizeBtn" title="Reset font size to default"><img src="svg/md-editor/icon-reset-font-size.svg" alt="Reset Font Size" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="geminiBtn" title="Send to Gemini AI"><img src="svg/md-editor/icon-gemini.svg" alt="Gemini" class="toolbar-icon"></button>
      <button id="chatgptBtn" title="Open ChatGPT"><img src="svg/md-editor/icon-chatgpt.svg" alt="ChatGPT" class="toolbar-icon"></button>
      <button id="uptodateBtn" title="Open UpToDate"><img src="svg/md-editor/icon-uptodate.svg" alt="UpToDate" class="toolbar-icon"></button>
    </div>
  </div>

  <!-- Hidden file input for local file opening -->
  <input type="file" id="fileInput" accept=".md,.txt,.html" style="display:none;">

  <!-- Editor -->
  <div class="editor-container">
    <div id="editor" contenteditable="true" spellcheck="false">
      <p>Start typing here...</p>
    </div>
  </div>

  <!-- Table context menu -->
  <div id="tableContextMenu" class="table-context-menu">
    <button id="addRowBefore"><img src="svg/md-editor/icon-add.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Add Row Above</button>
    <button id="addRowAfter"><img src="svg/md-editor/icon-add.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Add Row Below</button>
    <button id="deleteRow"><img src="svg/md-editor/icon-deleteTable.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Delete Row</button>
    <hr style="margin: 4px 0; border: none; border-top: 1px solid #e5e7eb;">
    <button id="addColBefore"><img src="svg/md-editor/icon-add.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Add Column Before</button>
    <button id="addColAfter"><img src="svg/md-editor/icon-add.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Add Column After</button>
    <button id="deleteCol"><img src="svg/md-editor/icon-deleteTable.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Delete Column</button>
    <hr style="margin: 4px 0; border: none; border-top: 1px solid #e5e7eb;">
    <button id="mergeCells"><img src="svg/md-editor/icon-cell-merge.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Merge Cells</button>
    <button id="splitCell"><img src="svg/md-editor/icon-split-cells.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Split Cell</button>
    <button id="setCellBg"><img src="svg/md-editor/icon-table-colors.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Cell Background</button>
    <hr style="margin: 4px 0; border: none; border-top: 1px solid #e5e7eb;">
    <button id="deleteTableCtx"><img src="svg/md-editor/icon-deleteTable.svg" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"> Delete Table</button>
  </div>



  <!-- Shortcuts modal -->
  <div class="modal" id="shortcutsModal">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Keyboard Shortcuts</h2>
        <button class="close-btn" id="closeShortcutsBtn">✕</button>
      </div>
      <div class="modal-body" style="max-height: 500px; overflow-y: auto;">
        <h3>Formatting</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+B</strong> - Bold</li>
          <li style="margin: 8px 0;"><strong>Ctrl+I</strong> - Italic</li>
          <li style="margin: 8px 0;"><strong>Ctrl+`</strong> - Code</li>
          <li style="margin: 8px 0;"><strong>Ctrl+S</strong> - Save/Download file</li>
        </ul>
        <h3>Headings & Paragraphs</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+0</strong> - Normal paragraph</li>
          <li style="margin: 8px 0;"><strong>Ctrl+1</strong> - Heading 1</li>
          <li style="margin: 8px 0;"><strong>Ctrl+2</strong> - Heading 2</li>
          <li style="margin: 8px 0;"><strong>Ctrl+3</strong> - Heading 3</li>
          <li style="margin: 8px 0;"><strong>Ctrl+4</strong> - Heading 4</li>
        </ul>
        <h3>Lists & Blocks</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+G</strong> - Unordered list</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+O</strong> - Ordered list</li>
          <li style="margin: 8px 0;"><strong>Tab</strong> - Indent list item</li>
          <li style="margin: 8px 0;"><strong>Shift+Tab</strong> - Outdent list item</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Q</strong> - Blockquote</li>
          <li style="margin: 8px 0;"><strong>Ctrl+T</strong> - Table</li>
        </ul>
        <h3>Text Color & Styles</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+M</strong> - Apply last text color</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+M</strong> - Remove text color</li>
          <li style="margin: 8px 0;"><strong>Ctrl+D</strong> - Apply last text color</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+D</strong> - Remove text color</li>
          <li style="margin: 8px 0;"><strong>Ctrl+H</strong> - Apply last highlight color</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+H</strong> - Remove highlight</li>
        </ul>
        <h3>Undo/Redo</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+Z</strong> - Undo</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Y</strong> or <strong>Ctrl+Shift+Z</strong> - Redo</li>
        </ul>
      </div>
      <div class="modal-footer">
        <button class="primary" id="closeShortcutsBtn2">Close</button>
      </div>
    </div>
  </div>

  <!-- File Browser Modal -->
  <div id="fileBrowserModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
      <div class="modal-header">
        <h2>Open File from Courses</h2>
        <span class="close" id="closeFileBrowserBtn">&times;</span>
      </div>
      <div class="modal-body" style="max-height: 600px; overflow: hidden; display: flex; flex-direction: column;">
        <div style="margin-bottom: 12px;">
          <input type="text" id="fileSearchInput" placeholder="Search files..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div id="fileListContainer" style="flex: 1; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px;">
          <div id="fileList" style="padding: 0;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="closeFileBrowserBtn2">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Add Image Modal -->
  <div id="imageModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Add Image</h2>
        <span class="close" id="closeImageModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <label for="imageNameInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Image File Name</label>
          <input type="text" id="imageNameInput" placeholder="e.g., photo.png" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
          <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">File must exist in assets/ folder</div>
        </div>
        <div style="margin-bottom: 16px;">
          <label for="imageAltInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Alt Text (Description)</label>
          <input type="text" id="imageAltInput" placeholder="e.g., Brain hemisphere diagram" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="margin-bottom: 16px;">
          <label for="imageSizeInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Image Size (Width)</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="number" id="imageSizeInput" placeholder="e.g., 100" value="100" min="10" max="100" style="width: 80px; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
            <span style="color: #6b7280;">%</span>
            <select id="imageSizePreset" style="padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px; cursor: pointer;">
              <option value="50">Small (50%)</option>
              <option value="75">Medium (75%)</option>
              <option value="100" selected>Full (100%)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">Width as percentage of content</div>
        </div>

      </div>
      <div class="modal-footer">
        <button id="cancelImageBtn">Cancel</button>
        <button class="primary" id="insertImageBtn">Insert Image</button>
      </div>
    </div>
  </div>

  <!-- Save File Modal -->
  <div id="saveFileModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Save Markdown File</h2>
        <span class="close" id="closeSaveModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <label for="fileNumberInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Number</label>
          <input type="text" id="fileNumberInput" placeholder="e.g., 1, 2, 3..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
          <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">Optional: Leave empty if not needed</div>
        </div>
        <div style="margin-bottom: 16px;">
          <label for="fileNameInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Name</label>
          <input type="text" id="fileNameInput" placeholder="e.g., ХОББ, Белодробен карцином" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="padding: 10px; background: #f3f4f6; border-radius: 4px; font-size: 0.9em; color: #4b5563;">
          <strong>Preview:</strong> <span id="fileNamePreview" style="color: #92400e; font-family: monospace;">document.html</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelSaveBtn">Cancel</button>
        <button class="primary" id="confirmSaveBtn">Download</button>
      </div>
    </div>
  </div>

  <!-- Checklist Modal -->
  <div id="checklistModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Create Checkbox List</h2>
        <span class="close" id="closeChecklistModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <label for="checklistCountInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Number of Options</label>
          <input type="number" id="checklistCountInput" placeholder="e.g., 4" value="4" min="1" max="20" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="margin-bottom: 16px;">
          <label for="checklistTextInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Paste Answer Text (one per line)</label>
          <textarea id="checklistTextInput" placeholder="Paste each answer on a new line..." style="width: 100%; height: 120px; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px; font-family: monospace; resize: vertical;"></textarea>
        </div>
        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500; color: #374151;">
            <input type="checkbox" id="checklistHighlightCheckbox" checked style="margin-right: 8px; cursor: pointer;">
            Highlight selected answer in red
          </label>
        </div>
        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500; color: #374151;">
            <input type="checkbox" id="checklistBoldCheckbox" style="margin-right: 8px; cursor: pointer;">
            Bold selected answer
          </label>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelChecklistBtn">Cancel</button>
        <button class="primary" id="confirmChecklistBtn">Insert</button>
      </div>
    </div>
  </div>

  <!-- Table Creation Modal -->
  <div id="tableModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Create Table</h2>
        <span class="close" id="closeTableModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 20px;">
          <label for="tableRowsInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Number of Rows (body rows, not including header)</label>
          <input type="number" id="tableRowsInput" value="3" min="1" max="20" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="margin-bottom: 20px;">
          <label for="tableColsInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Number of Columns</label>
          <input type="number" id="tableColsInput" value="3" min="1" max="20" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelTableBtn">Cancel</button>
        <button class="primary" id="confirmTableBtn">Create Table</button>
      </div>
    </div>
  </div>

  <!-- Merge Cells Modal -->
  <div id="mergeCellsModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h2>Merge Cells</h2>
        <span class="close" id="closeMergeCellsModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 16px; color: #6b7280;">Select merge direction:</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
          <button id="mergeRightBtn" style="padding: 16px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px; background: white; transition: all 0.2s;">
            <div style="font-size: 24px; margin-bottom: 4px;">→</div>
            <div>Merge Right</div>
          </button>
          <button id="mergeDownBtn" style="padding: 16px; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px; background: white; transition: all 0.2s;">
            <div style="font-size: 24px; margin-bottom: 4px;">↓</div>
            <div>Merge Down</div>
          </button>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelMergeBtn">Cancel</button>
      </div>
    </div>
  </div>

  <div id="symbolsModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Insert Symbol</h2>
        <span class="close" id="closeSymbolsModalBtn">&times;</span>
      </div>
      <div class="modal-body" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; max-height: 400px; overflow-y: auto;">
        <button class="symbol-btn" data-symbol="↑" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">↑</button>
        <button class="symbol-btn" data-symbol="↓" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">↓</button>
        <button class="symbol-btn" data-symbol="←" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">←</button>
        <button class="symbol-btn" data-symbol="→" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">→</button>
        <button class="symbol-btn" data-symbol="↔" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">↔</button>
        <button class="symbol-btn" data-symbol="α" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">α</button>
        <button class="symbol-btn" data-symbol="β" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">β</button>
        <button class="symbol-btn" data-symbol="γ" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">γ</button>
        <button class="symbol-btn" data-symbol="δ" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">δ</button>
        <button class="symbol-btn" data-symbol="ε" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">ε</button>
        <button class="symbol-btn" data-symbol="μ" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">μ</button>
        <button class="symbol-btn" data-symbol="≈" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">≈</button>
        <button class="symbol-btn" data-symbol="≠" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">≠</button>
        <button class="symbol-btn" data-symbol="≤" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">≤</button>
        <button class="symbol-btn" data-symbol="≥" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">≥</button>
        <button class="symbol-btn" data-symbol="±" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">±</button>
        <button class="symbol-btn" data-symbol="÷" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">÷</button>
        <button class="symbol-btn" data-symbol="°" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">°</button>
        <button class="symbol-btn" data-symbol="℃" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">℃</button>
        <button class="symbol-btn" data-symbol="‰" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">‰</button>
        <button class="symbol-btn" data-symbol="t½" style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">t½</button>
      </div>
      <div class="modal-footer" style="padding: 12px; border-top: 1px solid #e5e7eb; display: flex; align-items: center;">
        <label style="display: flex; align-items: center; cursor: pointer; flex: 1;">
          <input type="checkbox" id="symbolCopyCheckbox" style="margin-right: 8px; cursor: pointer;">
          Copy to clipboard
        </label>
      </div>
    </div>
  </div>

  <!-- Anchor Link Modal -->
  <div class="modal" id="anchorLinkModal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>🔗 Create/Link Anchors</h2>
        <span class="close" id="closeAnchorLinkModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
          <button id="createAnchorTabBtn" class="anchor-tab-btn active" style="flex: 1; padding: 10px 16px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">Create Anchor</button>
          <button id="linkToAnchorTabBtn" class="anchor-tab-btn" style="flex: 1; padding: 10px 16px; background: #d1d5db; color: #374151; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">Link to Anchor</button>
        </div>

        <!-- Create Anchor Tab -->
        <div id="createAnchorTab" class="anchor-tab-content">
          <div style="margin-bottom: 16px;">
            <label for="anchorIdInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Anchor ID</label>
            <input type="text" id="anchorIdInput" placeholder="e.g., section1, introduction" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
            <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">No spaces, use lowercase and hyphens</div>
          </div>
          <div style="margin-bottom: 16px;">
            <label for="anchorTextInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Anchor Text</label>
            <input type="text" id="anchorTextInput" placeholder="e.g., Topic 1 – Introduction" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
          </div>
          <div style="margin-bottom: 16px;">
            <label for="anchorHeadingTypeInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Heading Type</label>
            <select id="anchorHeadingTypeInput" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
              <option value="h2">Heading 2 (H2)</option>
              <option value="h3">Heading 3 (H3)</option>
              <option value="h4">Heading 4 (H4)</option>
            </select>
          </div>
          <button id="createAnchorBtn" style="width: 100%; padding: 10px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">Create Anchor</button>
        </div>

        <!-- Link to Anchor Tab -->
        <div id="linkToAnchorTab" class="anchor-tab-content" style="display: none;">
          <div style="margin-bottom: 16px;">
            <label for="existingAnchorsSelect" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Select Anchor</label>
            <select id="existingAnchorsSelect" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
              <option value="">-- No anchors found --</option>
            </select>
          </div>
          <div style="margin-bottom: 16px;">
            <label for="linkTextInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">Link Text</label>
            <input type="text" id="linkTextInput" placeholder="Text for the link" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
            <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">Leave empty to use anchor text</div>
          </div>
          <button id="createLinkBtn" style="width: 100%; padding: 10px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">Create Link</button>
        </div>
      </div>
    </div>
  </div>

  <!-- HTML Editor Modal -->
  <div id="htmlEditorModal">
    <div class="html-editor-container">
      <div class="html-editor-header">
        <h2>📄 HTML Source Code Editor</h2>
        <div class="html-editor-actions">
          <button id="htmlEditorSaveBtn" class="html-editor-button html-editor-save">💾 Save & Update</button>
          <button id="htmlEditorCloseBtn" class="html-editor-button html-editor-close">Close</button>
        </div>
      </div>
      <textarea id="htmlEditorTextarea" spellcheck="false" placeholder="HTML Code will appear here..."></textarea>
    </div>
  </div>

  <!-- Combine Files Modal -->
  <div id="combineFilesModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h2>Комбинирай HTML файлове</h2>
        <span class="close" id="closeCombineFilesBtn">&times;</span>
      </div>
      <div class="modal-body">
        <!-- Tabs for combining mode -->
        <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid #e5e7eb;">
          <button id="combineLocalTab" class="combine-tab-btn active" style="padding: 10px 16px; border: none; background: none; cursor: pointer; border-bottom: 2px solid #7c3aed; color: #7c3aed; font-weight: 500;">Локални файлове</button>
          <button id="combineCourseTab" class="combine-tab-btn" style="padding: 10px 16px; border: none; background: none; cursor: pointer; border-bottom: 2px solid transparent; color: #6b7280; font-weight: 500;">От курсове</button>
        </div>

        <!-- Local Files Tab -->
        <div id="combineLocalPanel" class="combine-panel">
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Избери HTML файлове:</label>
            <input type="file" id="combineFilesInput" accept=".html" multiple style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px;">
          </div>
          
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Редослед на файлове:</label>
            <div id="filesList" style="border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb; min-height: 200px; padding: 12px; max-height: 300px; overflow-y: auto;">
              <div style="color: #9ca3af; text-align: center; padding: 20px;">Качи файлове за да ги видиш тук</div>
            </div>
          </div>

          <div style="display: flex; gap: 8px; justify-content: space-between; font-size: 0.85em; color: #6b7280;">
            <div>💡 Можеш да преместваш файловете за да промениш редоследа</div>
          </div>
        </div>

        <!-- Courses Tab -->
        <div id="combineCoursePanel" class="combine-panel" style="display: none;">
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Търси файлове от курсове:</label>
            <input type="text" id="combineFileSearch" placeholder="Търси по име..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px;">
          </div>
          
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Избрани файлове:</label>
            <div id="courseFilesList" style="border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb; min-height: 200px; padding: 12px; max-height: 300px; overflow-y: auto;">
              <div style="color: #9ca3af; text-align: center; padding: 20px;">Избери файлове от курсове</div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="closeCombineFilesBtn2">Отмени</button>
        <button class="primary" id="saveCombineFilesBtn">Комбинирай и вмъкни</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
  <script src="courses.generated.js?v=202601314pk"></script>

  <script>
    const editor = document.getElementById('editor');
    
    // Set up MutationObserver to prevent nested lists
    const preventNestedLists = () => {
      // Find all nested OL/UL elements and flatten them
      const nestedLists = editor.querySelectorAll('ol ol, ol ul, ul ol, ul ul');
      
      nestedLists.forEach(nestedList => {
        const parentLi = nestedList.parentElement;
        if (parentLi && parentLi.tagName === 'LI') {
          const grandparent = parentLi.parentElement;
          
          // Check if parent LI is already indented (has nested list)
          // If it does, don't add more nesting - just remove the new nested list
          
          // Move all items from nested list to after parent LI
          const items = Array.from(nestedList.children);
          items.forEach((item, idx) => {
            const newItem = item.cloneNode(true);
            
            // Remove any nested lists from items to keep them flat
            const childLists = newItem.querySelectorAll('ol, ul');
            childLists.forEach(list => list.remove());
            
            const nextSibling = parentLi.nextElementSibling;
            
            if (nextSibling) {
              grandparent.insertBefore(newItem, nextSibling);
            } else {
              grandparent.appendChild(newItem);
            }
          });
          
          // Remove the nested list
          nestedList.remove();
        }
      });
    };
    
    // Create observer to watch for nested list creation
    const observer = new MutationObserver((mutations) => {
      // Check if any OL or UL elements were added/modified
      let hasListChanges = false;
      
      for (let mutation of mutations) {
        if (mutation.type === 'childList') {
          // Check if ol or ul was added
          for (let node of mutation.addedNodes) {
            if (node.nodeType === 1 && (node.tagName === 'OL' || node.tagName === 'UL')) {
              hasListChanges = true;
              break;
            }
          }
        }
        if (hasListChanges) break;
      }
      
      // If lists were modified, flatten any nested ones
      if (hasListChanges) {
        preventNestedLists();
      }
    });
    
    // Start observing the editor for changes
    observer.observe(editor, {
      childList: true,
      subtree: true,
      attributes: false
    });
    
    const shortcutsBtn = document.getElementById('shortcutsBtn');
    const shortcutsModal = document.getElementById('shortcutsModal');
    const closeShortcutsBtn = document.getElementById('closeShortcutsBtn');
    const closeShortcutsBtn2 = document.getElementById('closeShortcutsBtn2');

    let editorContent = '';
    let rawContent = '';
    let originalHtml = '<p>Start typing here...</p>';
    
    // Global base path for images
    let globalImageBasePath = '';
    
    // Track current file info
    let currentFileInfo = {
      name: '',
      number: '',
      isFromCourses: false
    };
    
    // Flag to prevent auto-save during file loading
    let isLoadingFile = false;

    // History for undo/redo
    let history = ['<p>Start typing here...</p>'];
    let historyIndex = 0;

    // Save current state to history
    function saveToHistory() {
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(editor.innerHTML);
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    // Toolbar functions
    function insertFormat(tag) {
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return;
      
      const range = selection.getRangeAt(0);
      
      // Запази позицијата на курсорот
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(editor);
      preCaretRange.setEnd(range.startContainer, range.startOffset);
      const cursorOffset = preCaretRange.toString().length;
      
      let node = range.commonAncestorContainer;
      
      // Ако е text node, оди до parent
      if (node.nodeType === 3) {
        node = node.parentNode;
      }
      
      // Оди нагоре додека не найдеш блок елемент (p, div, h1-h4)
      while (node && node !== editor) {
        const tagName = node.tagName.toLowerCase();
        if (['h1', 'h2', 'h3', 'h4', 'p', 'div'].includes(tagName)) {
          break;
        }
        node = node.parentNode;
      }
      
      // Проверка дали имаме валиден блок елемент
      if (!node || node === editor) {
        return;
      }
      
      const tagName = node.tagName.toLowerCase();
      if (!['h1', 'h2', 'h3', 'h4', 'p', 'div'].includes(tagName)) {
        return;
      }
      
      // Замена на блок елементот
      const targetTag = (tagName === tag) ? 'p' : tag;
      const newEl = document.createElement(targetTag);
      
      // Копирај детелја
      while (node.firstChild) {
        const child = node.firstChild;
        newEl.appendChild(child);
      }
      
      // Зачувај text-align ако постои
      const oldAlign = node.style.textAlign;
      if (oldAlign) {
        newEl.style.textAlign = oldAlign;
      }
      
      // Замени во DOM
      node.parentNode.replaceChild(newEl, node);
      
      // Врати фокус на иста позиција
      const newRange = document.createRange();
      const sel = window.getSelection();
      
      let charCount = 0;
      let found = false;
      
      function findPosition(n) {
        if (found) return;
        if (n.nodeType === 3) {
          const nextCount = charCount + n.length;
          if (nextCount >= cursorOffset) {
            const offset = cursorOffset - charCount;
            newRange.setStart(n, Math.min(offset, n.length));
            newRange.collapse(true);
            found = true;
            return;
          }
          charCount = nextCount;
        } else {
          for (let child of n.childNodes) {
            findPosition(child);
            if (found) return;
          }
        }
      }
      
      findPosition(newEl);
      
      if (!found) {
        newRange.setStart(newEl, 0);
      }
      
      sel.removeAllRanges();
      sel.addRange(newRange);
    }

    function insertInline(tag) {
      const selection = window.getSelection();
      if (selection.toString().length > 0) {
        if (tag === 'code') {
          document.execCommand('formatBlock', false, 'code');
        } else {
          document.execCommand(tag, false, null);
        }
      }
      saveToHistory();
      editor.focus();
    }

    function insertList(type) {
      if (type === 'ul') {
        document.execCommand('insertUnorderedList', false, null);
      } else {
        document.execCommand('insertOrderedList', false, null);
      }
      saveToHistory();
      editor.focus();
    }

    function insertBlockquote() {
      document.execCommand('formatBlock', false, 'blockquote');
      saveToHistory();
      editor.focus();
    }

    function insertChecklist() {
      const checklistModal = document.getElementById('checklistModal');
      checklistModal.style.display = 'flex';
      document.getElementById('checklistCountInput').focus();
    }

    // Variable to store cursor position when opening table modal
    let savedTableRange = null;

    function insertTable() {
      // CRITICAL: Save current cursor position BEFORE opening modal
      // This must happen before any focus changes
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        savedTableRange = selection.getRangeAt(0).cloneRange();
      } else {
        alert('Please click in the editor first');
        return;
      }
      
      // Open the table modal
      const tableModal = document.getElementById('tableModal');
      tableModal.style.display = 'flex';
      
      // Focus on rows input after a tiny delay to ensure modal is rendered
      setTimeout(() => {
        document.getElementById('tableRowsInput').focus();
      }, 10);
    }

    // Function to actually create the table
    function createTableHTML(rows, cols) {
      let table = '<table><thead><tr>';
      for (let i = 0; i < cols; i++) {
        table += '<th>Header ' + (i + 1) + '</th>';
      }
      table += '</tr></thead><tbody>';
      // rows parameter is the number of body rows (not including header)
      for (let i = 0; i < rows; i++) {
        table += '<tr>';
        for (let j = 0; j < cols; j++) {
          table += '<td> </td>';
        }
        table += '</tr>';
      }
      table += '</tbody></table>';
      return table;
    }

    // Advanced table functions
    function getTableCellFromSelection() {
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return null;
      let node = selection.getRangeAt(0).startContainer;
      while (node && node !== editor) {
        if (node.tagName === 'TD' || node.tagName === 'TH') return node;
        node = node.parentNode;
      }
      return null;
    }

    // Helper to set cursor in a table cell
    function setCursorInTable(table) {
      if (!table) return;
      
      const selection = window.getSelection();
      
      // Use the last saved cell if it's still in this table
      if (lastTableCell && table.contains(lastTableCell)) {
        const range = document.createRange();
        range.setStart(lastTableCell, 0);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        // Otherwise go to first cell
        const firstCell = table.querySelector('td') || table.querySelector('th');
        if (firstCell) {
          const range = document.createRange();
          range.setStart(firstCell, 0);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    }

    // Helper to set cursor in a specific table cell
    function setCursorInCell(cell) {
      if (!cell) return;
      
      const selection = window.getSelection();
      const range = document.createRange();
      
      // Set cursor at the beginning of the cell
      range.selectNodeContents(cell);
      range.collapse(true);
      
      selection.removeAllRanges();
      selection.addRange(range);
      
      // Update last table cell
      lastTableCell = cell;
    }

    function getTableFromCell(cell) {
      let node = cell;
      while (node && node !== editor) {
        if (node.tagName === 'TABLE') return node;
        node = node.parentNode;
      }
      return null;
    }

    function addTableColumnBefore() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
        newCell.textContent = ' ';
        row.insertBefore(newCell, row.cells[colIndex]);
      });
      saveToHistory();
    }

    function addTableColumnAfter() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
        newCell.textContent = ' ';
        row.insertBefore(newCell, row.cells[colIndex + 1]);
      });
      saveToHistory();
    }

    function deleteTableColumn() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        if (row.cells[colIndex]) row.deleteCell(colIndex);
      });
      saveToHistory();
    }

    function addTableRowBefore() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const row = cell.closest('tr');
      const newRow = document.createElement('tr');
      const colCount = table.querySelector('tr').cells.length;
      
      for (let i = 0; i < colCount; i++) {
        newRow.appendChild(document.createElement('td'));
      }
      row.parentNode.insertBefore(newRow, row);
      saveToHistory();
    }

    function addTableRowAfter() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const row = cell.closest('tr');
      const newRow = document.createElement('tr');
      const colCount = table.querySelector('tr').cells.length;
      
      for (let i = 0; i < colCount; i++) {
        newRow.appendChild(document.createElement('td'));
      }
      row.parentNode.insertBefore(newRow, row.nextSibling);
      saveToHistory();
    }

    function deleteTableRow() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const row = cell.closest('tr');
      row.remove();
      saveToHistory();
    }

    function deleteTable() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      table.remove();
      saveToHistory();
    }

    function mergeTableCells() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      
      const row = cell.closest('tr');
      if (!row) return alert('Позиционирай курсора в таблица');
      
      // Get current cell index and next cell
      const cellIndex = cell.cellIndex;
      const nextCell = row.cells[cellIndex + 1];
      
      if (!nextCell) return alert('Нямаш следваща клетка за мърджване');
      
      // Merge content
      cell.textContent = (cell.textContent + ' ' + nextCell.textContent).trim();
      
      // Add colspan if it doesn't exist
      const colspan = parseInt(cell.getAttribute('colspan')) || 1;
      cell.setAttribute('colspan', colspan + 1);
      
      // Remove next cell
      nextCell.remove();
      
      saveToHistory();
    }

    function setCellBackgroundColor() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const color = prompt('Цвят (hex):', '#FAF594');
      if (color) {
        cell.style.backgroundColor = color;
        saveToHistory();
      }
    }

    function splitTableCell() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      
      const colspan = parseInt(cell.getAttribute('colspan')) || 1;
      
      if (colspan <= 1) return alert('Клетката няма colspan за разделяне');
      
      const row = cell.closest('tr');
      const cellIndex = cell.cellIndex;
      
      // Reduce colspan
      cell.setAttribute('colspan', colspan - 1);
      
      // Create new cell
      const newCell = document.createElement(cell.tagName);
      newCell.textContent = ' ';
      
      // Insert new cell after current
      const nextCell = row.cells[cellIndex + 1];
      if (nextCell) {
        row.insertBefore(newCell, nextCell);
      } else {
        row.appendChild(newCell);
      }
      
      saveToHistory();
    }

    function insertLink() {
      const url = prompt('Enter URL:', 'https://');
      const text = window.getSelection().toString() || 'Link';
      if (url) {
        document.execCommand('createLink', false, url);
      }
      saveToHistory();
      editor.focus();
    }

    // Store cursor position for image insertion
    let savedImageRange = null;
    let savedChecklistRange = null;

    function insertImage() {
      // Save current cursor position
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        savedImageRange = selection.getRangeAt(0);
      }
      

      const imageModal = document.getElementById('imageModal');
      imageModal.style.display = 'flex';
      document.getElementById('imageNameInput').focus();
    }

    function insertChecklist() {
      // Save current cursor position BEFORE opening modal
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        savedChecklistRange = selection.getRangeAt(0);
      }
      
      const checklistModal = document.getElementById('checklistModal');
      checklistModal.style.display = 'flex';
      document.getElementById('checklistCountInput').focus();
    }

    function insertHR() {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const hr = document.createElement('hr');
      range.insertNode(hr);
      range.setStartAfter(hr);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
      saveToHistory();
      editor.focus();
    }

    function insertDashedLine() {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      
      // Create <hr> with dashed style
      const hr = document.createElement('hr');
      hr.style.cssText = 'border: none; border-top: 2px dashed #8B6F47;';
      
      range.insertNode(hr);
      range.setStartAfter(hr);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
      
      saveToHistory();
      editor.focus();
    }

    // Toolbar button events
    // Format dropdown toggle
    const formatToggleBtn = document.getElementById('formatToggleBtn');
    if (formatToggleBtn) {
      formatToggleBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const formatOptions = document.getElementById('formatOptions');
        const isHidden = formatOptions.style.display === 'none' || formatOptions.style.display === '';
        formatOptions.style.display = isHidden ? 'block' : 'none';
      });
    }

    // Close format dropdown when clicking outside
    const formatOptions = document.getElementById('formatOptions');
    const formatToggleBtn2 = document.getElementById('formatToggleBtn');
    if (formatOptions && formatToggleBtn2) {
      document.addEventListener('click', (e) => {
        if (!formatOptions.contains(e.target) && !formatToggleBtn2.contains(e.target)) {
          formatOptions.style.display = 'none';
        }
      });
    }

    // Format option selection
    document.querySelectorAll('.format-option').forEach(option => {
      option.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const format = option.dataset.format;
        
        // Use mousedown instead of click to intercept before selection loss
        // Close dropdown immediately
        const formatOptions = document.getElementById('formatOptions');
        if (formatOptions) {
          formatOptions.style.display = 'none';
        }
        
        // Apply format - insertFormat will use current selection from editor
        insertFormat(format);
        saveToHistory();
        
        // Ensure editor stays focused
        editor.focus();
      });
    });

    document.getElementById('boldBtn').addEventListener('click', () => {
      document.execCommand('bold', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('italicBtn').addEventListener('click', () => {
      document.execCommand('italic', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('underlineBtn').addEventListener('click', () => {
      document.execCommand('underline', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('strikeBtn').addEventListener('click', () => {
      document.execCommand('strikethrough', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('subscriptBtn').addEventListener('click', () => {
      document.execCommand('subscript', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('superscriptBtn').addEventListener('click', () => {
      document.execCommand('superscript', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignLeftBtn').addEventListener('click', () => {
      document.execCommand('justifyLeft', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignCenterBtn').addEventListener('click', () => {
      document.execCommand('justifyCenter', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignRightBtn').addEventListener('click', () => {
      document.execCommand('justifyRight', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('indentBtn').addEventListener('click', () => {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      let node = range.startContainer;
      
      // Check if we're in a list item
      while (node && node !== editor) {
        if (node.nodeType === 1 && node.tagName === 'LI') {
          document.execCommand('indent', false, null);
          saveToHistory();
          editor.focus();
          return;
        }
        node = node.parentNode;
      }
      
      // If not in list, show notification
      const notification = document.createElement('div');
      notification.textContent = '⚠️ Indent works only in lists';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #f59e0b; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    document.getElementById('outdentBtn').addEventListener('click', () => {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      let node = range.startContainer;
      
      // Check if we're in a list item
      while (node && node !== editor) {
        if (node.nodeType === 1 && node.tagName === 'LI') {
          document.execCommand('outdent', false, null);
          saveToHistory();
          editor.focus();
          return;
        }
        node = node.parentNode;
      }
      
      // If not in list, show notification
      const notification = document.createElement('div');
      notification.textContent = '⚠️ Outdent works only in lists';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #f59e0b; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    document.getElementById('ulBtn').addEventListener('click', () => {
      insertList('ul');
    });

    document.getElementById('olBtn').addEventListener('click', () => {
      insertList('ol');
    });

    document.getElementById('quoteBtn').addEventListener('click', () => {
      insertBlockquote();
    });

    document.getElementById('checklistBtn').addEventListener('click', () => {
      insertChecklist();
    });

    document.getElementById('symbolsBtn').addEventListener('click', () => {
      const symbolsModal = document.getElementById('symbolsModal');
      symbolsModal.style.display = 'flex';
    });

    document.getElementById('closeSymbolsModalBtn').addEventListener('click', () => {
      document.getElementById('symbolsModal').style.display = 'none';
    });

    // Handle symbol button clicks
    document.querySelectorAll('.symbol-btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        const symbol = this.getAttribute('data-symbol');
        const shouldCopy = document.getElementById('symbolCopyCheckbox').checked;
        
        if (shouldCopy) {
          // Copy to clipboard
          navigator.clipboard.writeText(symbol).then(() => {
            // Optional: show feedback
            console.log('Symbol copied to clipboard: ' + symbol);
          }).catch(() => {
            alert('Failed to copy to clipboard');
          });
        } else {
          // Get cursor position
          const selection = window.getSelection();
          if (selection.rangeCount === 0) {
            alert('Please click in the editor first');
            return;
          }
          
          // Insert symbol at cursor
          document.execCommand('insertText', false, symbol);
          
          saveToHistory();
          editor.focus();
        }
        
        // Close modal
        document.getElementById('symbolsModal').style.display = 'none';
      });
    });

    document.getElementById('editTableBtn').addEventListener('click', () => {
      editor.focus();
      
      const selection = window.getSelection();
      let table = null;
      
      // Try to find the table where cursor is
      if (selection.anchorNode) {
        const node = selection.anchorNode.nodeType === 3 ? selection.anchorNode.parentElement : selection.anchorNode;
        table = node.closest('table');
      }
      
      if (!table && selection.focusNode) {
        const node = selection.focusNode.nodeType === 3 ? selection.focusNode.parentElement : selection.focusNode;
        table = node.closest('table');
      }
      
      if (!table && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const node = range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentElement : range.commonAncestorContainer;
        table = node.closest('table');
      }
      
      if (!table) {
        const tables = editor.querySelectorAll('table');
        if (tables.length > 0) {
          table = tables[0];
        }
      }
      
      if (!table) {
        alert('No table found. Create a table first or click inside a table');
        return;
      }

      // Copy table HTML to clipboard
      const tableHtml = table.outerHTML;
      navigator.clipboard.writeText(tableHtml).then(() => {
        // Open Tables Generator
        alert('Table copied to clipboard!\n\nNow:\n1. Go to tablesgenerator.com\n2. Click "Import" or "Paste" button\n3. Paste your table (Ctrl+V)\n4. Edit it\n5. Copy the HTML\n6. Come back and paste here');
        window.open('https://www.tablesgenerator.com/html_tables', '_blank');
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy table. Please try again');
      });
    });

    // Table buttons
    // Table menu dropdown
    let lastTableContext = null; // Store last table context
    let lastTableCell = null; // Store last selected cell
    
    // Track when cursor enters/leaves table
    editor.addEventListener('click', () => {
      
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        while (node && node !== editor) {
          if (node.tagName === 'TABLE') {
            lastTableContext = node;
            return;
          }
          node = node.parentNode;
        }
      }
      lastTableContext = null;
      lastTableCell = null;
    });
    
    document.getElementById('tableBtn').addEventListener('click', () => {
      insertTable();
    });

    document.getElementById('linkBtn').addEventListener('click', () => {
      insertLink();
    });

    document.getElementById('hrBtn').addEventListener('click', () => {
      insertHR();
    });

    document.getElementById('dashedLineBtn').addEventListener('click', () => {
      insertDashedLine();
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        editor.innerHTML = history[historyIndex];
      }
    });

    document.getElementById('redoBtn').addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        editor.innerHTML = history[historyIndex];
      }
    });

    // Text Color Control - Toggle button
    document.getElementById('textColorToggleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const textColorOptions = document.getElementById('textColorOptions');
      const isHidden = textColorOptions.style.display === 'none' || !textColorOptions.style.display;
      textColorOptions.style.display = isHidden ? 'flex' : 'none';
    });

    // Close text color dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const textColorOptions = document.getElementById('textColorOptions');
      const textColorToggleBtn = document.getElementById('textColorToggleBtn');
      if (!textColorOptions.contains(e.target) && !textColorToggleBtn.contains(e.target)) {
        textColorOptions.style.display = 'none';
      }
    });

    // Text Color Control - Preset buttons
    document.querySelectorAll('.text-color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const color = btn.dataset.color;
        applyFormatting('color', color);
        
        // Update color picker value
        document.getElementById('textColorControl').value = color;
        
        // Update active button
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Close dropdown
        document.getElementById('textColorOptions').style.display = 'none';
        
        // Remove focus to hide hover state
        btn.blur();
      });
    });

    // Text Color Control - Custom color picker
    document.getElementById('textColorControl').addEventListener('input', (e) => {
      const color = e.target.value;
      applyFormatting('color', color);
      
      // Remove active class from preset buttons when using custom color
      document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
    });

    // Remove Color Button
    document.getElementById('removeColorBtn').addEventListener('click', (e) => {
      e.preventDefault();
      const selection = window.getSelection();
      
      // If no selection or selection is in editor
      if (!selection.toString() || !editor.contains(selection.anchorNode)) {
        alert('Моля, избери текст първо');
        return;
      }

      // Remove color by applying default dark gray
      document.execCommand('foreColor', false, 'rgb(31, 41, 55)');
      
      // Close dropdown
      document.getElementById('textColorOptions').style.display = 'none';
      
      // Mark as modified
      saveToHistory();
    });

    // Heading Color Toggle Button
    document.getElementById('headingColorToggleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const headingColorOptions = document.getElementById('headingColorOptions');
      const isHidden = headingColorOptions.style.display === 'none' || headingColorOptions.style.display === '';
      headingColorOptions.style.display = isHidden ? 'flex' : 'none';
    });

    // Close heading color dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const headingColorOptions = document.getElementById('headingColorOptions');
      const headingColorToggleBtn = document.getElementById('headingColorToggleBtn');
      if (headingColorOptions && headingColorToggleBtn && !headingColorOptions.contains(e.target) && !headingColorToggleBtn.contains(e.target)) {
        headingColorOptions.style.display = 'none';
      }
    });

    // Heading Color Control
    document.querySelectorAll('.heading-color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const color = btn.dataset.color;
        
        // Update CSS for all headings with higher specificity
        const style = document.createElement('style');
        style.id = 'heading-color-style';
        const existingStyle = document.getElementById('heading-color-style');
        if (existingStyle) existingStyle.remove();
        
        style.textContent = `
          #editor h1, 
          #editor h2, 
          #editor h3, 
          #editor h4 { 
            color: ${color} !important; 
          }
        `;
        document.head.appendChild(style);
        
        // Also apply directly to existing headers
        const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
        headers.forEach(h => {
          h.style.color = color;
        });
        
        // Update active button
        document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Save to localStorage
        localStorage.setItem('mdEditorHeadingColor', color);
        
        // Close dropdown
        document.getElementById('headingColorOptions').style.display = 'none';
        
        // Remove focus to hide hover state
        btn.blur();
      });
    });

    // Highlight Toggle Button
    document.getElementById('highlightToggleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const highlightOptions = document.getElementById('highlightOptions');
      highlightOptions.style.display = highlightOptions.style.display === 'none' ? 'flex' : 'none';
    });

    // Close highlight dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const highlightOptions = document.getElementById('highlightOptions');
      const highlightToggleBtn = document.getElementById('highlightToggleBtn');
      if (!highlightOptions.contains(e.target) && !highlightToggleBtn.contains(e.target)) {
        highlightOptions.style.display = 'none';
      }
    });

    // Highlight Control - Preset buttons
    document.querySelectorAll('.highlight-color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const color = btn.dataset.color;
        applyFormatting('highlight', color);
        
        // Update color picker value
        document.getElementById('highlightColorControl').value = color;
        
        // Update active button
        document.querySelectorAll('.highlight-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Close dropdown
        document.getElementById('highlightOptions').style.display = 'none';
        
        // Remove focus to hide hover state
        btn.blur();
      });
    });

    // Highlight Control - Custom color picker
    document.getElementById('highlightColorControl').addEventListener('input', (e) => {
      const color = e.target.value;
      applyFormatting('highlight', color);
      
      // Remove active class from preset buttons when using custom color
      document.querySelectorAll('.highlight-color-btn').forEach(b => b.classList.remove('active'));
    });

    // Remove Highlight Button
    document.getElementById('removeHighlightBtn').addEventListener('click', (e) => {
      e.preventDefault();
      const selection = window.getSelection();
      
      // If no selection or selection is in editor
      if (!selection.toString() || !editor.contains(selection.anchorNode)) {
        alert('Моля, избери текст първо');
        return;
      }

      // Remove highlight using transparent/white background
      document.execCommand('backColor', false, 'transparent');
      
      // Close dropdown
      document.getElementById('highlightOptions').style.display = 'none';
      
      // Mark as modified
      saveToHistory();
    });

    // Apply formatting to selected text
    function applyFormatting(property, value) {
      const selection = window.getSelection();
      
      // If no selection or selection is in editor
      if (!selection.toString() || !editor.contains(selection.anchorNode)) {
        alert('Моля, избери текст първо');
        return;
      }

      // Use document.execCommand for color - it preserves structure better
      if (property === 'color') {
        // Convert hex to RGB for execCommand
        const hex = value;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const rgb = `rgb(${r}, ${g}, ${b})`;
        document.execCommand('foreColor', false, rgb);
      } else if (property === 'highlight') {
        // Convert hex to RGB for highlight
        const hex = value;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const rgb = `rgb(${r}, ${g}, ${b})`;
        document.execCommand('backColor', false, rgb);
      } else if (property === 'fontSize') {
        document.execCommand('fontSize', false, value);
      }
      
      // Save to localStorage
      if (property === 'color') {
        localStorage.setItem('mdEditorTextColor', value);
      } else if (property === 'highlight') {
        localStorage.setItem('mdEditorHighlight', value);
      }
      
      // Mark as modified
      saveToHistory();
    }

    // Load saved default preferences on page load
    window.addEventListener('load', () => {
      const savedTextColor = localStorage.getItem('mdEditorTextColor');
      const savedHeadingColor = localStorage.getItem('mdEditorHeadingColor');

      if (savedTextColor) {
        document.getElementById('textColorControl').value = savedTextColor;
        // Clear all active classes first
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        // Activate corresponding button if it exists
        const btn = document.querySelector(`.text-color-btn[data-color="${savedTextColor}"]`);
        if (btn) {
          btn.classList.add('active');
        }
      } else {
        // If no saved color, activate the default (Dark Gray)
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        const defaultBtn = document.querySelector('.text-color-btn[data-color="#1f2937"]');
        if (defaultBtn) defaultBtn.classList.add('active');
      }

      if (savedHeadingColor) {
        // Apply saved heading color
        const btn = document.querySelector(`.heading-color-btn[data-color="${savedHeadingColor}"]`);
        if (btn) {
          const style = document.createElement('style');
          style.id = 'heading-color-style';
          style.textContent = `
            #editor h1, 
            #editor h2, 
            #editor h3, 
            #editor h4 { 
              color: ${savedHeadingColor} !important; 
            }
          `;
          document.head.appendChild(style);
          
          // Also apply directly to existing headers
          const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
          headers.forEach(h => {
            h.style.color = savedHeadingColor;
          });
          
          // Clear all active classes first
          document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
      } else {
        // If no saved color, activate the default (Black)
        document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
        const defaultBtn = document.querySelector('.heading-color-btn[data-color="#000000"]');
        if (defaultBtn) {
          defaultBtn.classList.add('active');
          // Apply default heading color
          const style = document.createElement('style');
          style.id = 'heading-color-style';
          style.textContent = `
            #editor h1, 
            #editor h2, 
            #editor h3, 
            #editor h4 { 
              color: #000000 !important; 
            }
          `;
          document.head.appendChild(style);
          
          // Also apply directly to existing headers
          const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
          headers.forEach(h => {
            h.style.color = '#000000';
          });
        }
      }

      // Load saved highlight color
      const savedHighlight = localStorage.getItem('mdEditorHighlight');
      if (savedHighlight) {
        document.getElementById('highlightColorControl').value = savedHighlight;
        // Clear all active classes first
        document.querySelectorAll('.highlight-color-btn').forEach(b => b.classList.remove('active'));
        // Activate corresponding button if it exists
        const btn = document.querySelector(`.highlight-color-btn[data-color="${savedHighlight}"]`);
        if (btn) {
          btn.classList.add('active');
        }
      } else {
        // If no saved highlight, activate the default (Yellow)
        document.querySelectorAll('.highlight-color-btn').forEach(b => b.classList.remove('active'));
        const defaultBtn = document.querySelector('.highlight-color-btn[data-color="#ffeb3b"]');
        if (defaultBtn) defaultBtn.classList.add('active');
      }
    });

    document.getElementById('downloadBtn').addEventListener('click', () => {
      // Populate modal with current file info
      document.getElementById('fileNumberInput').value = currentFileInfo.number || '';
      document.getElementById('fileNameInput').value = currentFileInfo.name || '';
      updateFileNamePreview();
      
      // Show modal
      document.getElementById('saveFileModal').style.display = 'flex';
      document.getElementById('fileNameInput').focus();
    });

    // Open local .md file from computer
    document.getElementById('openLocalBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        const markdownContent = event.target.result;
        
        // Set global base path for images (use file's directory)
        if (file.name) {
          // For local files, we can't reliably set base path, but we try
          globalImageBasePath = '';
        }
        
        // Convert markdown to HTML
        isLoadingFile = true;
        const html = markdownToHtml(markdownContent);
        editor.innerHTML = html;
        saveToHistory();
        setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
        
        // Extract file info for saving later
        const fileName = file.name.replace(/\.(md|txt)$/i, '');
        const numberMatch = fileName.match(/^(\d+(\.\d+)?)-/);
        const nameWithoutNumber = fileName.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '');
        
        currentFileInfo = {
          name: nameWithoutNumber,
          number: numberMatch ? numberMatch[1] : '',
          isFromCourses: false
        };
        
        // Update page title
        document.title = fileName + ' — Markdown Editor';
      };
      reader.readAsText(file);
      
      // Reset file input
      e.target.value = '';
    });

    // Open .md file from courses.generated.js
    document.getElementById('openCoursesBtn').addEventListener('click', () => {
      // Check if courses data is available
      if (typeof courses === 'undefined') {
        alert('Courses data not found. Please make sure you are running this from index.html or include courses.generated.js');
        return;
      }
      
      // Group files by course
      const filesByCourse = {};
      courses.forEach(course => {
        const courseName = course.title || course.name || 'Unknown';
        filesByCourse[courseName] = [];
        
        course.sections.forEach(section => {
          // Add msg notes (HTML files with msg prefix)
          if (section.msgNotes) {
            section.msgNotes.forEach(note => {
              if (note.path && (/\.md$/i.test(note.path) && note.type === 'markdown') || (/\.html$/i.test(note.path) && note.type === 'html')) {
                filesByCourse[courseName].push({
                  name: note.name,
                  path: note.path,
                  content: note.content,
                  type: note.type,
                  courseName: courseName,
                  sectionName: section.name
                });
              }
            });
          }
          
          // Add regular files (including msg-terms.html)
          if (section.files) {
            section.files.forEach(file => {
              // Include any HTML or markdown files (like msg-terms.html)
              if (file.path && (file.path.match(/\.(html|md|txt)$/i))) {
                filesByCourse[courseName].push({
                  name: file.name,
                  path: file.path,
                  content: file.content,
                  type: file.type || (file.path.match(/\.html$/i) ? 'html' : 'markdown'),
                  courseName: courseName,
                  sectionName: section.name
                });
              }
            });
          }
        });
      });
      
      // Populate file list with course headers
      const fileList = document.getElementById('fileList');
      fileList.innerHTML = '';
      
      Object.keys(filesByCourse).forEach(courseName => {
        const files = filesByCourse[courseName];
        if (files.length === 0) return;
        
        // Add course header
        const courseHeader = document.createElement('div');
        courseHeader.className = 'course-header';
        courseHeader.textContent = courseName;
        courseHeader.setAttribute('data-course', courseName);
        fileList.appendChild(courseHeader);
        
        // Add files for this course
        files.forEach((file, idx) => {
          const fileItem = document.createElement('div');
          fileItem.className = 'file-item';
          fileItem.setAttribute('data-course', courseName);
          fileItem.setAttribute('data-type', file.type);
          fileItem.setAttribute('data-search-text', (file.courseName + ' ' + file.sectionName + ' ' + file.name).toLowerCase());
          
          // Clean up file name: remove msg-, number prefix (including decimals like 2.4), and extension
          const cleanName = file.name
            .replace(/^\d+(\.\d+)?-/, '')   // Remove number prefix (e.g., "1-", "2.4-")
            .replace(/^msg-/i, '')          // Remove "msg-" prefix
            .replace(/\.(md|txt|html)$/i, '');   // Remove .md, .txt, or .html extension
          
          fileItem.innerHTML = `
            <div class="file-item-name">${cleanName}</div>
            <div class="file-item-path">${file.sectionName}</div>
          `;
          
          fileItem.addEventListener('click', () => {
            loadFileFromCourses(file);
            document.getElementById('fileBrowserModal').style.display = 'none';
          });
          
          fileList.appendChild(fileItem);
        });
      });
      
      // Show modal
      document.getElementById('fileBrowserModal').style.display = 'flex';
      document.getElementById('fileSearchInput').value = '';
      document.getElementById('fileSearchInput').focus();
    });

    // HTML Editor functionality
    let htmlEditorMode = false;
    let htmlEditorOriginalContent = '';
    let currentFileName = ''; // Track current file name

    // Format HTML for readability with proper indentation
    function formatHTML(html) {
      let formatted = '';
      let indent = 0;
      const indentStr = '  '; // 2 spaces per indent level

      // Split by tags
      const tokens = html.match(/(<[^>]+>|[^<]+)/g) || [];

      for (let token of tokens) {
        token = token.trim();
        if (!token) continue;

        // Check if it's a closing tag
        const isClosingTag = token.startsWith('</');
        // Check if it's a self-closing tag or void element
        const isSelfClosing = token.endsWith('/>') || /^<(img|br|hr|input|meta|link)[\s>]/i.test(token);
        // Check if it's an opening tag
        const isOpeningTag = token.startsWith('<') && !isClosingTag && !isSelfClosing;

        if (isClosingTag) {
          indent = Math.max(0, indent - 1);
          formatted += indentStr.repeat(indent) + token + '\n';
        } else if (isSelfClosing) {
          formatted += indentStr.repeat(indent) + token + '\n';
        } else if (isOpeningTag) {
          formatted += indentStr.repeat(indent) + token + '\n';
          // Don't increase indent for certain tags
          if (!/^<(br|hr|img|input|meta|link|!DOCTYPE|!doctype)/i.test(token)) {
            indent++;
          }
        } else {
          // Text content
          const text = token.trim();
          if (text.length > 0) {
            // Only add non-empty text
            formatted += indentStr.repeat(indent) + text + '\n';
          }
        }
      }

      return formatted.trim();
    }

    document.getElementById('htmlEditorBtn').addEventListener('click', () => {
      // Check if editor has content
      if (!editor.innerHTML.trim()) {
        alert('⚠️ No content to edit.\n\nPlease open a file first.');
        return;
      }

      // Get current HTML content from editor
      let currentHtml = editor.innerHTML;
      
      // Format HTML for readability
      currentHtml = formatHTML(currentHtml);
      
      // Set textarea content
      document.getElementById('htmlEditorTextarea').value = currentHtml;
      
      // Show modal
      document.getElementById('htmlEditorModal').style.display = 'block';
      document.getElementById('htmlEditorTextarea').focus();
    });

    // HTML Editor Save
    document.getElementById('htmlEditorSaveBtn').addEventListener('click', () => {
      let htmlContent = document.getElementById('htmlEditorTextarea').value;
      
      // Minify HTML for storage (remove extra whitespace/newlines)
      // But keep meaningful structure
      htmlContent = htmlContent
        .replace(/>\s+</g, '><') // Remove space between tags
        .replace(/\n/g, '') // Remove newlines
        .replace(/\s+/g, ' ') // Replace multiple spaces with single space
        .trim();
      
      // Update editor with minified HTML
      editor.innerHTML = htmlContent;
      
      // Save to history and storage
      saveToHistory();
      localStorage.setItem('mdEditorContent', htmlContent);
      
      // Close modal
      document.getElementById('htmlEditorModal').style.display = 'none';
      
      // Show confirmation
      const notification = document.createElement('div');
      notification.textContent = '✅ HTML updated successfully!';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 12px 18px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    // HTML Editor Close
    document.getElementById('htmlEditorCloseBtn').addEventListener('click', () => {
      document.getElementById('htmlEditorModal').style.display = 'none';
    });

    // Close HTML editor on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('htmlEditorModal').style.display === 'block') {
        document.getElementById('htmlEditorModal').style.display = 'none';
      }
    });

    // File search functionality
    document.getElementById('fileSearchInput').addEventListener('input', (e) => {
      const searchText = e.target.value.toLowerCase();
      const fileItems = document.querySelectorAll('.file-item');
      const courseHeaders = document.querySelectorAll('.course-header');
      
      // Track which courses have visible files
      const visibleCourses = new Set();
      
      fileItems.forEach(item => {
        const itemText = item.getAttribute('data-search-text');
        if (itemText.includes(searchText)) {
          item.classList.remove('hidden');
          visibleCourses.add(item.getAttribute('data-course'));
        } else {
          item.classList.add('hidden');
        }
      });
      
      // Show/hide course headers based on whether they have visible files
      courseHeaders.forEach(header => {
        const courseName = header.getAttribute('data-course');
        if (visibleCourses.has(courseName)) {
          header.classList.remove('hidden');
        } else {
          header.classList.add('hidden');
        }
      });
    });

    // Function to load file from courses
    function loadFileFromCourses(file) {
      // Set global base path for images
      const basePath = file.path.substring(0, file.path.lastIndexOf('/') + 1);
      if (window.location.protocol === 'file:') {
        const currentPath = window.location.pathname;
        const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
        globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
      } else {
        const currentOrigin = window.location.origin;
        globalImageBasePath = currentOrigin + '/' + basePath;
      }
      
      // Convert markdown to HTML or use HTML directly
      isLoadingFile = true;
      let html;
      
      // If it's an HTML file, use content directly (extract body content)
      if (file.type === 'html') {
        const parser = new DOMParser();
        const doc = parser.parseFromString(file.content, 'text/html');
        // Get body content and trim whitespace
        html = doc.body.innerHTML.trim();
        
        // Parse msg-terms.html file if opened
        if (file.name === 'msg-terms.html') {
          // Just load normally, no special parsing needed
        }
      } else {
        // Otherwise parse as Markdown
        html = markdownToHtml(file.content);
      }
      
      editor.innerHTML = html;
      saveToHistory();
      setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
      
      // Extract file info for saving later
      const numberMatch = file.name.match(/^(\d+(\.\d+)?)-/);
      const cleanName = file.name.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '').replace(/\.(md|txt|html)$/i, '');
      
      currentFileInfo = {
        name: cleanName,
        number: numberMatch ? numberMatch[1] : '',
        isFromCourses: true
      };
      
      // Update page title
      document.title = cleanName + ' — Markdown Editor';
    }

    // Close file browser modal
    document.getElementById('closeFileBrowserBtn').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    document.getElementById('closeFileBrowserBtn2').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    // Close modal when clicking outside
    document.getElementById('fileBrowserModal').addEventListener('click', (e) => {
      if (e.target.id === 'fileBrowserModal') {
        document.getElementById('fileBrowserModal').style.display = 'none';
      }
    });

    // Save file modal functionality
    function updateFileNamePreview() {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      const preview = document.getElementById('fileNamePreview');
      
      let fileName = '';
      if (number) {
        fileName += number + '-msg-';
      }
      fileName += (name || 'document') + '.html';
      
      preview.textContent = fileName;
    }

    document.getElementById('fileNumberInput').addEventListener('input', updateFileNamePreview);
    document.getElementById('fileNameInput').addEventListener('input', updateFileNamePreview);

    document.getElementById('confirmSaveBtn').addEventListener('click', () => {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      
      if (!name) {
        alert('Please enter a file name');
        return;
      }
      
      // Clean the name: remove .html, .md, .txt extensions
      const cleanName = name.replace(/\.(html|md|txt)$/i, '');
      
      // Get content
      let editorContent = editor.innerHTML;
      
      // CRITICAL FIX: Process lists BEFORE doing any cleanup
      const contentDiv = document.createElement('div');
      contentDiv.innerHTML = editorContent;
      
      // Step 1: Clean up list structure first - ensure proper nesting
      // Process each list to fix any broken structures
      contentDiv.querySelectorAll('ul, ol').forEach(list => {
        // For each list, go through its direct <li> children
        Array.from(list.children).forEach(li => {
          if (li.tagName === 'LI') {
            let html = li.innerHTML;
            
            // Remove ONLY leading and trailing <br> tags in the TEXT content
            // BUT preserve <br> tags before nested lists
            // First, check if there's a nested list
            const hasNestedList = li.querySelector('ul, ol') !== null;
            
            if (hasNestedList) {
              // If has nested list, only remove trailing <br> after the nested list
              html = html.replace(/<br\s*\/?>\s*$/gi, '');
            } else {
              // If no nested list, remove both leading and trailing <br>
              html = html.replace(/^<br\s*\/?>/gi, '');
              html = html.replace(/<br\s*\/?>\s*$/gi, '');
            }
            
            li.innerHTML = html;
          }
        });
      });
      
      editorContent = contentDiv.innerHTML;
      
      // Step 2: Create a temporary container
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = editorContent;
      
      // Step 3: Remove hidden elements
      const removeHiddenElements = (element) => {
        const nodesToRemove = [];
        element.querySelectorAll('*').forEach(node => {
          const style = window.getComputedStyle(node);
          if (style.display === 'none' || style.visibility === 'hidden') {
            nodesToRemove.push(node);
          }
        });
        nodesToRemove.reverse().forEach(n => n.remove());
      };
      
      removeHiddenElements(tempDiv);
      editorContent = tempDiv.innerHTML;
      
      // Step 4: VERY CAREFULLY remove only COMPLETELY EMPTY <p> tags
      // Do NOT remove <p> tags that contain any content or are near lists
      let prevContent;
      let iterations = 0;
      do {
        prevContent = editorContent;
        iterations++;
        
        // Only remove <p> tags that are completely empty
        editorContent = editorContent.replace(/<p>\s*<\/p>/g, '');
        
        // Only remove <p> with just <br> tags (these are spacing)
        editorContent = editorContent.replace(/<p><br\s*\/?><\/p>/g, '');
        editorContent = editorContent.replace(/<p>\s*<br\s*\/?>\s*<\/p>/g, '');
        
        // DO NOT try to remove <p> containing text or formatting
        // This breaks lists completely
        
      } while (editorContent !== prevContent && iterations < 2);
      
      // Step 5: Fix image paths
      editorContent = editorContent.replace(/src="[^"]*?(assets\/[^"]*)"(?=[^>]*>)/g, 'src="$1"');
      editorContent = editorContent.replace(/(<img[^>]*src="([^"]*?)"[^>]*)data-original-src="[^"]*?"(?=[^>]*>)/g, '$1data-original-src="$2"');
      editorContent = editorContent.replace(/file:\/\/\/.*?\/Filen\/Personal\/Website\//g, '');
      
      // Get heading color from localStorage
      const savedHeadingColor = localStorage.getItem('mdEditorHeadingColor') || '#000000';
      
      // Create standalone HTML file with embedded content
      const htmlDoc = `<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${cleanName}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  <style>
    body { 
      font-family: "Open Sans", Arial, sans-serif; 
      max-width: 1550px; 
      margin: 0.5rem auto; 
      padding: 0 1rem; 
      line-height: 1.6; 
      color: #1f2937; 
    }
    h1, h2, h3, h4 { 
      font-weight: 600; 
      margin-top: 0.8em;
      margin-bottom: 0.15em;
      color: ${savedHeadingColor};
    }
    h1 { font-size: 1.5em; }
    h2 { font-size: 1.3em; }
    h3 { font-size: 1.1em; margin-bottom: 0.1em; }
    h4 { font-size: 1.05em; margin-bottom: 0.1em; }
    h3 + h4 { margin-top: 0.3em; }
    p { 
      margin: 0.3em 0; 
      white-space: pre-wrap;
    }
    p + ul, p + ol { margin-top: -0.5em; }
    h1 + p, h2 + p, h3 + p, h4 + p,
    h1 + ul, h2 + ul, h3 + ul, h4 + ul,
    h1 + ol, h2 + ol, h3 + ol, h4 + ol { 
      margin-top: 0.1em; 
    }
    ul, ol { 
      margin: 0.5em 0; 
      padding-left: 1.5em; 
      list-style-position: outside;
    }
    li { margin: 0.2em 0; }
    li p {
      margin: 0;
      padding: 0;
      display: inline;
    }
    li > ul, li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }
    ul ul, ul ol, ol ul, ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }
    ul ul { list-style-type: circle; }
    ul ul ul { list-style-type: square; }
    strong { font-weight: 600; }
    em { font-style: italic; }
    code { 
      background: rgba(146, 64, 14, 0.1); 
      padding: 2px 6px; 
      border-radius: 3px; 
      font-family: "Courier New", monospace; 
      font-size: 0.9em; 
    }
    pre {
      background: rgba(255, 255, 255, 0.5);
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
      font-family: "Courier New", monospace;
    }
    pre code {
      background: none;
      padding: 0;
    }
    blockquote {
      border-left: 3px solid #f59e0b;
      padding-left: 1em;
      margin: 0.5em 0;
      font-style: italic;
      color: #78350f;
    }
    table { 
      border-collapse: collapse; 
      margin: 0.75em 0; 
      width: 100%; 
      table-layout: auto;
    }
    th, td { 
      border: 1px solid rgba(146, 64, 14, 0.35); 
      padding: 6px 10px; 
      text-align: left; 
      vertical-align: top;
      height: 24px;
      line-height: 1.2;
    }
    thead th { 
      background: rgba(196, 127, 9, 0.08); 
      font-weight: 600; 
    }
    tbody tr:nth-child(odd) { 
      background: rgba(146, 64, 14, 0.03); 
    }
    img { 
      max-width: 100%; 
      height: auto; 
    }
    a { 
      color: #f59e0b; 
      text-decoration: underline; 
    }
    a:hover {
      color: #d97706;
    }
    /* Keep <p> tags inside list items on same line (as they appear in editor) */
    li p {
      margin: 0 !important;
      padding: 0 !important;
      display: inline !important;
      line-height: 1 !important;
    }
    /* Prevent nested list paragraph issues */
    li > ul,
    li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }
    /* Ensure list structure is clean */
    ul ul, ul ol,
    ol ul, ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }
    @media (max-width: 768px) {
      body {
        max-width: 100%;
        margin: 0.5rem 0;
        padding: 0 0.5rem;
        font-size: 16px;
      }
      h1 { font-size: 1.3em; }
      h2 { font-size: 1.1em; }
      h3 { font-size: 1em; }
      p { margin: 0.5em 0; }
      ul, ol { padding-left: 1.2em; }
      li { margin: 0.1em 0; }
      table { font-size: 0.9em; }
      th, td { padding: 4px 6px; }
    }
  </style>
</head>
<body>
${editorContent}
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"><\/script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"><\/script>
<script>
renderMathInElement(document.body, {
  delimiters: [
    {left: '$$', right: '$$', display: true},
    {left: '$', right: '$', display: false}
  ]
});
<\/script>
</body>
</html>`;
      
      const blob = new Blob([htmlDoc], { type: 'text/html;charset=utf-8' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      
      let fileName = '';
      if (number) {
        fileName = number + '-msg-' + name + '.html';
      } else {
        fileName = name + '.html';
      }
      
      link.download = fileName;
      link.click();
      URL.revokeObjectURL(link.href);
      
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('cancelSaveBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('closeSaveModalBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('saveFileModal').addEventListener('click', (e) => {
      if (e.target.id === 'saveFileModal') {
        document.getElementById('saveFileModal').style.display = 'none';
      }
    });

    // Image modal events
    document.getElementById('imageBtn').addEventListener('click', insertImage);
    
    document.getElementById('closeImageModalBtn').addEventListener('click', () => {
      document.getElementById('imageModal').style.display = 'none';
    });
    
    document.getElementById('cancelImageBtn').addEventListener('click', () => {
      document.getElementById('imageModal').style.display = 'none';
    });
    
    document.getElementById('imageModal').addEventListener('click', (e) => {
      if (e.target.id === 'imageModal') {
        document.getElementById('imageModal').style.display = 'none';
      }
    });



    // Image size preset selector
    document.getElementById('imageSizePreset').addEventListener('change', (e) => {
      const preset = e.target.value;
      const sizeInput = document.getElementById('imageSizeInput');
      
      if (preset === 'custom') {
        sizeInput.style.display = 'block';
        sizeInput.focus();
      } else {
        sizeInput.value = preset;
        sizeInput.style.display = 'block';
      }
    });
    
    document.getElementById('insertImageBtn').addEventListener('click', () => {
      let imageName = document.getElementById('imageNameInput').value.trim();
      const imageAlt = document.getElementById('imageAltInput').value.trim();
      const imageSize = document.getElementById('imageSizeInput').value || 100;

      if (!imageName) {
        alert('Please enter image file name');
        return;
      }
      
      // Auto-add .png extension if missing
      if (!imageName.match(/\.(png|jpg|jpeg|gif|webp|svg)$/i)) {
        imageName = imageName + '.png';
      }
      
      // Use saved range if available, otherwise get current selection
      let range = savedImageRange;
      if (!range) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) {
          alert('Please click in the editor first');
          return;
        }
        range = selection.getRangeAt(0);
      }
      
      const img = document.createElement('img');
      img.src = 'assets/' + imageName;
      img.alt = imageAlt || imageName;
      img.style.maxWidth = imageSize + '%';
      img.style.height = 'auto';
      img.style.display = 'block';
      img.setAttribute('data-original-src', 'assets/' + imageName);
      img.setAttribute('data-width', imageSize);
      
      range.insertNode(img);
      
      // Add line break after image
      const br = document.createElement('br');
      range.setStartAfter(img);
      range.insertNode(br);
      
      // Move cursor after br
      range.setStartAfter(br);
      range.collapse(true);
      
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      
      // Clear inputs and close modal
      document.getElementById('imageNameInput').value = '';
      document.getElementById('imageAltInput').value = '';
      document.getElementById('imageSizeInput').value = '100';
      document.getElementById('imageSizePreset').value = '100';
      document.getElementById('imageModal').style.display = 'none';
      savedImageRange = null; // Clear saved range
      
      saveToHistory();
      editor.focus();
    });

    // Enter key support for image name input
    document.getElementById('imageNameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('insertImageBtn').click();
      }
    });

    // Checklist modal events
    const checklistModal = document.getElementById('checklistModal');
    
    document.getElementById('closeChecklistModalBtn').addEventListener('click', () => {
      checklistModal.style.display = 'none';
    });
    
    document.getElementById('cancelChecklistBtn').addEventListener('click', () => {
      checklistModal.style.display = 'none';
    });
    
    checklistModal.addEventListener('click', (e) => {
      if (e.target.id === 'checklistModal') {
        checklistModal.style.display = 'none';
      }
    });
    
    document.getElementById('confirmChecklistBtn').addEventListener('click', () => {
      // Check if user pasted text in textarea
      const textInput = document.getElementById('checklistTextInput').value.trim();
      let count;
      let customAnswers = [];
      
      if (textInput) {
        // Use pasted text to generate answers
        customAnswers = textInput.split('\n').filter(line => line.trim().length > 0);
        count = customAnswers.length;
      } else {
        // Use the number input
        count = parseInt(document.getElementById('checklistCountInput').value) || 4;
      }
      
      const doHighlight = document.getElementById('checklistHighlightCheckbox').checked;
      const doBold = document.getElementById('checklistBoldCheckbox').checked;
      
      // Use saved range
      let range = savedChecklistRange;
      if (!range) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) {
          alert('Please click in the editor first');
          return;
        }
        range = selection.getRangeAt(0);
      }
      
      // Bulgarian letters: А, Б, В, Г, Д, ...
      const bulgarianLetters = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У'];
      
      // Build the HTML for the checklist
      let checklistHtml = '<ul style="list-style-type: none; padding-left: 0;">';
      for (let i = 1; i <= count; i++) {
        const label = bulgarianLetters[i - 1];
        const answerText = customAnswers.length > 0 ? customAnswers[i - 1] : `Option ${i}`;
        
        checklistHtml += `<li style="margin-bottom: 8px; display: flex; align-items: center;"><span class="checklist-circle" style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; border: 1px solid #999; border-radius: 50%; margin-right: 8px; font-size: 12px; font-weight: bold; background-color: white; color: #000; transition: all 0.2s;">${label}</span><span class="checklist-item" style="cursor: pointer;">${answerText}</span></li>`;
      }
      checklistHtml += '</ul>';
      
      // Create a temporary container
      const temp = document.createElement('div');
      temp.innerHTML = checklistHtml;
      
      // Get the UL element
      const ul = temp.querySelector('ul');
      
      // Add click handlers to checklist items
      const items = ul.querySelectorAll('li');
      items.forEach(item => {
        item.addEventListener('click', function(e) {
          e.stopPropagation();
          const circle = this.querySelector('.checklist-circle');
          const span = this.querySelector('.checklist-item');
          const isSelected = circle.style.backgroundColor === 'rgb(0, 0, 0)';
          
          if (isSelected) {
            // Deselect
            circle.style.backgroundColor = 'white';
            circle.style.color = '#000';
            if (doHighlight) span.style.color = 'inherit';
            if (doBold) span.style.fontWeight = 'normal';
          } else {
            // Select
            circle.style.backgroundColor = '#000';
            circle.style.color = 'white';
            if (doHighlight) span.style.color = '#ef4444';
            if (doBold) span.style.fontWeight = 'bold';
          }
        });
      });
      
      // Insert the UL at cursor position
      range.insertNode(ul);
      
      // Add a line break after for spacing
      const br = document.createElement('br');
      range.setStartAfter(ul);
      range.insertNode(br);
      
      // Move cursor after the br
      range.setStartAfter(br);
      range.collapse(true);
      
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      
      // Close modal and reset
      document.getElementById('checklistModal').style.display = 'none';
      document.getElementById('checklistCountInput').value = '4';
      document.getElementById('checklistTextInput').value = '';
      document.getElementById('checklistHighlightCheckbox').checked = true;
      document.getElementById('checklistBoldCheckbox').checked = false;
      savedChecklistRange = null; // Clear saved range
      
      saveToHistory();
      editor.focus();
    });

    // Table modal events
    const tableModal = document.getElementById('tableModal');
    
    document.getElementById('closeTableModalBtn').addEventListener('click', () => {
      tableModal.style.display = 'none';
    });
    
    document.getElementById('cancelTableBtn').addEventListener('click', () => {
      tableModal.style.display = 'none';
    });
    
    tableModal.addEventListener('click', (e) => {
      if (e.target.id === 'tableModal') {
        tableModal.style.display = 'none';
      }
    });
    
    document.getElementById('confirmTableBtn').addEventListener('click', () => {
      const rows = parseInt(document.getElementById('tableRowsInput').value) || 3;
      const cols = parseInt(document.getElementById('tableColsInput').value) || 3;
      
      const tableHTML = createTableHTML(rows, cols);
      
      // Use saved range from before modal was opened
      const range = savedTableRange || document.getSelection().getRangeAt(0);
      const fragment = document.createRange().createContextualFragment(tableHTML);
      range.insertNode(fragment);
      
      // Add a line break after table for spacing
      const br = document.createElement('br');
      range.setStartAfter(fragment.lastChild);
      range.insertNode(br);
      
      // Move cursor after the br
      range.setStartAfter(br);
      range.collapse(true);
      
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      
      // Clear saved range
      savedTableRange = null;
      
      // Close modal and reset
      tableModal.style.display = 'none';
      document.getElementById('tableRowsInput').value = '3';
      document.getElementById('tableColsInput').value = '3';
      
      saveToHistory();
      editor.focus();
    });

    // Table context menu functionality
    const tableContextMenu = document.getElementById('tableContextMenu');
    let contextMenuCell = null;

    // Show context menu on right-click in table
    editor.addEventListener('contextmenu', (e) => {
      let node = e.target;
      
      // Check if click is inside a table cell
      while (node && node !== editor) {
        if (node.tagName === 'TD' || node.tagName === 'TH') {
          e.preventDefault();
          
          contextMenuCell = node;
          
          // Position the context menu
          tableContextMenu.style.left = e.pageX + 'px';
          tableContextMenu.style.top = e.pageY + 'px';
          tableContextMenu.classList.add('active');
          
          return;
        }
        node = node.parentNode;
      }
    });

    // Hide context menu on click outside
    document.addEventListener('click', () => {
      tableContextMenu.classList.remove('active');
    });

    // Context menu actions
    document.getElementById('addRowBefore').addEventListener('click', () => {
      if (contextMenuCell) {
        const table = contextMenuCell.closest('table');
        const row = contextMenuCell.closest('tr');
        const newRow = document.createElement('tr');
        const colCount = row.cells.length;
        
        for (let i = 0; i < colCount; i++) {
          newRow.appendChild(document.createElement('td'));
        }
        row.parentNode.insertBefore(newRow, row);
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('addRowAfter').addEventListener('click', () => {
      if (contextMenuCell) {
        const row = contextMenuCell.closest('tr');
        const newRow = document.createElement('tr');
        const colCount = row.cells.length;
        
        for (let i = 0; i < colCount; i++) {
          newRow.appendChild(document.createElement('td'));
        }
        row.parentNode.insertBefore(newRow, row.nextSibling);
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('deleteRow').addEventListener('click', () => {
      if (contextMenuCell) {
        const row = contextMenuCell.closest('tr');
        row.remove();
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('addColBefore').addEventListener('click', () => {
      if (contextMenuCell) {
        const table = contextMenuCell.closest('table');
        const colIndex = contextMenuCell.cellIndex;
        
        table.querySelectorAll('tr').forEach(row => {
          const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
          newCell.textContent = ' ';
          row.insertBefore(newCell, row.cells[colIndex]);
        });
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('addColAfter').addEventListener('click', () => {
      if (contextMenuCell) {
        const table = contextMenuCell.closest('table');
        const colIndex = contextMenuCell.cellIndex;
        
        table.querySelectorAll('tr').forEach(row => {
          const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
          newCell.textContent = ' ';
          row.insertBefore(newCell, row.cells[colIndex + 1]);
        });
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('deleteCol').addEventListener('click', () => {
      if (contextMenuCell) {
        const table = contextMenuCell.closest('table');
        const colIndex = contextMenuCell.cellIndex;
        
        table.querySelectorAll('tr').forEach(row => {
          if (row.cells[colIndex]) row.deleteCell(colIndex);
        });
        saveToHistory();
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('mergeCells').addEventListener('click', () => {
      if (contextMenuCell) {
        // Open merge cells modal
        const mergeCellsModal = document.getElementById('mergeCellsModal');
        mergeCellsModal.style.display = 'flex';
      }
      tableContextMenu.classList.remove('active');
    });

    // Merge Cells Modal events
    const mergeCellsModal = document.getElementById('mergeCellsModal');
    
    document.getElementById('closeMergeCellsModalBtn').addEventListener('click', () => {
      mergeCellsModal.style.display = 'none';
    });
    
    document.getElementById('cancelMergeBtn').addEventListener('click', () => {
      mergeCellsModal.style.display = 'none';
    });
    
    mergeCellsModal.addEventListener('click', (e) => {
      if (e.target.id === 'mergeCellsModal') {
        mergeCellsModal.style.display = 'none';
      }
    });

    document.getElementById('mergeRightBtn').addEventListener('click', () => {
      if (contextMenuCell) {
        const row = contextMenuCell.closest('tr');
        const cellIndex = contextMenuCell.cellIndex;
        const nextCell = row.cells[cellIndex + 1];
        
        if (nextCell) {
          contextMenuCell.textContent = (contextMenuCell.textContent + ' ' + nextCell.textContent).trim();
          const colspan = parseInt(contextMenuCell.getAttribute('colspan')) || 1;
          contextMenuCell.setAttribute('colspan', colspan + 1);
          nextCell.remove();
          saveToHistory();
        } else {
          alert('No cell to the right to merge with');
        }
      }
      mergeCellsModal.style.display = 'none';
    });

    document.getElementById('mergeDownBtn').addEventListener('click', () => {
      if (contextMenuCell) {
        const currentRow = contextMenuCell.closest('tr');
        const nextRow = currentRow.nextElementSibling;
        const cellIndex = contextMenuCell.cellIndex;
        
        if (nextRow && nextRow.cells[cellIndex]) {
          const cellBelow = nextRow.cells[cellIndex];
          contextMenuCell.textContent = (contextMenuCell.textContent + ' ' + cellBelow.textContent).trim();
          const rowspan = parseInt(contextMenuCell.getAttribute('rowspan')) || 1;
          contextMenuCell.setAttribute('rowspan', rowspan + 1);
          cellBelow.remove();
          saveToHistory();
        } else {
          alert('No cell below to merge with');
        }
      }
      mergeCellsModal.style.display = 'none';
    });

    document.getElementById('splitCell').addEventListener('click', () => {
      if (contextMenuCell) {
        const colspan = parseInt(contextMenuCell.getAttribute('colspan')) || 1;
        
        if (colspan > 1) {
          const row = contextMenuCell.closest('tr');
          contextMenuCell.setAttribute('colspan', colspan - 1);
          const newCell = document.createElement('td');
          row.insertBefore(newCell, contextMenuCell.nextSibling);
          saveToHistory();
        }
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('setCellBg').addEventListener('click', () => {
      if (contextMenuCell) {
        const color = prompt('Enter background color (hex):', '#FAF594');
        if (color) {
          contextMenuCell.style.backgroundColor = color;
          saveToHistory();
        }
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('deleteTableCtx').addEventListener('click', () => {
      if (contextMenuCell) {
        const table = contextMenuCell.closest('table');
        if (confirm('Delete entire table?')) {
          table.remove();
          saveToHistory();
        }
      }
      tableContextMenu.classList.remove('active');
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all content?')) {
        editor.innerHTML = '<p></p>';
        saveToHistory();
        editor.focus();
      }
    });

    // Shortcuts modal
    shortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.add('open');
    });

    closeShortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    closeShortcutsBtn2.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    shortcutsModal.addEventListener('click', (e) => {
      if (e.target === shortcutsModal) {
        shortcutsModal.classList.remove('open');
      }
    });

    // Reset font size functionality
    function resetFontSizes() {
      const editor = document.getElementById('editor');
      
      // Define default font sizes for each element type
      const defaultSizes = {
        'h1': '1.5em',
        'h2': '1.3em',
        'h3': '1.1em',
        'h4': '1.05em',
        'p': '1em',
        'li': '1em',
        'blockquote': '1em',
        'code': '0.9em',
        'td': '1em',
        'th': '1em'
      };
      
      // Reset all elements
      Object.entries(defaultSizes).forEach(([selector, fontSize]) => {
        const elements = editor.querySelectorAll(selector);
        elements.forEach(el => {
          el.style.fontSize = fontSize;
        });
      });
      
      // Also reset inline style font-size on any element
      const allElements = editor.querySelectorAll('*');
      allElements.forEach(el => {
        if (el.style.fontSize) {
          const tag = el.tagName.toLowerCase();
          if (defaultSizes[tag]) {
            el.style.fontSize = defaultSizes[tag];
          } else {
            // For other elements, reset to inherit
            el.style.fontSize = 'inherit';
          }
        }
      });
      
      saveToHistory();
      
      // Show notification
      const notification = document.createElement('div');
      notification.textContent = '✓ Font sizes reset to default';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    }

    // Reset font size button event listener
    const resetFontSizeBtn = document.getElementById('resetFontSizeBtn');
    if (resetFontSizeBtn) {
      resetFontSizeBtn.addEventListener('click', () => {
        resetFontSizes();
      });
    }

    // Gemini button - Copy prompt to clipboard and open Gemini
    const geminiBtn = document.getElementById('geminiBtn');
    if (geminiBtn) {
      geminiBtn.addEventListener('click', () => {
        const geminiPrompt = `Преобразувай целия следващ текст в СУРОВ MD КОД с цел максимална четимост и ясна структура.

Изисквания за форматиране:
1. Генерирай само и единствено самия .md код, ОГРАДЕН В БЛОК ЗА КОД (markdown...), за да може да бъде копиран.
2. Използвай **H1 (#)** само веднъж за главното заглавие на темата.
3. Използвай **H3 (###)** и **H4 (####)** за всички подтеми и секции. Избягвай H2. Не използвай H5 или по-ниски.
4. Преобразувай дългите абзаци в ЛОГИЧЕСКИ СПИСЪЦИ (bullet points), където е възможно, за да се подобри прегледността.
5. Използвай удебеляване (bold) за ключови термини, синдроми и анатомични структури.
6. СЪДЪРЖАНИЕТО да бъде запазено изцяло, но форматиране може да бъде променено за по-добра структура и четимост.
7. Не добавяй LaTeX, емоджита, cite_start или снимки.
8. Ако има препратки към фигури (напр. "фиг. 8.1"), ги премахни.
9. Ако изпращам текста на части, продължавай смислово от последната завършена секция.`;

        // Copy to clipboard
        navigator.clipboard.writeText(geminiPrompt).then(() => {
          // Show notification
          const notification = document.createElement('div');
          notification.textContent = '✓ Prompt copied to clipboard! Opening Gemini...';
          notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #2563eb; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.transition = 'opacity 0.3s';
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
          }, 2000);

          // Open Gemini in new tab
          window.open('https://gemini.google.com/app', '_blank');
        }).catch(err => {
          console.error('Failed to copy:', err);
          // Show error notification
          const notification = document.createElement('div');
          notification.textContent = '✗ Failed to copy prompt';
          notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #ef4444; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.transition = 'opacity 0.3s';
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
          }, 2000);
        });
      });
    }

    // ChatGPT button - Open ChatGPT
    const chatgptBtn = document.getElementById('chatgptBtn');
    if (chatgptBtn) {
      chatgptBtn.addEventListener('click', () => {
        window.open('https://chatgpt.com', '_blank');
      });
    }

    // UpToDate button - Open UpToDate
    const uptodateBtn = document.getElementById('uptodateBtn');
    if (uptodateBtn) {
      uptodateBtn.addEventListener('click', () => {
        window.open('https://www.uptodate.com/contents/search', '_blank');
      });
    }

    // Raw code modal - TOGGLE MODE
    // Function to apply syntax highlighting to markdown
    function highlightMarkdown(text) {
      // Escape HTML to prevent code execution
      let highlighted = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Headers (h1-h4)
      highlighted = highlighted.replace(/^(#{1,4})\s+(.*)$/gm, '<span style="color: #92400e; font-weight: 600;">$1</span> <span style="color: #78350f; font-weight: 600;">$2</span>');
      
      // Bold **text**
      highlighted = highlighted.replace(/\*\*([^*]+)\*\*/g, '<span style="color: #1f2937; font-weight: 600;">**</span><span style="color: #374151; font-weight: 600;">$1</span><span style="color: #1f2937; font-weight: 600;">**</span>');
      
      // Italic *text*
      highlighted = highlighted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span style="color: #6b7280;">*</span><span style="color: #6b7280; font-style: italic;">$1</span><span style="color: #6b7280;">*</span>');
      
      // Underline __text__
      highlighted = highlighted.replace(/__([^_]+)__/g, '<span style="color: #9ca3af;">__</span><span style="color: #9ca3af; text-decoration: underline;">$1</span><span style="color: #9ca3af;">__</span>');
      
      // Inline code `code`
      highlighted = highlighted.replace(/`([^`]+)`/g, '<span style="color: #059669;">`</span><span style="color: #059669; background: rgba(5, 150, 105, 0.1);">$1</span><span style="color: #059669;">`</span>');
      
      // Links [text](url)
      highlighted = highlighted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<span style="color: #2563eb;">[</span><span style="color: #3b82f6;">$1</span><span style="color: #2563eb;">](</span><span style="color: #60a5fa; text-decoration: underline;">$2</span><span style="color: #2563eb;">)</span>');
      
      // Images ![alt](url)
      highlighted = highlighted.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<span style="color: #7c3aed;">![</span><span style="color: #8b5cf6;">$1</span><span style="color: #7c3aed;">](</span><span style="color: #a78bfa; text-decoration: underline;">$2</span><span style="color: #7c3aed;">)</span>');
      
      // Unordered list - keep original - or * marker
      highlighted = highlighted.replace(/^(\s*)([-*])\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2</span> <span style="color: #374151;">$3</span>');
      
      // Ordered list
      highlighted = highlighted.replace(/^(\s*)(\d+)\.\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2.</span> <span style="color: #374151;">$3</span>');
      
      // Blockquote
      highlighted = highlighted.replace(/^(&gt;)\s+(.*)$/gm, '<span style="color: #d97706; font-weight: 600;">$1</span> <span style="color: #92400e; font-style: italic;">$2</span>');
      
      // Horizontal rule
      highlighted = highlighted.replace(/^---+$/gm, '<span style="color: #6b7280;">---</span>');
      
      // Dashed divider (topic separator)
      highlighted = highlighted.replace(/^~~~+$/gm, '<span style="color: #8B6F47; border-bottom: 2px dashed #8B6F47; display: inline-block; padding-bottom: 2px;">~~~</span>');
      
      return highlighted;
    }

    // Flatten nested lists - remove unnecessary nesting
    function flattenNestedLists() {
      // Recursively flatten all nested lists
      let changed = true;
      while (changed) {
        changed = false;
        
        // Find all OL and UL elements
        const allLists = Array.from(editor.querySelectorAll('ol, ul'));
        
        for (let list of allLists) {
          // Check if this list is nested inside an LI
          const parentLi = list.parentElement;
          if (parentLi && parentLi.tagName === 'LI') {
            // This is a nested list
            const grandparentList = parentLi.parentElement;
            
            // Only flatten if both parent and child are same type or if parent is OL
            if (grandparentList && (grandparentList.tagName === 'OL' || grandparentList.tagName === 'UL')) {
              // Move all items from nested list to after the parent LI
              const items = Array.from(list.querySelectorAll(':scope > li'));
              
              for (let item of items) {
                // If this is an OL > LI > OL, move items to parent OL
                if (grandparentList.tagName === 'OL' && list.tagName === 'OL') {
                  const nextSibling = parentLi.nextElementSibling;
                  if (nextSibling) {
                    grandparentList.insertBefore(item.cloneNode(true), nextSibling);
                  } else {
                    grandparentList.appendChild(item.cloneNode(true));
                  }
                }
              }
              
              // Remove the nested list if we moved items
              if (items.length > 0 && list.tagName === 'OL' && grandparentList.tagName === 'OL') {
                list.remove();
                changed = true;
              }
            }
          }
        }
      }
      
      // Second pass: remove any remaining nested OL/UL that are direct children of LI
      const nestedLists = editor.querySelectorAll('ol ol, ol ul, ul ol, ul ul');
      nestedLists.forEach(nestedList => {
        const parent = nestedList.parentElement;
        if (parent && parent.tagName === 'LI') {
          // Move all items up
          const items = Array.from(nestedList.children);
          const grandparent = parent.parentElement;
          
          items.forEach((item, index) => {
            const clone = item.cloneNode(true);
            const nextSibling = parent.nextElementSibling;
            if (nextSibling) {
              grandparent.insertBefore(clone, nextSibling);
            } else {
              grandparent.appendChild(clone);
            }
          });
          
          nestedList.remove();
        }
      });
    }

    // Merge adjacent lists of the same type
    function mergeAdjacentLists() {
      const selection = window.getSelection();
      let currentNode = selection.focusNode;
      
      // Find the list item we're in
      while (currentNode && currentNode !== editor) {
        if (currentNode.nodeType === 1 && currentNode.tagName === 'LI') {
          const listItem = currentNode;
          const list = listItem.parentNode;
          
          if (list && (list.tagName === 'OL' || list.tagName === 'UL')) {
            // Check if there's an identical list immediately after this one
            let nextElement = list.nextElementSibling;
            while (nextElement && nextElement.nodeType === 8) {
              // Skip comment nodes
              nextElement = nextElement.nextElementSibling;
            }
            
            if (nextElement && nextElement.tagName === list.tagName) {
              // Move all items from next list to current list
              while (nextElement.firstChild) {
                list.appendChild(nextElement.firstChild);
              }
              // Remove the now-empty list
              nextElement.remove();
              
              // Show notification
              const notification = document.createElement('div');
              notification.textContent = '✓ Списъци обединени';
              notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
              document.body.appendChild(notification);
              
              setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
              }, 2000);
            } else {
              alert('Няма съседен списък за обединяване');
            }
          }
          return;
        }
        currentNode = currentNode.parentNode;
      }
      
      alert('Моля, позиционирай курсора в списък');
    }

    // Double-click to edit list item numbers
    editor.addEventListener('dblclick', (e) => {
      // Find if we're in an OL li
      let li = e.target.closest('li');
      
      if (li && li.parentNode && li.parentNode.tagName === 'OL') {
        e.preventDefault();
        
        // Find the current position in the list
        const ol = li.parentNode;
        const items = Array.from(ol.children);
        const currentIndex = items.indexOf(li);
        const currentNumber = currentIndex + 1;
        
        // Prompt user for new number
        const newNumber = prompt(`Промени номера на list item (текущо: ${currentNumber}):`, currentNumber.toString());
        
        if (newNumber !== null && newNumber.trim() !== '') {
          const num = parseInt(newNumber);
          if (!isNaN(num) && num > 0) {
            // Store the custom number as data attribute
            li.setAttribute('data-ol-number', num);
            
            // Apply custom CSS if not already applied
            if (!document.getElementById('custom-ol-numbers')) {
              const style = document.createElement('style');
              style.id = 'custom-ol-numbers';
              style.textContent = `
                ol li[data-ol-number] {
                  list-style: none;
                  counter-increment: none;
                }
                ol li[data-ol-number]::before {
                  content: attr(data-ol-number) ". ";
                  font-weight: inherit;
                }
              `;
              document.head.appendChild(style);
            }
            
            saveToHistory();
            
            // Show notification
            const notification = document.createElement('div');
            notification.textContent = `✓ Номер на list item промънен на ${num}`;
            notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.style.transition = 'opacity 0.3s';
              notification.style.opacity = '0';
              setTimeout(() => notification.remove(), 300);
            }, 2000);
          } else {
            alert('Моля, въведи положително число');
          }
        }
      }
    });

    // Keyboard shortcuts
    editor.addEventListener('keydown', (e) => {
      // Handle Delete/Backspace on dashed line dividers (works same as regular <hr>)
      if (e.key === 'Delete' || e.key === 'Backspace') {
        const selection = window.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          
          // Find the actual element
          while (node && node !== editor && node.nodeType === 3) {
            node = node.parentNode;
          }
          
          // Check if adjacent to <hr>
          if (node && node.nodeType === 1) {
            if (e.key === 'Backspace' && node.previousSibling && node.previousSibling.tagName === 'HR') {
              e.preventDefault();
              node.previousSibling.remove();
              saveToHistory();
              return;
            }
            if (e.key === 'Delete' && node.nextSibling && node.nextSibling.tagName === 'HR') {
              e.preventDefault();
              node.nextSibling.remove();
              saveToHistory();
              return;
            }
          }
        }
      }
      
      // CRITICAL: Handle Enter in list items to prevent <p> tag wrapping
      if (e.key === 'Enter') {
        const selection = window.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          
          // Check if we're inside a list item
          while (node && node !== editor) {
            if (node.nodeType === 1 && node.tagName === 'LI') {
              // We're in a list item - let browser handle it but don't prevent
              // The input event will clean up any stray <p> tags
              return;
            }
            node = node.parentNode;
          }
        }
      }
      
      // Handle Tab/Shift+Tab for list indentation or table navigation
      if (e.key === 'Tab') {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        
        // First check if we're in a table cell
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'TD' || node.tagName === 'TH')) {
            e.preventDefault();
            
            const currentCell = node;
            const row = currentCell.closest('tr');
            const table = currentCell.closest('table');
            
            if (e.shiftKey) {
              // Navigate to previous cell
              const prevCell = currentCell.previousElementSibling;
              if (prevCell) {
                setCursorInCell(prevCell);
              } else {
                // Go to previous row, last cell
                const prevRow = row.previousElementSibling;
                if (prevRow) {
                  const lastCell = prevRow.cells[prevRow.cells.length - 1];
                  setCursorInCell(lastCell);
                }
              }
            } else {
              // Navigate to next cell
              const nextCell = currentCell.nextElementSibling;
              if (nextCell) {
                setCursorInCell(nextCell);
              } else {
                // Go to next row, first cell
                const nextRow = row.nextElementSibling;
                if (nextRow) {
                  setCursorInCell(nextRow.cells[0]);
                } else {
                  // We're at the last cell - add a new row
                  const tbody = table.querySelector('tbody');
                  const newRow = document.createElement('tr');
                  const colCount = row.cells.length;
                  for (let i = 0; i < colCount; i++) {
                    newRow.appendChild(document.createElement('td'));
                  }
                  tbody.appendChild(newRow);
                  setCursorInCell(newRow.cells[0]);
                  saveToHistory();
                }
              }
            }
            return;
          }
          node = node.parentNode;
        }
        
        // If not in table, check for list item
        node = range.startContainer;
        while (node && node !== editor) {
          if (node.nodeType === 1 && node.tagName === 'LI') {
            e.preventDefault();
            if (e.shiftKey) {
              document.execCommand('outdent', false, null);
            } else {
              document.execCommand('indent', false, null);
            }
            saveToHistory();
            return;
          }
          node = node.parentNode;
        }
      }
      
      // Handle arrow keys for table navigation
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        
        // Check if we're in a table cell
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'TD' || node.tagName === 'TH')) {
            // Only handle if cursor is at edge of cell
            const atStart = range.startOffset === 0;
            const atEnd = range.startOffset === (node.textContent || '').length;
            
            const currentCell = node;
            const row = currentCell.closest('tr');
            const cellIndex = currentCell.cellIndex;
            
            if (e.key === 'ArrowLeft' && atStart && e.ctrlKey) {
              e.preventDefault();
              const prevCell = currentCell.previousElementSibling;
              if (prevCell) setCursorInCell(prevCell);
            } else if (e.key === 'ArrowRight' && atEnd && e.ctrlKey) {
              e.preventDefault();
              const nextCell = currentCell.nextElementSibling;
              if (nextCell) setCursorInCell(nextCell);
            } else if (e.key === 'ArrowUp' && e.ctrlKey) {
              e.preventDefault();
              const prevRow = row.previousElementSibling;
              if (prevRow && prevRow.cells[cellIndex]) {
                setCursorInCell(prevRow.cells[cellIndex]);
              }
            } else if (e.key === 'ArrowDown' && e.ctrlKey) {
              e.preventDefault();
              const nextRow = row.nextElementSibling;
              if (nextRow && nextRow.cells[cellIndex]) {
                setCursorInCell(nextRow.cells[cellIndex]);
              }
            }
            return;
          }
          node = node.parentNode;
        }
      }
      
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'b') {
          e.preventDefault();
          document.execCommand('bold', false, null);
          saveToHistory();
        } else if (e.key === 'i') {
          e.preventDefault();
          document.execCommand('italic', false, null);
          saveToHistory();
        } else if (e.key === 's' || e.key === 'S' || e.key === 'С' || e.key === 'с') {
          e.preventDefault();
          // Open save modal (same as download button)
          document.getElementById('saveFileModal').style.display = 'block';
        } else if (e.key === '`') {
          e.preventDefault();
          document.execCommand('formatBlock', false, 'code');
          saveToHistory();
        } else if (e.key === '1') {
          e.preventDefault();
          insertFormat('h1');
          saveToHistory();
        } else if (e.key === '2') {
          e.preventDefault();
          insertFormat('h2');
          saveToHistory();
        } else if (e.key === '3') {
          e.preventDefault();
          insertFormat('h3');
          saveToHistory();
        } else if (e.key === '4') {
          e.preventDefault();
          insertFormat('h4');
          saveToHistory();
        } else if (e.key === '0') {
          e.preventDefault();
          insertFormat('p');
          saveToHistory();
        } else if (e.key === 'g' || e.key === 'G' || e.key === 'Г' || e.key === 'г') {
          e.preventDefault();
          document.execCommand('insertUnorderedList', false, null);
          saveToHistory();
        } else if ((e.key === 'o' || e.key === 'O'|| e.key === 'О' || e.key === 'о') && e.shiftKey) {
          e.preventDefault();
          document.execCommand('insertOrderedList', false, null);
          saveToHistory();
        } else if (e.key === 't' || e.key === 'T' || e.key === 'т' || e.key === 'Т') {
          e.preventDefault();
          insertTable();
        } else if (e.key === 'D' || e.key === 'd'|| e.key === 'Д' || e.key === 'д') {
          if (e.shiftKey) {
            e.preventDefault();
            // Remove text color (reset to dark gray)
            const selection = window.getSelection();
            if (selection.toString() && editor.contains(selection.anchorNode)) {
              document.execCommand('foreColor', false, 'rgb(31, 41, 55)');
              saveToHistory();
            }
          } else {
            e.preventDefault();
            // Apply last used text color
            const lastColor = localStorage.getItem('mdEditorTextColor') || '#1f2937';
            applyFormatting('color', lastColor);
            saveToHistory();
          }
        } else if (e.key === 'q' || e.key === 'Q' || e.key === 'я' || e.key === 'Я') {
          e.preventDefault();
          insertBlockquote();
        } else if ((e.key === 'z' || e.key === 'Z'|| e.key === 'З' || e.key === 'з') && !e.shiftKey) {
          e.preventDefault();
          if (historyIndex > 0) {
            historyIndex--;
            editor.innerHTML = history[historyIndex];
          }
        } else if (((e.key === 'z' || e.key === 'Z') && e.shiftKey) || (e.key === 'y' || e.key === 'Y')) {
          e.preventDefault();
          if (historyIndex < history.length - 1) {
            historyIndex++;
            editor.innerHTML = history[historyIndex];
          }
        } else if (e.key === 'm' || e.key === 'M' || e.key === 'М' || e.key === 'м') {
          if (e.shiftKey) {
            e.preventDefault();
            // Remove text color (reset to black)
            const selection = window.getSelection();
            if (selection.toString() && editor.contains(selection.anchorNode)) {
              document.execCommand('foreColor', false, 'rgb(31, 41, 55)');
              saveToHistory();
            }
          } else {
            e.preventDefault();
            // Apply last used text color
            const lastColor = localStorage.getItem('mdEditorTextColor') || '#1f2937';
            applyFormatting('color', lastColor);
            saveToHistory();
          }
        } else if ((e.key === 'c' || e.key === 'C' || e.key === 'С' || e.key === 'с') && e.altKey) {
          e.preventDefault();
          // Apply last used text color
          const lastColor = localStorage.getItem('mdEditorTextColor') || '#1f2937';
          applyFormatting('color', lastColor);
          saveToHistory();
        } else if (e.key === 'h' || e.key === 'H' || e.key === 'Х' || e.key === 'х') {
          if (e.shiftKey) {
            e.preventDefault();
            // Remove highlight
            const selection = window.getSelection();
            if (selection.toString() && editor.contains(selection.anchorNode)) {
              document.execCommand('backColor', false, 'transparent');
              saveToHistory();
            }
          } else {
            e.preventDefault();
            // Apply last used highlight color
            const lastHighlight = localStorage.getItem('mdEditorHighlight') || '#ffeb3b';
            applyFormatting('highlight', lastHighlight);
            saveToHistory();
          }
        }
      }
    });

    // CRITICAL: Prevent browser from wrapping list content in <p> tags
    // This event fires BEFORE the change is made, allowing us to prevent it
    editor.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph') {
        // Check if we're in a list item
        const selection = window.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          
          while (node && node !== editor) {
            if (node.nodeType === 1 && node.tagName === 'LI') {
              // We're in a list item - don't prevent, let browser handle it
              // But the input event will clean up any unwanted tags
              return;
            }
            node = node.parentNode;
          }
        }
      }
    });

    // Save to history on input and detect "---" for horizontal rule
    editor.addEventListener('input', () => {
      // Debounced history save (don't save on every keystroke)
      clearTimeout(editor.historyTimeout);
      editor.historyTimeout = setTimeout(() => {
        saveToHistory();
      }, 500);
      
      // CRITICAL: Convert unwanted <div> elements to <p> tags to prevent font size issues
      // Only convert top-level divs that are not part of special structures (tables, etc)
      const unwantedDivs = editor.querySelectorAll(':scope > div');
      unwantedDivs.forEach(div => {
        // Skip divs that are part of special structures (if any)
        const p = document.createElement('p');
        // Move all children to the new paragraph
        while (div.firstChild) {
          p.appendChild(div.firstChild);
        }
        // Copy useful attributes if any
        Array.from(div.attributes).forEach(attr => {
          if (attr.name !== 'style' && attr.name !== 'class') {
            p.setAttribute(attr.name, attr.value);
          }
        });
        div.parentNode.replaceChild(p, div);
      });
      
      // SAFE: Only remove completely empty <p> tags using textContent manipulation
      // Instead of innerHTML which breaks cursor position
      const emptyParagraphs = editor.querySelectorAll('p');
      emptyParagraphs.forEach(p => {
        if (p.textContent.trim() === '' && !p.querySelector('input, img, br')) {
          p.remove();
        }
      });
      
      // Auto-convert "---" to horizontal rule and "~~~" to dashed divider
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        
        // Find parent paragraph
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'P' || node.tagName === 'DIV')) {
            const text = node.textContent.trim();
            if (text === '---' && node.tagName === 'P') {
              // Replace this paragraph with <hr>
              const hr = document.createElement('hr');
              node.parentNode.replaceChild(hr, node);
              
              // Create new paragraph after hr and focus there
              const newP = document.createElement('p');
              newP.innerHTML = '<br>';
              hr.parentNode.insertBefore(newP, hr.nextSibling);
              
              const newRange = document.createRange();
              newRange.setStart(newP, 0);
              newRange.collapse(true);
              selection.removeAllRanges();
              selection.addRange(newRange);
              
              saveToHistory();
            } else if (text === '~~~' && node.tagName === 'P') {
              // Replace this paragraph with dashed <hr>
              const hr = document.createElement('hr');
              hr.style.cssText = 'border: none; border-top: 2px dashed #8B6F47;';
              node.parentNode.replaceChild(hr, node);
              
              // Create new paragraph after hr and focus there
              const newP2 = document.createElement('p');
              newP2.innerHTML = '<br>';
              hr.parentNode.insertBefore(newP2, hr.nextSibling);
              
              const newRange2 = document.createRange();
              newRange2.setStart(newP2, 0);
              newRange2.collapse(true);
              selection.removeAllRanges();
              selection.addRange(newRange2);
              
              saveToHistory();
            }
            break;
          }
          node = node.parentNode;
        }
      }
    });

    // Handle copy events - convert to clean markdown
    editor.addEventListener('copy', (e) => {
      const selection = window.getSelection();
      if (selection.toString().length === 0) return;
      
      e.preventDefault();
      
      try {
        // Get the HTML content from selection
        const range = selection.getRangeAt(0);
        const fragment = range.cloneContents();
        const div = document.createElement('div');
        div.appendChild(fragment);
        
        let html = div.innerHTML;
        
        // Clean up the HTML before converting to markdown
        // Remove BR tags only inside list items (browser artifacts)
        // Don't remove all BR tags globally as they may be important for structure
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        // Remove BR tags specifically from within LI elements
        tempDiv.querySelectorAll('li').forEach(li => {
          li.querySelectorAll('br').forEach(br => br.remove());
        });
        
        html = tempDiv.innerHTML;
        
        // Remove empty paragraphs
        html = html.replace(/<p>\s*<\/p>/gi, '');
        
        // Convert HTML to markdown
        const markdown = htmlToMarkdown(html);
        
        // Set clipboard - use markdown as plain text
        e.clipboardData.setData('text/plain', markdown);
        e.clipboardData.setData('text/html', html);
        
        console.log('Copied markdown:', markdown);
      } catch (error) {
        console.error('Error in copy handler:', error);
        // Fallback - let browser handle it
      }
    });

    // Handle paste events - convert markdown to HTML and insert
    editor.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text/plain');
      
      // Get current selection
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return;
      
      const range = selection.getRangeAt(0);
      
      // Convert markdown to HTML
      const html = markdownToHtml(text);
      
      // Create temporary container with the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Remove all style attributes to prevent font size changes
      const allElements = tempDiv.querySelectorAll('*');
      allElements.forEach(el => {
        el.removeAttribute('style');
        // Also remove font-related attributes
        el.removeAttribute('size');
        el.removeAttribute('face');
      });
      
      // CRITICAL: Convert any unwanted <div> elements to <p>
      // This prevents browser from wrapping content in divs with wrong font size
      const divs = tempDiv.querySelectorAll(':scope > div');
      divs.forEach(div => {
        const p = document.createElement('p');
        // Copy all children
        while (div.firstChild) {
          p.appendChild(div.firstChild);
        }
        // Copy attributes if any
        Array.from(div.attributes).forEach(attr => {
          if (attr.name !== 'style') {
            p.setAttribute(attr.name, attr.value);
          }
        });
        div.parentNode.replaceChild(p, div);
      });
      
      // Delete current selection
      range.deleteContents();
      
      // Insert HTML nodes directly - preserves list structure including nested lists
      let lastNode = null;
      while (tempDiv.firstChild) {
        const node = tempDiv.firstChild;
        range.insertNode(node);
        lastNode = node;
        range.setStartAfter(node);
      }
      
      // Move cursor after all inserted content
      if (lastNode) {
        range.setStartAfter(lastNode);
        range.collapse(true);
      }
      
      selection.removeAllRanges();
      selection.addRange(range);
      
      // CRITICAL: Clean up empty paragraphs (<p><br></p> or <p></p>) that browser may add
      // Do this immediately after paste, before input event
      const emptyParagraphs = editor.querySelectorAll('p');
      emptyParagraphs.forEach(p => {
        // Check if paragraph is empty (only whitespace or just <br>)
        const textContent = p.textContent.trim();
        const hasOnlyBr = p.children.length === 1 && p.querySelector('br') && textContent === '';
        const isEmpty = textContent === '' && !p.querySelector('img, input, table, ul, ol, h1, h2, h3, h4, h5, h6, blockquote');
        
        if (isEmpty || hasOnlyBr) {
          // Only remove if it's not between list items (to preserve list structure)
          const prevSibling = p.previousElementSibling;
          const nextSibling = p.nextElementSibling;
          const isBetweenListItems = (prevSibling && (prevSibling.tagName === 'LI' || prevSibling.tagName === 'UL' || prevSibling.tagName === 'OL')) &&
                                    (nextSibling && (nextSibling.tagName === 'LI' || nextSibling.tagName === 'UL' || nextSibling.tagName === 'OL'));
          
          if (!isBetweenListItems) {
            p.remove();
          }
        }
      });
      
      // Trigger input event to save history
      editor.dispatchEvent(new Event('input', { bubbles: true }));
    });
    // Click handler for links (Ctrl+Click to open)
    editor.addEventListener('click', (e) => {
      // Check if clicking on a link
      let target = e.target;
      
      // Find parent link if clicking on child element
      while (target && target !== editor) {
        if (target.tagName === 'A') {
          // Ctrl+Click or Cmd+Click to open link
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              window.open(href, '_blank');
              
              // Show notification
              const notification = document.createElement('div');
              notification.textContent = `🔗 Opening: ${href}`;
              notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #2563eb; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
              document.body.appendChild(notification);
              
              setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
              }, 2000);
            }
          } else {
            // Regular click - show tooltip
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              const tooltip = document.createElement('div');
              tooltip.textContent = `Ctrl+Click to open: ${href}`;
              tooltip.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #374151; color: white; padding: 8px 14px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 12px;';
              document.body.appendChild(tooltip);
              
              setTimeout(() => {
                tooltip.style.transition = 'opacity 0.3s';
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
              }, 1500);
            }
          }
          break;
        }
        target = target.parentElement;
      }
    });

    // Escape HTML special characters
    function escapeHtml(text) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, m => map[m]);
    }

    // HTML to Markdown conversion
    function htmlToMarkdown(html) {
      let markdown = '';
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + html + '</div>', 'text/html');
      
      const processNode = (node, insideListItem = false, depth = 0) => {
        if (node.nodeType === 3) {
          // Text node
          return node.textContent;
        } else if (node.nodeType === 1) {
          const tag = node.tagName.toLowerCase();
          
          if (tag === 'h1') {
            return '# ' + processChildren(node, false, depth) + '\n';
          } else if (tag === 'h2') {
            return '## ' + processChildren(node, false, depth) + '\n';
          } else if (tag === 'h3') {
            return '### ' + processChildren(node, false, depth) + '\n';
          } else if (tag === 'h4') {
            return '#### ' + processChildren(node, false, depth) + '\n';
          } else if (tag === 'p') {
            // Special handling: if inside list item, don't add newline
            if (insideListItem) {
              return processChildren(node, true, depth);
            }
            return processChildren(node, false, depth) + '\n';
          } else if (tag === 'strong' || tag === 'b') {
            return '**' + processChildren(node, insideListItem, depth) + '**';
          } else if (tag === 'em' || tag === 'i') {
            return '*' + processChildren(node, insideListItem, depth) + '*';
          } else if (tag === 'u') {
            return '__' + processChildren(node, insideListItem, depth) + '__';
          } else if (tag === 'code') {
            return '`' + processChildren(node, insideListItem, depth) + '`';
          } else if (tag === 'a') {
            return '[' + processChildren(node, insideListItem, depth) + '](' + (node.href || '#') + ')';
          } else if (tag === 'img') {
            const alt = node.getAttribute('alt') || '';
            
            // Generate path from alt text (all images are in assets/ folder)
            // If alt is "ДН", generate "assets/ДН.png"
            let src = '';
            if (alt) {
              // Try to detect file extension from src if it's not base64
              let ext = '.png'; // default
              if (node.src && !node.src.startsWith('data:')) {
                const match = node.src.match(/\.([a-z]+)$/i);
                if (match) ext = '.' + match[1];
              }
              src = 'assets/' + alt + ext;
            }
            
            // Skip if no alt text (can't generate filename)
            if (!src) return '';
            
            return '![' + alt + '](' + src + ')';
          } else if (tag === 'blockquote') {
            return '> ' + processChildren(node, false, depth).trim() + '\n';
          } else if (tag === 'ul') {
            let items = '';
            const itemIndent = '  '.repeat(depth);
            
            // Process both direct LI children and direct nested UL/OL children
            for (let child of node.childNodes) {
              if (child.nodeType === 1) {
                const childTag = child.tagName.toLowerCase();
                
                if (childTag === 'li') {
                  // Process list item
                  let textContent = '';
                  let nestedLists = [];
                  
                  for (let liChild of child.childNodes) {
                    if (liChild.nodeType === 3) {
                      // Text node
                      textContent += liChild.textContent;
                    } else if (liChild.nodeType === 1) {
                      const liChildTag = liChild.tagName.toLowerCase();
                      if (liChildTag === 'ul' || liChildTag === 'ol') {
                        // Save nested list for later
                        nestedLists.push(liChild);
                      } else {
                        // Process other elements (strong, em, span, p, etc.)
                        textContent += processNode(liChild, true, depth);
                      }
                    }
                  }
                  
                  // Add main item
                  items += itemIndent + '- ' + textContent.trim() + '\n';
                  
                  // Process all nested lists with increased depth
                  nestedLists.forEach(nestedList => {
                    const nestedItems = processNode(nestedList, false, depth + 1);
                    items += nestedItems;
                  });
                } else if (childTag === 'ul' || childTag === 'ol') {
                  // Direct nested list (without LI wrapper)
                  const nestedItems = processNode(child, false, depth + 1);
                  items += nestedItems;
                }
              }
            }
            return items;
          } else if (tag === 'ol') {
            let items = '';
            let counter = 1;
            const itemIndent = '  '.repeat(depth);
            
            // Process both direct LI children and direct nested UL/OL children
            for (let child of node.childNodes) {
              if (child.nodeType === 1) {
                const childTag = child.tagName.toLowerCase();
                
                if (childTag === 'li') {
                  // Process list item
                  let textContent = '';
                  let nestedLists = [];
                  
                  for (let liChild of child.childNodes) {
                    if (liChild.nodeType === 3) {
                      // Text node
                      textContent += liChild.textContent;
                    } else if (liChild.nodeType === 1) {
                      const liChildTag = liChild.tagName.toLowerCase();
                      if (liChildTag === 'ul' || liChildTag === 'ol') {
                        // Save nested list for later
                        nestedLists.push(liChild);
                      } else {
                        // Process other elements (strong, em, span, p, etc.)
                        textContent += processNode(liChild, true, depth);
                      }
                    }
                  }
                  
                  // Add main item
                  items += itemIndent + counter + '. ' + textContent.trim() + '\n';
                  counter++;
                  
                  // Process all nested lists with increased depth
                  nestedLists.forEach(nestedList => {
                    const nestedItems = processNode(nestedList, false, depth + 1);
                    items += nestedItems;
                  });
                } else if (childTag === 'ul' || childTag === 'ol') {
                  // Direct nested list (without LI wrapper)
                  const nestedItems = processNode(child, false, depth + 1);
                  items += nestedItems;
                }
              }
            }
            return items;
          } else if (tag === 'hr') {
            return '---\n';
          } else if (tag === 'table') {
            return processTable(node) + '\n';
          } else if (tag === 'br') {
            return '\n';
          } else if (tag === 'pre') {
            return '```\n' + node.textContent + '\n```\n';
          } else {
            return processChildren(node, insideListItem, depth);
          }
        }
        return '';
      };
      
      const processChildren = (node, insideListItem = false, depth = 0) => {
        let result = '';
        for (let child of node.childNodes) {
          result += processNode(child, insideListItem, depth);
        }
        return result;
      };
      
      const processTable = (table) => {
        let markdown = '';
        const rows = table.querySelectorAll('tr');
        
        rows.forEach((row, rowIdx) => {
          const cells = row.querySelectorAll('td, th');
          markdown += '| ';
          cells.forEach(cell => {
            // Process cell content and replace newlines with <br>
            let cellContent = processChildren(cell).replace(/\n/g, '<br>').trim();
            markdown += cellContent + ' | ';
          });
          markdown += '\n';
          
          if (rowIdx === 0) {
            markdown += '| ';
            for (let i = 0; i < cells.length; i++) {
              markdown += '--- | ';
            }
            markdown += '\n';
          }
        });
        
        return markdown;
      };
      
      markdown = processChildren(doc.querySelector('div'));
      
      // Clean up multiple consecutive newlines and trim
      return markdown.replace(/\n\n+/g, '\n').trim();
    }

    // Markdown to HTML conversion with proper nested lists
    function markdownToHtml(markdown) {
      let html = '';
      const lines = markdown.split(/\r?\n/);
      let i = 0;
      let iterations = 0;
      const MAX_ITERATIONS = 10000; // Safety limit
      
      while (i < lines.length && iterations < MAX_ITERATIONS) {
        iterations++;
        const line = lines[i];
        
        // Skip empty lines
        if (!line.trim()) {
          i++;
          continue;
        }
        
        // Headings
        if (line.startsWith('#### ')) {
          html += '<h4>' + applyInlineFormatting(line.substring(5)) + '</h4>';
          i++;
        } else if (line.startsWith('### ')) {
          html += '<h3>' + applyInlineFormatting(line.substring(4)) + '</h3>';
          i++;
        } else if (line.startsWith('## ')) {
          html += '<h2>' + applyInlineFormatting(line.substring(3)) + '</h2>';
          i++;
        } else if (line.startsWith('# ')) {
          html += '<h1>' + applyInlineFormatting(line.substring(2)) + '</h1>';
          i++;
        }
        // Blockquote
        else if (line.startsWith('> ')) {
          html += '<blockquote>' + applyInlineFormatting(line.substring(2)) + '</blockquote>';
          i++;
        }
        // Horizontal rule
        else if (line.trim() === '---' || line.trim() === '***' || line.trim() === '___') {
          html += '<hr>';
          i++;
        }
        // Lists - use processListBlock for proper nesting
        else if (line.match(/^\s*[-*]\s+/) || line.match(/^\s*\d+\.\s+/)) {
          const oldI = i;
          const listResult = processListBlock(lines, i);
          html += listResult.html;
          i = listResult.nextIndex;
          
          // Safety check: make sure i moved forward
          if (i <= oldI) {
            console.error('processListBlock did not advance! Breaking to prevent infinite loop.');
            i = oldI + 1; // Force advance
          }
        }
        // Tables
        else if (line.includes('|')) {
          let tableHtml = '<table><tbody>';
          let tableIterations = 0;
          while (i < lines.length && lines[i].includes('|') && tableIterations < 1000) {
            tableIterations++;
            const cells = lines[i].split('|').map(c => c.trim()).filter(c => c !== '');
            
            // Skip header separator lines (lines where ALL cells are dashes/colons)
            const isHeaderSeparator = cells.length > 0 && cells.every(c => /^:?-+:?$/.test(c));
            
            if (cells.length > 0 && !isHeaderSeparator) {
              tableHtml += '<tr>';
              cells.forEach(cell => {
                tableHtml += '<td>' + applyInlineFormatting(cell) + '</td>';
              });
              tableHtml += '</tr>';
            }
            i++;
          }
          tableHtml += '</tbody></table>';
          html += tableHtml;
        }
        // Paragraphs
        else {
          html += '<p>' + applyInlineFormatting(line) + '</p>';
          i++;
        }
      }
      
      if (iterations >= MAX_ITERATIONS) {
        console.error('markdownToHtml: MAX_ITERATIONS reached! Returning partial HTML.');
      }
      
      return html;
    }
    
    // Process a block of list lines and create proper nested HTML
    function processListBlock(lines, startIndex) {
      let i = startIndex;
      let html = '';
      let iterations = 0;
      const MAX_ITERATIONS = 1000;
      
      // Simple approach: build list recursively by level
      function processListAtLevel(startIdx, minLevel) {
        let idx = startIdx;
        let result = '';
        let currentTag = null;
        
        while (idx < lines.length && iterations < MAX_ITERATIONS) {
          iterations++;
          const line = lines[idx];
          
          if (!line.trim()) {
            idx++;
            continue;
          }
          
          const match = line.match(/^(\s*)([-*]|\d+\.)\s+(.*)$/);
          if (!match) break;
          
          const indent = match[1].length;
          const level = Math.floor(indent / 2);
          const marker = match[2];
          const content = match[3];
          const tag = /^\d+\.$/.test(marker) ? 'ol' : 'ul';
          
          // If level is less than minLevel, stop and return
          if (level < minLevel) break;
          
          // If level is greater than minLevel, recursively process nested list
          if (level > minLevel) {
            const nested = processListAtLevel(idx, level);
            result += nested.html;
            idx = nested.nextIdx;
            continue;
          }
          
          // Same level
          if (currentTag !== tag) {
            if (currentTag) result += '</' + currentTag + '>';
            currentTag = tag;
            result += '<' + tag + '>';
          }
          
          result += '<li>' + applyInlineFormatting(content) + '</li>';
          idx++;
        }
        
        if (currentTag) result += '</' + currentTag + '>';
        return { html: result, nextIdx: idx };
      }
      
      const listResult = processListAtLevel(startIndex, 0);
      return { html: listResult.html, nextIndex: listResult.nextIdx };
    }

    // Apply inline formatting (bold, italic, code, links, images)
    function applyInlineFormatting(text) {
      // Images must be processed before links
      text = text.replace(/!\[(.*?)\]\((.*?)\)/g, (match, alt, src) => {
        // If we have a base path and src is relative, create absolute path for display
        if (globalImageBasePath && !src.startsWith('http://') && !src.startsWith('https://') && !src.startsWith('data:') && !src.startsWith('file://')) {
          const absoluteSrc = globalImageBasePath + src;
          return `<img src="${absoluteSrc}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
        }
        // Always preserve the original src in data-original-src
        return `<img src="${src}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
      });
      text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/__(.*?)__/g, '<u>$1</u>');
      text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
      text = text.replace(/`(.*?)`/g, '<code>$1</code>');
      text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
      // Handle <br> tags
      text = text.replace(/<br\s*\/?>/gi, '<br>');
      return text;
    }

    // Load saved content from localStorage OR from URL parameter
    window.addEventListener('load', () => {
      // Check if there's a path parameter (coming from md-viewer)
      const urlParams = new URLSearchParams(window.location.search);
      const filePath = urlParams.get('path');
      const loadFromHash = urlParams.get('loadFromHash');
      const editMode = urlParams.get('editMode');
      
      // Check for sessionStorage content (from md-viewer edit button)
      if (editMode === 'true') {
        const sessionContent = sessionStorage.getItem('editFileContent');
        const sessionPath = sessionStorage.getItem('editFilePath');
        
        if (sessionContent && sessionPath) {
          try {
            // Set global base path for images
            const basePath = sessionPath.substring(0, sessionPath.lastIndexOf('/') + 1);
            
            if (window.location.protocol === 'file:') {
              const currentPath = window.location.pathname;
              const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
              globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
            } else {
              const currentOrigin = window.location.origin;
              globalImageBasePath = currentOrigin + '/' + basePath;
            }
            
            console.log('Global Image Base Path:', globalImageBasePath);
            
            // Parse content (could be HTML or Markdown)
            isLoadingFile = true;
            let html = '';
            const fileName = sessionPath.split('/').pop();
            const isHtmlFile = fileName.endsWith('.html');
            
            if (isHtmlFile && sessionContent.includes('<!DOCTYPE')) {
              // It's HTML - extract body content
              const parser = new DOMParser();
              const doc = parser.parseFromString(sessionContent, 'text/html');
              html = doc.body.innerHTML.trim();
            } else {
              // Treat as Markdown
              html = markdownToHtml(sessionContent);
            }
            
            editor.innerHTML = html;
            saveToHistory();
            setTimeout(() => { isLoadingFile = false; }, 100);
            
            // Update page title
            const cleanName = fileName.replace(/\.(md|txt|html)$/i, '').replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '');
            document.title = cleanName + ' — Markdown Editor';
            
            // Clear sessionStorage
            sessionStorage.removeItem('editFileContent');
            sessionStorage.removeItem('editFilePath');
            
            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
          } catch (err) {
            alert('Грешка при зареждане на съдържанието: ' + err.message);
            console.error('Load error:', err);
            sessionStorage.removeItem('editFileContent');
            sessionStorage.removeItem('editFilePath');
          }
        }
      }
      
      if (loadFromHash === 'true' && window.location.hash) {
        // Load from URL hash (content passed from index.html)
        try {
          const markdownContent = decodeURIComponent(window.location.hash.substring(1));
          
          // Set global base path for images
          if (filePath) {
            const basePath = filePath.substring(0, filePath.lastIndexOf('/') + 1);
            
            // For file:// protocol, construct path differently
            if (window.location.protocol === 'file:') {
              // Get the directory of the current HTML file
              const currentPath = window.location.pathname;
              const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
              globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
            } else {
              // For http:// or https://
              const currentOrigin = window.location.origin;
              globalImageBasePath = currentOrigin + '/' + basePath;
            }
            
            console.log('Global Image Base Path:', globalImageBasePath);
          }
          
          // Convert markdown to HTML (now with absolute image paths built-in)
          isLoadingFile = true;
          const html = markdownToHtml(markdownContent);
          editor.innerHTML = html;
          setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
          
          history = [editor.innerHTML];
          historyIndex = 0;
          
          // Update page title
          if (filePath) {
            const fileName = filePath.split('/').pop();
            document.title = fileName.replace(/\.(md|txt)$/i, '').replace(/^\d+-/, '').replace(/^msg-/i, '') + ' — Markdown Editor';
          }
          
          // Clear URL parameters to prevent auto-reload on refresh
          window.history.replaceState({}, document.title, window.location.pathname);
        } catch (err) {
          alert('Грешка при зареждане на съдържанието: ' + err.message);
          console.error('Load error:', err);
        }
      } else if (filePath) {
        // Original fetch-based loading (kept for backward compatibility)
        const decodedPath = decodeURIComponent(filePath);
        const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
        const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
          ? new URL(encodedPath, window.location.origin).href
          : encodedPath;
        
        // Load file from path
        fetch(absoluteUrl)
          .then(r => {
            if (!r.ok) throw new Error('HTTP ' + r.status);
            return r.text();
          })
          .then(content => {
            // Determine if it's HTML or Markdown based on file extension
            const fileName = decodedPath.split('/').pop();
            const isHtmlFile = fileName.endsWith('.html');
            
            isLoadingFile = true;
            let html = '';
            
            if (isHtmlFile) {
              // It's HTML - extract ONLY what's between <body> tags, NOT the <head>
              const bodyMatch = content.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
              if (bodyMatch) {
                html = bodyMatch[1];
              } else {
                // Fallback: if no body tags, this is probably a corrupted file
                // Try to extract everything after </head> or <body> markers
                const headEndMatch = content.match(/<\/head\s*>/i);
                if (headEndMatch) {
                  // Find everything after </head>
                  const headEndIndex = headEndMatch.index + headEndMatch[0].length;
                  let afterHead = content.substring(headEndIndex);
                  // Remove opening <body> tag if present
                  afterHead = afterHead.replace(/^<body[^>]*>/i, '');
                  // Remove closing tags
                  afterHead = afterHead.replace(/<\/body\s*>[\s\S]*$/i, '');
                  html = afterHead;
                } else {
                  // Last resort - use empty content
                  html = '';
                }
              }
              
              // REMOVE ALL <br> tags between list items - this fixes the indent list problem
              // Loop until no more <br> tags found between list elements
              let prevHtml;
              do {
                prevHtml = html;
                // Remove <br> between any list-related closing and opening tags
                html = html.replace(/<\/(li|ul|ol)>\s*<br\s*\/?>\s*</gi, '</$1><');
              } while (html !== prevHtml);
              
              // Also remove leading empty <br> and whitespace
              html = html.replace(/^\s*<br\s*\/?>\s*/i, '');
              // CRITICAL: Remove all block-level tags that shouldn't be in contenteditable
              // Keep only formatting tags: strong, em, u, code, a, img, li, ul, ol, h1-h4, blockquote, table
              // Remove: p, div, span, style, meta, script, head, body, html, link, etc.
              
              // First, unwrap <p> tags - keep content but remove the tag itself
              html = html.replace(/<\/?p[^>]*>/gi, '');
              
              // Remove <div> tags but keep content
              html = html.replace(/<\/?div[^>]*>/gi, '');
              
              // Remove <span> tags but keep content
              html = html.replace(/<\/?span[^>]*>/gi, '');
              
              // Remove ALL <style> blocks
              html = html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
              
              // Remove ALL <script> blocks
              html = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
              
              // Remove <meta> tags
              html = html.replace(/<meta[^>]*>/gi, '');
              
              // Remove <link> tags
              html = html.replace(/<link[^>]*>/gi, '');
              
              // Remove <title> tags
              html = html.replace(/<title[^>]*>[\s\S]*?<\/title>/gi, '');
              
              // Remove <head> tags
              html = html.replace(/<\/?head[^>]*>/gi, '');
              
              // Remove <html> tags
              html = html.replace(/<\/?html[^>]*>/gi, '');
            } else {
              // It's Markdown - convert to HTML
              html = markdownToHtml(content);
            }
            
            editor.innerHTML = html;
            
            // CRITICAL: After setting innerHTML, remove all <br> tags that are between list items
            // This prevents visual empty lines that appear when editing
            let editorHtml = editor.innerHTML;
            let prevEditorHtml;
            do {
              prevEditorHtml = editorHtml;
              // Remove <br> between list-related tags
              editorHtml = editorHtml.replace(/<\/(li|ul|ol)>\s*<br\s*\/?>\s*</gi, '</$1><');
            } while (editorHtml !== prevEditorHtml);
            
            editor.innerHTML = editorHtml;
            
            setTimeout(() => { isLoadingFile = false; }, 100);
            history = [editorHtml];
            historyIndex = 0;
            
            // Update page title
            document.title = fileName.replace(/\.(md|txt|html)$/i, '') + ' — Markdown Editor';
          })
          .catch(err => {
            const isFile = window.location.protocol === 'file:';
            const hint = isFile
              ? '\n\nСъвет: Отвори сайта през локален HTTP сървър (напр. VS Code Live Server), тъй като браузърите блокират fetch от file://'
              : '';
            alert('Грешка при зареждане на файла: ' + err.message + hint);
            console.error('Load error:', err);
          });
      } else {
        // Load from localStorage if no path parameter
        const saved = localStorage.getItem('mdEditorContent');
        if (saved) {
          editor.innerHTML = saved;
          history = [saved];
          historyIndex = 0;
        }
      }
    });

    // Auto-save to localStorage (only when user is actually editing, not loading files)
    editor.addEventListener('input', () => {
      if (isLoadingFile) return; // Don't save during file load
      
      clearTimeout(editor.saveTimeout);
      editor.saveTimeout = setTimeout(() => {
        localStorage.setItem('mdEditorContent', editor.innerHTML);
      }, 2000);
    });

    // Table context menu
    // Edit table button - copy table and open Tables Generator

    // Function to import table from clipboard
    function importTableFromClipboard() {
      navigator.clipboard.readText().then(html => {
        // Check if it's a table
        if (html.includes('<table')) {
          const fragment = document.createRange().createContextualFragment(html);
          const range = window.getSelection().getRangeAt(0);
          range.insertNode(fragment);
          saveToHistory();
          alert('Table imported successfully!');
        } else {
          alert('Clipboard does not contain a table. Please copy HTML table from tablesgenerator.com');
        }
      }).catch(err => {
        console.error('Failed to read clipboard:', err);
      });
    }

    // Add keyboard shortcut for importing: Ctrl+Shift+V
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'V') {
        e.preventDefault();
        importTableFromClipboard();
      }
    });

    // Table column resizing functionality
    let resizingColumn = null;
    let resizingTable = null;
    let startX = 0;
    let startWidth = 0;
    let originalTableWidth = 0;

    editor.addEventListener('mousedown', (e) => {
      // Check if clicking on column resize handle
      if (e.target.tagName === 'TD' || e.target.tagName === 'TH') {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        if (isAtRightEdge && e.clientX > rect.left + 10) {
          const row = cell.closest('tr');
          const table = cell.closest('table');
          const isLastCell = cell.cellIndex === row.cells.length - 1;
          
          // Set fixed widths for all cells in all rows
          const allRows = table.querySelectorAll('tr');
          allRows.forEach(r => {
            for (let i = 0; i < r.cells.length; i++) {
              const c = r.cells[i];
              c.style.width = c.offsetWidth + 'px';
            }
          });
          table.style.tableLayout = 'fixed';
          originalTableWidth = table.offsetWidth;
          
          if (isLastCell) {
            resizingTable = table;
            startWidth = table.offsetWidth;
          } else {
            resizingColumn = cell;
            startWidth = cell.offsetWidth;
          }
          startX = e.clientX;
          document.body.style.cursor = isLastCell ? 'ew-resize' : 'col-resize';
          e.preventDefault();
        }
      }
    });

    document.addEventListener('mousemove', (e) => {
      // Handle table resize (when dragging last column edge)
      if (resizingTable) {
        const diff = e.clientX - startX;
        const newWidth = Math.max(100, startWidth + diff);
        resizingTable.style.width = newWidth + 'px';
        document.body.style.cursor = 'ew-resize';
      }
      // Handle column resize - ONLY change the dragged column
      else if (resizingColumn) {
        const diff = e.clientX - startX;
        const newWidth = Math.max(30, startWidth + diff);
        const colIndex = resizingColumn.cellIndex;
        const table = resizingColumn.closest('table');
        
        if (table) {
          // Update ONLY the dragged column width
          const allRows = table.querySelectorAll('tr');
          allRows.forEach(r => {
            if (r.cells[colIndex]) {
              r.cells[colIndex].style.width = newWidth + 'px';
            }
          });
          // Adjust table width to maintain layout
          table.style.width = (originalTableWidth + diff) + 'px';
        }
        document.body.style.cursor = 'col-resize';
      }
    });

    document.addEventListener('mouseup', () => {
      if (resizingTable || resizingColumn) {
        saveToHistory();
        resizingTable = null;
        resizingColumn = null;
        document.body.style.cursor = 'default';
      }
    });

    // Update cursor style for column resize hover
    editor.addEventListener('mouseover', (e) => {
      if ((e.target.tagName === 'TD' || e.target.tagName === 'TH') && !resizingColumn) {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        
        if (isAtRightEdge && e.clientX > rect.left + 50) {
          document.body.style.cursor = 'col-resize';
        } else {
          document.body.style.cursor = 'default';
        }
      }
    });

    editor.addEventListener('mousemove', (e) => {
      if (!resizingColumn && (e.target.tagName === 'TD' || e.target.tagName === 'TH')) {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        
        if (isAtRightEdge && e.clientX > rect.left + 50) {
          document.body.style.cursor = 'col-resize';
        } else {
          document.body.style.cursor = 'default';
        }
      }
    });

    // Anchor Link Functions
    let anchorLinkModalOpen = false;
    let savedAnchorSelection = null; // Save selection when modal opens

    document.getElementById('anchorLinkBtn').addEventListener('click', () => {
      // Save current selection BEFORE opening modal
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        savedAnchorSelection = selection.getRangeAt(0).cloneRange();
      }
      
      document.getElementById('anchorLinkModal').style.display = 'block';
      anchorLinkModalOpen = true;
      refreshAnchorsList();
    });

    document.getElementById('closeAnchorLinkModalBtn').addEventListener('click', () => {
      document.getElementById('anchorLinkModal').style.display = 'none';
      anchorLinkModalOpen = false;
    });

    // Tab switching
    document.getElementById('createAnchorTabBtn').addEventListener('click', () => {
      document.getElementById('createAnchorTab').style.display = 'block';
      document.getElementById('linkToAnchorTab').style.display = 'none';
      document.getElementById('createAnchorTabBtn').style.background = '#2563eb';
      document.getElementById('createAnchorTabBtn').style.color = 'white';
      document.getElementById('linkToAnchorTabBtn').style.background = '#d1d5db';
      document.getElementById('linkToAnchorTabBtn').style.color = '#374151';
    });

    document.getElementById('linkToAnchorTabBtn').addEventListener('click', () => {
      document.getElementById('createAnchorTab').style.display = 'none';
      document.getElementById('linkToAnchorTab').style.display = 'block';
      document.getElementById('linkToAnchorTabBtn').style.background = '#2563eb';
      document.getElementById('linkToAnchorTabBtn').style.color = 'white';
      document.getElementById('createAnchorTabBtn').style.background = '#d1d5db';
      document.getElementById('createAnchorTabBtn').style.color = '#374151';
      refreshAnchorsList();
    });

    // Create Anchor
    document.getElementById('createAnchorBtn').addEventListener('click', () => {
      const anchorId = document.getElementById('anchorIdInput').value.trim().toLowerCase().replace(/\s+/g, '-');
      const anchorText = document.getElementById('anchorTextInput').value.trim();
      const headingType = document.getElementById('anchorHeadingTypeInput').value;

      if (!anchorId || !anchorText) {
        alert('⚠️ Please fill in both Anchor ID and Anchor Text');
        return;
      }

      // Create heading element
      const heading = document.createElement(headingType);
      heading.id = anchorId;
      heading.textContent = anchorText;
      heading.style.marginTop = '20px';
      heading.style.marginBottom = '10px';

      // Insert at saved cursor position
      if (savedAnchorSelection) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedAnchorSelection);
        
        const range = savedAnchorSelection;
        range.insertNode(heading);
        range.setStartAfter(heading);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        editor.appendChild(heading);
      }

      saveToHistory();

      // Clear inputs
      document.getElementById('anchorIdInput').value = '';
      document.getElementById('anchorTextInput').value = '';

      // Refresh anchors list
      refreshAnchorsList();

      // Show success message
      const notification = document.createElement('div');
      notification.textContent = '✅ Anchor created: #' + anchorId;
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 12px 18px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px;';
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    // Create Link to Anchor
    document.getElementById('createLinkBtn').addEventListener('click', () => {
      const selectedAnchor = document.getElementById('existingAnchorsSelect').value;
      let linkText = document.getElementById('linkTextInput').value.trim();

      if (!selectedAnchor) {
        alert('⚠️ Please select an anchor first');
        return;
      }

      // Get anchor text if link text is empty
      if (!linkText) {
        const anchorElement = document.getElementById(selectedAnchor);
        if (anchorElement) {
          linkText = anchorElement.textContent;
        } else {
          linkText = selectedAnchor;
        }
      }

      // Create link element
      const link = document.createElement('a');
      link.href = '#' + selectedAnchor;
      link.textContent = linkText;
      link.style.color = '#2563eb';
      link.style.textDecoration = 'underline';
      link.style.cursor = 'pointer';

      // Insert at saved cursor position
      if (savedAnchorSelection) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedAnchorSelection);
        
        const range = savedAnchorSelection;
        range.insertNode(link);
        range.setStartAfter(link);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        editor.appendChild(link);
      }

      saveToHistory();

      // Clear inputs
      document.getElementById('linkTextInput').value = '';

      // Show success message
      const notification = document.createElement('div');
      notification.textContent = '✅ Link created to #' + selectedAnchor;
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #3b82f6; color: white; padding: 12px 18px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px;';
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    // Refresh anchors list from current editor content
    function refreshAnchorsList() {
      const select = document.getElementById('existingAnchorsSelect');
      select.innerHTML = '';

      // Find all elements with IDs (h2, h3, h4, etc.)
      const anchors = editor.querySelectorAll('[id]');
      
      if (anchors.length === 0) {
        select.innerHTML = '<option value="">-- No anchors found --</option>';
        return;
      }

      anchors.forEach(anchor => {
        const option = document.createElement('option');
        option.value = anchor.id;
        option.textContent = anchor.textContent || anchor.id;
        select.appendChild(option);
      });
    }

    // Handle anchor link clicks - scroll to anchor instead of following href
    // Works both in editor and on regular HTML pages
    function handleAnchorClick(e) {
      if (e.target.tagName === 'A' && e.target.href && e.target.href.includes('#')) {
        const href = e.target.getAttribute('href');
        // Only prevent default if href is local anchor (starts with #)
        if (href.startsWith('#')) {
          e.preventDefault();
          
          const anchorId = href.substring(1);
          const targetElement = document.getElementById(anchorId);
          
          console.log('Anchor click - ID:', anchorId, 'Found:', !!targetElement);
          
          if (targetElement) {
            // Scroll to the element
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Highlight the element briefly
            const originalBg = window.getComputedStyle(targetElement).backgroundColor;
            targetElement.style.backgroundColor = '#fff3cd';
            targetElement.style.transition = 'background-color 0.3s';
            
            setTimeout(() => {
              targetElement.style.backgroundColor = originalBg;
            }, 1500);
            
            // Update URL
            window.history.pushState(null, null, href);
          }
        }
      }
    }
    
    // Attach to editor
    editor.addEventListener('click', handleAnchorClick);
    
    // Also attach globally for any page
    document.addEventListener('click', handleAnchorClick);

    editor.addEventListener('mouseout', (e) => {
      if (!resizingColumn && (e.target.tagName === 'TD' || e.target.tagName === 'TH')) {
        document.body.style.cursor = 'default';
      }
    });

    // Combine Files functionality
    const combineFilesBtn = document.getElementById('combineFilesBtn');
    const combineFilesModal = document.getElementById('combineFilesModal');
    const closeCombineFilesBtn = document.getElementById('closeCombineFilesBtn');
    const closeCombineFilesBtn2 = document.getElementById('closeCombineFilesBtn2');
    const combineFilesInput = document.getElementById('combineFilesInput');
    const filesList = document.getElementById('filesList');
    const saveCombineFilesBtn = document.getElementById('saveCombineFilesBtn');
    
    // Tab switching
    const combineLocalTab = document.getElementById('combineLocalTab');
    const combineCourseTab = document.getElementById('combineCourseTab');
    const combineLocalPanel = document.getElementById('combineLocalPanel');
    const combineCoursePanel = document.getElementById('combineCoursePanel');
    const combineFileSearch = document.getElementById('combineFileSearch');
    const courseFilesList = document.getElementById('courseFilesList');

    let uploadedFiles = []; // Store local file objects
    let selectedCourseFiles = []; // Store selected course files
    let allCourseFilesIndex = []; // Index of all course files for searching
    let currentCombineMode = 'local'; // 'local' or 'course'

    // Build index of all course files
    function buildCourseFilesIndex() {
      allCourseFilesIndex = [];
      
      if (typeof courses === 'undefined') return;
      
      courses.forEach(course => {
        function searchSection(section, breadcrumb = '') {
          const currentPath = breadcrumb ? breadcrumb + ' > ' + section.name : course.title;
          
          if (section.files) {
            section.files.forEach(file => {
              if (file.type === 'html' && file.content) {
                allCourseFilesIndex.push({
                  ...file,
                  breadcrumb: currentPath
                });
              }
            });
          }
          
          if (section.msgNotes) {
            section.msgNotes.forEach(note => {
              if (note.type === 'html' && note.content) {
                allCourseFilesIndex.push({
                  ...note,
                  breadcrumb: currentPath
                });
              }
            });
          }
          
          if (section.subsections) {
            section.subsections.forEach(subsection => {
              searchSection(subsection, currentPath);
            });
          }
        }
        
        if (course.sections) {
          course.sections.forEach(section => {
            searchSection(section, course.title);
          });
        }
      });
    }

    combineFilesBtn.addEventListener('click', () => {
      combineFilesModal.classList.add('open');
      uploadedFiles = [];
      selectedCourseFiles = [];
      filesList.innerHTML = '<div style="color: #9ca3af; text-align: center; padding: 20px;">Качи файлове за да ги видиш тук</div>';
      courseFilesList.innerHTML = '<div style="color: #9ca3af; text-align: center; padding: 20px;">Избери файлове от курсове</div>';
      combineFilesInput.value = '';
      combineFileSearch.value = '';
      
      // Build course index on modal open
      buildCourseFilesIndex();
    });

    closeCombineFilesBtn.addEventListener('click', () => {
      combineFilesModal.classList.remove('open');
    });

    closeCombineFilesBtn2.addEventListener('click', () => {
      combineFilesModal.classList.remove('open');
    });

    combineFilesModal.addEventListener('click', (e) => {
      if (e.target === combineFilesModal) {
        combineFilesModal.classList.remove('open');
      }
    });

    // Tab switching
    combineLocalTab.addEventListener('click', () => {
      currentCombineMode = 'local';
      combineLocalPanel.style.display = 'block';
      combineCoursePanel.style.display = 'none';
      combineLocalTab.style.color = '#7c3aed';
      combineLocalTab.style.borderBottomColor = '#7c3aed';
      combineCourseTab.style.color = '#6b7280';
      combineCourseTab.style.borderBottomColor = 'transparent';
    });

    combineCourseTab.addEventListener('click', () => {
      currentCombineMode = 'course';
      combineLocalPanel.style.display = 'none';
      combineCoursePanel.style.display = 'block';
      combineLocalTab.style.color = '#6b7280';
      combineLocalTab.style.borderBottomColor = 'transparent';
      combineCourseTab.style.color = '#7c3aed';
      combineCourseTab.style.borderBottomColor = '#7c3aed';
      renderCourseFilesList();
    });

    combineFilesInput.addEventListener('change', (e) => {
      uploadedFiles = Array.from(e.target.files);
      renderFilesList();
    });

    combineFileSearch.addEventListener('input', () => {
      renderCourseFilesList();
    });

    function renderFilesList() {
      if (uploadedFiles.length === 0) {
        filesList.innerHTML = '<div style="color: #9ca3af; text-align: center; padding: 20px;">Качи файлове за да ги видиш тук</div>';
        return;
      }

      filesList.innerHTML = '';
      uploadedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.draggable = true;
        fileItem.dataset.index = index;
        fileItem.style.cssText = `
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 10px 12px;
          background: white;
          border: 1px solid #d1d5db;
          border-radius: 4px;
          margin-bottom: 8px;
          cursor: move;
          user-select: none;
        `;

        const dragHandle = document.createElement('span');
        dragHandle.textContent = '⋮⋮';
        dragHandle.style.cssText = 'color: #9ca3af; cursor: grab;';

        const fileName = document.createElement('span');
        fileName.textContent = file.name;
        fileName.style.cssText = 'flex: 1; font-size: 0.9em;';

        const removeBtn = document.createElement('button');
        removeBtn.textContent = '✕';
        removeBtn.style.cssText = `
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 3px;
          padding: 4px 8px;
          cursor: pointer;
          font-size: 0.85em;
        `;

        removeBtn.addEventListener('click', () => {
          uploadedFiles.splice(index, 1);
          renderFilesList();
        });

        fileItem.appendChild(dragHandle);
        fileItem.appendChild(fileName);
        fileItem.appendChild(removeBtn);
        filesList.appendChild(fileItem);

        // Drag and drop
        fileItem.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', e.target.innerHTML);
          fileItem.style.opacity = '0.5';
        });

        fileItem.addEventListener('dragend', () => {
          fileItem.style.opacity = '1';
        });

        fileItem.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          fileItem.style.borderTop = '2px solid #3b82f6';
        });

        fileItem.addEventListener('dragleave', () => {
          fileItem.style.borderTop = 'none';
        });

        fileItem.addEventListener('drop', (e) => {
          e.preventDefault();
          fileItem.style.borderTop = 'none';
          
          const draggedIndex = parseInt(e.dataTransfer.getData('text/html') ? 
            document.querySelector('[style*="opacity: 0.5"]')?.dataset.index : -1);
          
          const draggedItem = document.querySelector('[style*="opacity: 0.5"]');
          if (draggedItem) {
            const draggedIdx = parseInt(draggedItem.dataset.index);
            const dropIdx = index;
            
            if (draggedIdx !== dropIdx) {
              const temp = uploadedFiles[draggedIdx];
              uploadedFiles[draggedIdx] = uploadedFiles[dropIdx];
              uploadedFiles[dropIdx] = temp;
              renderFilesList();
            }
          }
        });
      });
    }

    function renderCourseFilesList() {
      const searchTerm = combineFileSearch.value.toLowerCase();
      
      let filteredFiles = allCourseFilesIndex;
      if (searchTerm) {
        filteredFiles = allCourseFilesIndex.filter(file => 
          file.name.toLowerCase().includes(searchTerm) ||
          file.breadcrumb.toLowerCase().includes(searchTerm)
        );
      }

      if (filteredFiles.length === 0) {
        courseFilesList.innerHTML = '<div style="color: #9ca3af; text-align: center; padding: 20px;">Нема резултати</div>';
        return;
      }

      courseFilesList.innerHTML = '';
      filteredFiles.forEach((file, idx) => {
        const isSelected = selectedCourseFiles.some(f => f.path === file.path);
        
        const fileItem = document.createElement('div');
        fileItem.style.cssText = `
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 10px 12px;
          background: white;
          border: 1px solid #d1d5db;
          border-radius: 4px;
          margin-bottom: 8px;
          cursor: pointer;
          user-select: none;
          ${isSelected ? 'background: #eef2ff; border-color: #7c3aed;' : ''}
        `;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isSelected;
        checkbox.style.cssText = 'cursor: pointer;';

        const fileInfo = document.createElement('div');
        fileInfo.style.cssText = 'flex: 1;';
        const cleanFileName = file.name
          .replace(/^\d+(\.\d+)?-/, '') // Remove number prefix like "1-", "2-msg-", etc
          .replace(/^msg-/i, '') // Remove "msg-" prefix
          .replace(/\.(html|md|txt)$/i, ''); // Remove file extension
        fileInfo.innerHTML = `
          <div style="font-size: 0.9em; font-weight: 500;">${cleanFileName}</div>
          <div style="font-size: 0.75em; color: #6b7280;">${file.breadcrumb}</div>
        `;

        fileItem.appendChild(checkbox);
        fileItem.appendChild(fileInfo);
        courseFilesList.appendChild(fileItem);

        fileItem.addEventListener('click', () => {
          if (isSelected) {
            selectedCourseFiles = selectedCourseFiles.filter(f => f.path !== file.path);
          } else {
            selectedCourseFiles.push(file);
          }
          renderCourseFilesList();
        });
      });
    }

    saveCombineFilesBtn.addEventListener('click', async () => {
      if (currentCombineMode === 'local') {
        if (uploadedFiles.length === 0) {
          alert('Моля качи поне един файл');
          return;
        }

        let combinedHtml = '';

        // Read content of each file
        for (let i = 0; i < uploadedFiles.length; i++) {
          const file = uploadedFiles[i];
          const text = await file.text();
          // Extract HTML content
          const parser = new DOMParser();
          const doc = parser.parseFromString(text, 'text/html');
          const bodyContent = doc.body.innerHTML;
          
          combinedHtml += bodyContent;
          
          // Add separator between files (but not after the last one)
          if (i < uploadedFiles.length - 1) {
            combinedHtml += '<hr style="border: none; border-top: 2px dashed #8B6F47;">';
            combinedHtml += '<p><br></p>';
            combinedHtml += '<p><br></p>';
            combinedHtml += '<hr style="border: none; border-top: 2px dashed #8B6F47;">';
          }
        }

        // Replace entire editor text with combined content
        editor.innerHTML = combinedHtml;
        saveToHistory();
      } else {
        // Handle course files combining
        if (selectedCourseFiles.length === 0) {
          alert('Моля избери поне един файл');
          return;
        }

        let combinedHtml = '';

        for (let i = 0; i < selectedCourseFiles.length; i++) {
          const file = selectedCourseFiles[i];
          
          // Extract HTML content
          if (file.type === 'html' || file.content.includes('<!DOCTYPE')) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(file.content, 'text/html');
            combinedHtml += doc.body.innerHTML;
          } else {
            // Treat as markdown
            combinedHtml += markdownToHtml(file.content);
          }
          
          // Add separator between files
          if (i < selectedCourseFiles.length - 1) {
            combinedHtml += '<hr style="border: none; border-top: 2px dashed #8B6F47;">';
            combinedHtml += '<p><br></p>';
            combinedHtml += '<p><br></p>';
            combinedHtml += '<hr style="border: none; border-top: 2px dashed #8B6F47;">';
          }
        }

        // Replace entire editor text with combined content
        editor.innerHTML = combinedHtml;
        saveToHistory();
      }
      
      // Close modal
      combineFilesModal.classList.remove('open');
      
      // Show notification
      const notification = document.createElement('div');
      notification.textContent = '✓ Файлове комбинирани успешно!';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });
  </script>

  <!-- ============================================
       CHAT SYSTEM - Firebase
       ============================================ -->

  <!-- Firebase Scripts -->
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.5.0/firebase-database.js"></script>

  <script src="js/user-identity.js?v=202404231000"></script>
    <!-- CHAT SYSTEM -->
    <script src="js/chat.js?v=202601314pk"></script>
  
<script src="js/version-check.js"></script>
</body>

</html>
