<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Markdown Editor - WYSIWYG</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Open Sans', Arial, sans-serif;
      background: #fafafa;
      display: flex;
      flex-direction: column;
    }

    /* SuperDoc-inspired Minimal Toolbar */
    .toolbar {
      position: sticky;
      top: 0;
      z-index: 100;
      background: #ffffff;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 16px;
      display: flex;
      gap: 0;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    .toolbar-group {
      display: flex;
      gap: 0;
      align-items: center;
      padding: 0;
      background: transparent;
      border-radius: 0;
      border: none;
      border-right: 1px solid #e0e0e0;
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar-group:hover {
      background: transparent;
      border-color: #e0e0e0;
    }

    .toolbar button {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4a4a4a;
      border-radius: 0;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 400;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      position: relative;
      overflow: hidden;
      height: 36px;
      min-width: 36px;
    }

    .toolbar button svg {
      width: 18px;
      height: 18px;
      stroke-width: 1.5;
      flex-shrink: 0;
    }

    .toolbar button::before {
      display: none;
    }

    .toolbar button:hover {
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .toolbar button:active {
      background: #ececec;
    }

    .toolbar button.active {
      background: #e8e8e8;
      color: #1a1a1a;
      font-weight: 500;
    }

    .toolbar-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
    }

    /* Table options dropdown menu */
    .table-options-menu {
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      min-width: 220px;
      padding: 6px 0;
    }

    .table-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 0.95em;
      color: #4a4a4a;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.15s ease;
    }

    .table-menu-item:hover {
      background-color: #f0f0f0;
      color: #1a1a1a;
    }

    .table-options-trigger {
      padding: 8px 6px !important;
      min-width: 32px;
      font-size: 16px;
    }

    .toolbar select {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4a4a4a;
      border-radius: 0;
      cursor: pointer;
      font-size: 0.95em;
      font-family: 'Open Sans', Arial, sans-serif;
      font-weight: 400;
      transition: all 0.15s ease;
      height: 36px;
    }

    .toolbar select:hover {
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .toolbar select {
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #4b5563;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      font-family: 'Open Sans', Arial, sans-serif;
      font-weight: 500;
      transition: all 0.2s;
    }

    .toolbar select:hover {
      background: rgba(146, 64, 14, 0.08);
      color: #92400e;
    }

    /* Main editor container */
    .editor-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* Editor area */
    #editor {
      flex: 1;
      padding: 12px 200px;
      font-size: 16px;
      font-family: 'Open Sans', Arial, sans-serif;
      outline: none;
      overflow-y: auto;
      background: #fff;
      color: #1f2937;
      line-height: 1.6;
      word-wrap: break-word;
      -webkit-user-select: text;
      user-select: text;
    }

    #editor:focus {
      outline: none;
    }

    /* Markdown content styling to match index.html */
    #editor h1,
    #editor h2,
    #editor h3,
    #editor h4 {
      color: #92400e;
      margin-top: 0.8em;
      margin-bottom: 0.15em;
      font-weight: 600;
    }

    #editor h1 { font-size: 1.5em; color: #000000; }
    #editor h2 { font-size: 1.3em; color: #000000; }
    #editor h3 { font-size: 1.1em; color: #000000; margin-bottom: 0.1em; }
    #editor h4 { font-size: 1.05em; color: #000000; margin-bottom: 0.1em; }

    #editor p {
      margin: 0.3em 0;
      white-space: pre-wrap;
    }

    /* CRITICAL: Fix for list formatting - prevent <p> tags from breaking lists */
    #editor ul, #editor ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
      list-style-position: outside;
    }

    #editor li {
      margin: 0.2em 0;
      padding: 0;
      display: list-item;
    }

    /* Remove <p> tags inside list items - they should not exist */
    #editor li p {
      margin: 0;
      padding: 0;
      display: inline;
    }

    /* Prevent nested list paragraph issues */
    #editor li > ul,
    #editor li > ol {
      margin: 0.3em 0 0 0;
      padding-left: 1.5em;
    }

    /* Ensure list structure is clean */
    #editor ul ul, #editor ul ol,
    #editor ol ul, #editor ol ol {
      margin-top: 0.2em;
      padding-left: 1.5em;
    }
    }
    }

    /* Reduce space between paragraph and following list */
    #editor p + ul,
    #editor p + ol {
      margin-top: -0.5em;
    }

    /* Reduce space between heading and following content */
    #editor h1 + p,
    #editor h2 + p,
    #editor h3 + p,
    #editor h4 + p,
    #editor h1 + ul,
    #editor h2 + ul,
    #editor h3 + ul,
    #editor h4 + ul,
    #editor h1 + ol,
    #editor h2 + ol,
    #editor h3 + ol,
    #editor h4 + ol {
      margin-top: 0.1em;
    }

    /* Reduce space between h3 and h4 */
    #editor h3 + h4 {
      margin-top: 0.3em;
    }

    #editor ul,
    #editor ol {
      margin: 0.3em 0;
      padding-left: 1.5em;
    }

    #editor li {
      margin: 0.15em 0;
    }

    #editor ul ul {
      list-style-type: circle;
    }

    #editor ul ul ul {
      list-style-type: square;
    }

    #editor strong {
      font-weight: 600;
    }

    #editor em {
      font-style: italic;
    }

    #editor code {
      background: rgba(146, 64, 14, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    #editor pre {
      background: rgba(255, 255, 255, 0.5);
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
      font-family: 'Courier New', monospace;
    }

    #editor pre code {
      background: none;
      padding: 0;
    }

    #editor blockquote {
      border-left: 3px solid #f59e0b;
      padding-left: 1em;
      margin: 0.5em 0;
      font-style: italic;
      color: #78350f;
    }

    #editor a {
      color: #f59e0b;
      text-decoration: underline;
      cursor: pointer;
    }

    #editor a:hover {
      color: #d97706;
    }

    .heading-color-btn {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .heading-color-btn:hover:not(.active) {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .heading-color-btn.active {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .heading-color-btn.active:hover {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .heading-color-btn:focus,
    .heading-color-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3) !important;
      transform: scale(1.05) !important;
    }

    .text-color-btn {
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .text-color-btn:hover:not(.active) {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
    }

    .text-color-btn.active {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .text-color-btn.active:hover {
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      transform: scale(1.05);
    }

    .text-color-btn:focus,
    .text-color-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3) !important;
      transform: scale(1.05) !important;
    }

    #editor table {
      border-collapse: collapse;
      margin: 0.75em 0;
      width: 100%;
      table-layout: auto;
    }

    #editor th,
    #editor td {
      border: 1px solid rgba(146, 64, 14, 0.35);
      padding: 6px 10px;
      text-align: left;
      vertical-align: top;
      height: 24px;
      line-height: 1.2;
    }

    #editor thead th {
      background: rgba(196, 127, 9, 0.08);
      font-weight: 600;
    }

    #editor tbody tr:nth-child(odd) {
      background: rgba(146, 64, 14, 0.03);
    }

    /* Raw code modal */
    .raw-code-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #92400e;
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 1.2em;
      transition: all 0.3s;
      z-index: 200;
    }

    .raw-code-btn:hover {
      background: #b8520d;
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
      transform: scale(1.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 300;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 8px;
      width: 100%;
      max-width: 1400px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 25px rgba(0,0,0,0.15);
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      margin: 0;
      color: #1f2937;
      font-size: 1.2em;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: #6b7280;
    }

    .modal-close:hover {
      color: #1f2937;
    }

    .modal-body {
      flex: 1;
      overflow: auto;
      padding: 16px 20px;
    }

    .raw-code {
      width: 100%;
      min-height: 300px;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      resize: vertical;
      line-height: 1.5;
    }

    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-footer button {
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      background: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s;
    }

    .modal-footer button:hover {
      background: #f3f4f6;
    }

    .modal-footer button.primary {
      background: #92400e;
      color: #fff;
      border-color: #92400e;
    }

    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* File list styles */
    .file-item {
      padding: 12px 16px;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .file-item:hover {
      background: #fef3c7;
    }

    .file-item[data-type="markdown"] {
      background: #fef8f0;
    }

    .file-item[data-type="html"] {
      background: #f5f3ff;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-item-name {
      font-weight: 500;
      color: #1f2937;
      font-size: 0.95em;
    }

    .file-item-path {
      font-size: 0.85em;
      color: #6b7280;
    }

    .file-item.hidden {
      display: none;
    }

    /* Course group header */
    .course-header {
      padding: 10px 16px;
      background: #f59e0b;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      position: sticky;
      top: 0;
      z-index: 1;
      border-bottom: 2px solid #d97706;
    }

    .course-header.hidden {
      display: none;
    }

    .file-item.hidden {
      display: none;
    }
    .modal-footer button.primary:hover {
      background: #b8520d;
    }

    /* Keyboard shortcuts hint */
    .shortcuts-hint {
      padding: 8px 12px;
      background: #fef3c7;
      border: 1px solid #fcd34d;
      border-radius: 4px;
      font-size: 0.85em;
      color: #78350f;
      margin-left: auto;
    }

    /* Table context menu */
    .table-context-menu {
      position: fixed;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 4px 0;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .table-context-menu.active {
      display: block;
    }

    .table-context-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      border: none;
      background: white;
      color: #1f2937;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
    }

    .table-context-menu button:hover {
      background: #f3f4f6;
    }

    .table-context-menu button:first-child {
      border-radius: 6px 6px 0 0;
    }

    .table-context-menu button:last-child {
      border-radius: 0 0 6px 6px;
    }

    /* Table resize functionality */
    #editor table {
      border-collapse: collapse;
      margin: 10px 0;
      position: relative;
    }

    #editor table td,
    #editor table th {
      border: 1px solid #ccc;
      padding: 8px;
      min-width: 50px;
      position: relative;
    }

    #editor table td:after,
    #editor table th:after {
      content: '';
      position: absolute;
      top: 0;
      right: -4px;
      width: 8px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }

    #editor table td:hover:after,
    #editor table th:hover:after {
      background: rgba(66, 165, 245, 0.3);
    }

    @media (max-width: 768px) {
      .toolbar {
        padding: 8px 12px;
      }

      .toolbar button {
        padding: 5px 8px;
        font-size: 0.85em;
      }

      .shortcuts-hint {
        display: none;
      }

      #editor {
        padding: 16px;
      }

      .raw-code-btn {
        width: 45px;
        height: 45px;
        bottom: 15px;
        right: 15px;
      }

      /* Mobile font sizes for viewer */
      #editor h1 {
        font-size: 1.5em;
      }

      #editor h2 {
        font-size: 1.3em;
      }

      #editor h3 {
        font-size: 1.1em;
      }

      #editor h4 {
        font-size: 1em;
      }

      #editor h5,
      #editor h6 {
        font-size: 0.95em;
      }

      #editor p,
      #editor li,
      #editor div {
        font-size: 0.9em;
        line-height: 1.4;
      }

      #editor code {
        font-size: 0.8em;
      }

      #editor blockquote {
        font-size: 0.9em;
      }

      #editor table {
        font-size: 0.85em;
      }
    }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolbar-group" style="position: relative; display: inline-block;">
      <button id="formatToggleBtn" title="Format"><img src="svg/radix_text.svg" alt="Format" class="toolbar-icon"></button>
      <div id="formatOptions" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; min-width: 180px;">
        <div class="format-option" data-format="p" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/radix_text.svg" alt="Normal" class="toolbar-icon">
          <span>Normal</span>
        </div>
        <div class="format-option" data-format="h1" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/bootstrap_type-h1.svg" alt="H1" class="toolbar-icon">
          <span>Heading 1</span>
        </div>
        <div class="format-option" data-format="h2" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/bootstrap_type-h2.svg" alt="H2" class="toolbar-icon">
          <span>Heading 2</span>
        </div>
        <div class="format-option" data-format="h3" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/bootstrap_type-h3.svg" alt="H3" class="toolbar-icon">
          <span>Heading 3</span>
        </div>
        <div class="format-option" data-format="h4" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; hover: background: #f3f4f6;">
          <img src="svg/bootstrap_type-h4.svg" alt="H4" class="toolbar-icon">
          <span>Heading 4</span>
        </div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="boldBtn" title="Bold (Ctrl+B)"><img src="svg/bootstrap_type-bold.svg" alt="Bold" class="toolbar-icon"></button>
      <button id="italicBtn" title="Italic (Ctrl+I)"><img src="svg/bootstrap_type-italic.svg" alt="Italic" class="toolbar-icon"></button>
      <button id="underlineBtn" title="Underline (Ctrl+U)"><img src="svg/bootstrap_type-underline.svg" alt="Underline" class="toolbar-icon"></button>
      <button id="strikeBtn" title="Strikethrough"><img src="svg/bootstrap_type-strikethrough.svg" alt="Strikethrough" class="toolbar-icon"></button>
      <button id="subscriptBtn" title="Subscript"><img src="svg/material-symbols_outlined_subscript.svg" alt="Subscript" class="toolbar-icon"></button>
      <button id="superscriptBtn" title="Superscript"><img src="svg/material-symbols_outlined_superscript.svg" alt="Superscript" class="toolbar-icon"></button>
      
      <!-- Text Color Button -->
      <div style="position: relative; display: inline-block;">
        <button id="textColorToggleBtn" title="Text Color"><img src="svg/material-symbols_outlined_format_color_text.svg" alt="Text Color" class="toolbar-icon"></button>
        <div id="textColorOptions" style="position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px; flex-direction: row; flex-wrap: wrap; max-width: 250px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; gap: 6px; display: none !important; flex: 1;">
          <button class="text-color-btn" data-color="#dd0a0ab7" title="Red" style="background-color: #dd0a0ab7; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#65a30d" title="Green" style="background-color: #65a30d; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#3b82f6" title="Blue" style="background-color: #3b82f6; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#eab308" title="Yellow" style="background-color: #eab308; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#7c2d12" title="Deep Orange" style="background-color: #7c2d12; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#7e22ce" title="Purple" style="background-color: #7e22ce; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#000000" title="Black" style="background-color: #000000; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="text-color-btn" data-color="#1f2937" title="Dark Gray" style="background-color: #1f2937; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <input type="color" id="textColorControl" value="#1f2937" style="width: 40px; height: 34px; cursor: pointer; border: none; border-radius: 4px;">
        </div>
      </div>

      <!-- Heading Color Button -->
      <div style="position: relative; display: inline-block;">
        <button id="headingColorToggleBtn" title="Heading Color"><img src="svg/material-symbols_outlined_format_color_fill.svg" alt="Heading Color" class="toolbar-icon"></button>
        <div id="headingColorOptions" style="position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 8px; flex-direction: row; flex-wrap: wrap; max-width: 250px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; gap: 6px; display: none !important; flex: 1;">
          <button class="heading-color-btn" data-color="#000000" title="Black" style="background-color: #000000; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#1f2937" title="Dark Gray" style="background-color: #1f2937; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#1e40af" title="Deep Blue" style="background-color: #1e40af; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#7c2d12" title="Deep Orange" style="background-color: #7c2d12; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#65a30d" title="Lime Green" style="background-color: #65a30d; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
          <button class="heading-color-btn" data-color="#7e22ce" title="Purple" style="background-color: #7e22ce; width: 24px; height: 24px; border-radius: 4px; border: 2px solid #e5e7eb; cursor: pointer;"></button>
        </div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="alignLeftBtn" title="Align Left"><img src="svg/material-symbols_outlined_format_align_left.svg" alt="Align Left" class="toolbar-icon"></button>
      <button id="alignCenterBtn" title="Align Center"><img src="svg/material-symbols_outlined_format_align_center.svg" alt="Align Center" class="toolbar-icon"></button>
      <button id="alignRightBtn" title="Align Right"><img src="svg/material-symbols_outlined_format_align_right.svg" alt="Align Right" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="ulBtn" title="Unordered List (Ctrl+Shift+U)"><img src="svg/vscode-codicon_list-unordered.svg" alt="Outdent" class="toolbar-icon"></button>
      <button id="olBtn" title="Ordered List (Ctrl+Shift+O)"><img src="svg/vscode-codicon_list-ordered.svg" alt="Outdent" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="outdentBtn" title="Outdent (Shift+Tab)"><img src="svg/material-symbols_outlined_format_indent_decrease.svg" alt="Outdent" class="toolbar-icon"></button>
      <button id="indentBtn" title="Indent (Tab)"><img src="svg/material-symbols_outlined_format_indent_increase.svg" alt="Indent" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group" style="position: relative;">
      <button id="tableBtn" title="Insert Table"><img src="svg/material-symbols_outlined_table.svg" alt="Table" class="toolbar-icon"></button>
      <button id="editTableBtn" title="Edit table with Tables Generator"><img src="svg/material-symbols_outlined_table_eye.svg" alt="Bold" class="toolbar-icon"></button>
      <button id="tableOptionsBtn" title="Table Options" class="table-options-trigger"><img src="svg/material-symbols_outlined_table_chart.svg" alt="Table" class="toolbar-icon"></button>
      <!-- Table Options Dropdown Menu -->
      <div id="tableOptionsMenu" class="table-options-menu" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; min-width: 220px; white-space: nowrap;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableRowBefore(); closeTableMenu();"><img src="svg/material-symbols_outlined_add.svg"  alt="Table" class="toolbar-icon"> Insert row above</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableRowAfter(); closeTableMenu();"><img src="svg/material-symbols_outlined_add.svg"  alt="Table" class="toolbar-icon"> Insert row below</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableColumnBefore(); closeTableMenu();"><img src="svg/material-symbols_outlined_add.svg"  alt="Table" class="toolbar-icon"> Insert column left</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); addTableColumnAfter(); closeTableMenu();"><img src="svg/material-symbols_outlined_add.svg"  alt="Table" class="toolbar-icon"> Insert column right</div>
      <hr style="margin: 4px 0; border: none; border-top: 1px solid #eee;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTableRow(); closeTableMenu();"><img src="svg/material-symbols_outlined_remove.svg"  alt="Table" class="toolbar-icon">Remove Table Row</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTableColumn(); closeTableMenu();"><img src="svg/material-symbols_outlined_remove.svg"  alt="Table" class="toolbar-icon"> Delete column</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); deleteTable(); closeTableMenu();"><img src="svg/material-symbols_outlined_remove.svg"  alt="Table" class="toolbar-icon"> Delete table</div>
      <hr style="margin: 4px 0; border: none; border-top: 1px solid #eee;">
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); setCellBackgroundColor(); closeTableMenu();"><img src="svg/material-symbols_outlined_colors.svg"  alt="Table" class="toolbar-icon"> Set Cell Background Color</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); mergeTableCells(); closeTableMenu();"><img src="svg/material-symbols_outlined_cell_merge.svg"  alt="Table" class="toolbar-icon"> Merge cells</div>
      <div class="table-menu-item" onclick="setCursorInTable(lastTableContext); splitTableCell(); closeTableMenu();"><img src="svg/material-symbols_outlined_code.svg"  alt="Table" class="toolbar-icon"> Split cell</div>
      </div>
    </div>

    <div class="toolbar-group">
      <button id="quoteBtn" title="Quote (Ctrl+Q)"><img src="svg/bootstrap_quote.svg" alt="Bold" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">

      <button id="linkBtn" title="Link (Ctrl+K)"><img src="svg/material-symbols_outlined_add_link.svg" alt="Bold" class="toolbar-icon"></button>
      <button id="hrBtn" title="Horizontal Line"><svg width="18" height="18" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32s-14.33-32-32-32H64c-17.67 0-32 14.33-32 32z"/></svg></button>
    </div>

    <div class="toolbar-group">
      <button id="undoBtn" title="Undo (Ctrl+Z)"><img src="svg/material-symbols_outlined_undo.svg" alt="Delete" class="toolbar-icon"></button>
      <button id="redoBtn" title="Redo (Ctrl+Y)"><img src="svg/material-symbols_outlined_redo.svg" alt="Delete" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="openLocalBtn" title="Open file from computer"><img src="svg/material-symbols_outlined_folder_open.svg" alt="Open Local" class="toolbar-icon"></button>
      <button id="openCoursesBtn" title="Open file from courses"><img src="svg/material-symbols_outlined_folder_data.svg" alt="Delete" class="toolbar-icon"></button>
    </div>

    <div class="toolbar-group">
      <button id="downloadBtn" title="Download as .html file"><img src="svg/material-symbols_outlined_download.svg" alt="Delete" class="toolbar-icon"></button>
      <button id="clearBtn" title="Clear all content"><img src="svg/vscode-codicon_clear-all.svg" alt="Delete" class="toolbar-icon"></button>
      <button id="shortcutsBtn" title="Show keyboard shortcuts"><img src="svg/material-symbols_outlined_keyboard.svg" alt="Delete" class="toolbar-icon"></button>
    </div>
  </div>

  <!-- Hidden file input for local file opening -->
  <input type="file" id="fileInput" accept=".md,.txt,.html" style="display:none;">

  <!-- Editor -->
  <div class="editor-container">
    <div id="editor" contenteditable="true" spellcheck="false">
      <p>Start typing here...</p>
    </div>
  </div>



  <!-- Shortcuts modal -->
  <div class="modal" id="shortcutsModal">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Keyboard Shortcuts</h2>
        <button class="close-btn" id="closeShortcutsBtn">×</button>
      </div>
      <div class="modal-body" style="max-height: 500px; overflow-y: auto;">
        <h3>Formatting</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+0</strong> - Normal paragraph</li>
          <li style="margin: 8px 0;"><strong>Ctrl+1</strong> - Heading 1</li>
          <li style="margin: 8px 0;"><strong>Ctrl+2</strong> - Heading 2</li>
          <li style="margin: 8px 0;"><strong>Ctrl+3</strong> - Heading 3</li>
          <li style="margin: 8px 0;"><strong>Ctrl+4</strong> - Heading 4</li>
          <li style="margin: 8px 0;"><strong>Ctrl+B</strong> - Bold</li>
          <li style="margin: 8px 0;"><strong>Ctrl+I</strong> - Italic</li>
          <li style="margin: 8px 0;"><strong>Ctrl+U</strong> - Underline</li>
          <li style="margin: 8px 0;"><strong>Ctrl+`</strong> - Code</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Alt+C</strong> - Apply last text color</li>
        </ul>
        <h3>Lists & Blocks</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+U</strong> - Unordered list</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Shift+O</strong> - Ordered list</li>
          <li style="margin: 8px 0;"><strong>Tab</strong> - Indent list item (move right)</li>
          <li style="margin: 8px 0;"><strong>Shift+Tab</strong> - Outdent list item (move left)</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Q</strong> - Quote</li>
          <li style="margin: 8px 0;"><strong>Ctrl+T</strong> - Table</li>
          <li style="margin: 8px 0;"><strong>Ctrl+K</strong> - Link</li>
        </ul>
        <h3>Editing</h3>
        <ul style="list-style: none; padding: 0;">
          <li style="margin: 8px 0;"><strong>Ctrl+Z</strong> - Undo</li>
          <li style="margin: 8px 0;"><strong>Ctrl+Y</strong> or <strong>Ctrl+Shift+Z</strong> - Redo</li>
          <li style="margin: 8px 0;"><strong>Ctrl+M</strong> - Merge adjacent lists</li>
        </ul>
      </div>
      <div class="modal-footer">
        <button class="primary" id="closeShortcutsBtn2">Close</button>
      </div>
    </div>
  </div>

  <!-- File Browser Modal -->
  <div id="fileBrowserModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
      <div class="modal-header">
        <h2>Open Markdown File from Courses</h2>
        <span class="close" id="closeFileBrowserBtn">&times;</span>
      </div>
      <div class="modal-body" style="max-height: 600px; overflow: hidden; display: flex; flex-direction: column;">
        <div style="margin-bottom: 12px;">
          <input type="text" id="fileSearchInput" placeholder="Search files..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div id="fileListContainer" style="flex: 1; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px;">
          <div id="fileList" style="padding: 0;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="closeFileBrowserBtn2">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Save File Modal -->
  <div id="saveFileModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Save Markdown File</h2>
        <span class="close" id="closeSaveModalBtn">&times;</span>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <label for="fileNumberInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Number</label>
          <input type="text" id="fileNumberInput" placeholder="e.g., 1, 2, 3..." style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
          <div style="margin-top: 4px; font-size: 0.85em; color: #6b7280;">Optional: Leave empty if not needed</div>
        </div>
        <div style="margin-bottom: 16px;">
          <label for="fileNameInput" style="display: block; margin-bottom: 6px; font-weight: 500; color: #374151;">File Name</label>
          <input type="text" id="fileNameInput" placeholder="e.g., ХОББ, Белодробен карцином" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
        </div>
        <div style="padding: 10px; background: #f3f4f6; border-radius: 4px; font-size: 0.9em; color: #4b5563;">
          <strong>Preview:</strong> <span id="fileNamePreview" style="color: #92400e; font-family: monospace;">document.html</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelSaveBtn">Cancel</button>
        <button class="primary" id="confirmSaveBtn">Download</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
  <script src="courses.generated.js"></script>

  <script>
    const editor = document.getElementById('editor');
    
    // Set up MutationObserver to prevent nested lists
    const preventNestedLists = () => {
      // Find all nested OL/UL elements and flatten them
      const nestedLists = editor.querySelectorAll('ol ol, ol ul, ul ol, ul ul');
      
      nestedLists.forEach(nestedList => {
        const parentLi = nestedList.parentElement;
        if (parentLi && parentLi.tagName === 'LI') {
          const grandparent = parentLi.parentElement;
          
          // Check if parent LI is already indented (has nested list)
          // If it does, don't add more nesting - just remove the new nested list
          
          // Move all items from nested list to after parent LI
          const items = Array.from(nestedList.children);
          items.forEach((item, idx) => {
            const newItem = item.cloneNode(true);
            
            // Remove any nested lists from items to keep them flat
            const childLists = newItem.querySelectorAll('ol, ul');
            childLists.forEach(list => list.remove());
            
            const nextSibling = parentLi.nextElementSibling;
            
            if (nextSibling) {
              grandparent.insertBefore(newItem, nextSibling);
            } else {
              grandparent.appendChild(newItem);
            }
          });
          
          // Remove the nested list
          nestedList.remove();
        }
      });
    };
    
    // Create observer to watch for nested list creation
    const observer = new MutationObserver((mutations) => {
      // Check if any OL or UL elements were added/modified
      let hasListChanges = false;
      
      for (let mutation of mutations) {
        if (mutation.type === 'childList') {
          // Check if ol or ul was added
          for (let node of mutation.addedNodes) {
            if (node.nodeType === 1 && (node.tagName === 'OL' || node.tagName === 'UL')) {
              hasListChanges = true;
              break;
            }
          }
        }
        if (hasListChanges) break;
      }
      
      // If lists were modified, flatten any nested ones
      if (hasListChanges) {
        preventNestedLists();
      }
    });
    
    // Start observing the editor for changes
    observer.observe(editor, {
      childList: true,
      subtree: true,
      attributes: false
    });
    
    const shortcutsBtn = document.getElementById('shortcutsBtn');
    const shortcutsModal = document.getElementById('shortcutsModal');
    const closeShortcutsBtn = document.getElementById('closeShortcutsBtn');
    const closeShortcutsBtn2 = document.getElementById('closeShortcutsBtn2');

    let editorContent = '';
    let rawContent = '';
    let originalHtml = '<p>Start typing here...</p>';
    
    // Global base path for images
    let globalImageBasePath = '';
    
    // Track current file info
    let currentFileInfo = {
      name: '',
      number: '',
      isFromCourses: false
    };
    
    // Flag to prevent auto-save during file loading
    let isLoadingFile = false;

    // History for undo/redo
    let history = ['<p>Start typing here...</p>'];
    let historyIndex = 0;

    // Save current state to history
    function saveToHistory() {
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(editor.innerHTML);
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    // Toolbar functions
    function insertFormat(tag) {
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return;
      
      const range = selection.getRangeAt(0);
      
      // Save cursor offset for restoration
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(editor);
      preCaretRange.setEnd(range.startContainer, range.startOffset);
      const cursorOffset = preCaretRange.toString().length;
      
      let node = range.commonAncestorContainer;
      
      // If text node, get parent
      if (node.nodeType === 3) {
        node = node.parentNode;
      }
      
      // Walk up to find the paragraph/heading element
      while (node && node !== editor) {
        if (node.nodeType === 1) {
          const tagName = node.tagName.toLowerCase();
          if (['h1', 'h2', 'h3', 'h4', 'p', 'div'].includes(tagName)) {
            // Found a block element
            const targetTag = (tagName === tag) ? 'p' : tag;
            
            // Create new element
            const newEl = document.createElement(targetTag);
            
            // Copy children
            while (node.firstChild) {
              newEl.appendChild(node.firstChild);
            }
            
            // Replace in DOM
            node.parentNode.replaceChild(newEl, node);
            
            // Restore cursor at the same position
            const newRange = document.createRange();
            const sel = window.getSelection();
            
            // Walk through new element to find cursor position
            let charCount = 0;
            let found = false;
            
            function findPosition(n) {
              if (found) return;
              if (n.nodeType === 3) {
                const nextCount = charCount + n.length;
                if (nextCount >= cursorOffset) {
                  const offset = cursorOffset - charCount;
                  newRange.setStart(n, Math.min(offset, n.length));
                  newRange.collapse(true);
                  found = true;
                  return;
                }
                charCount = nextCount;
              } else {
                for (let child of n.childNodes) {
                  findPosition(child);
                  if (found) return;
                }
              }
            }
            
            findPosition(newEl);
            
            // If position not found, put at start
            if (!found) {
              newRange.setStart(newEl, 0);
            }
            
            sel.removeAllRanges();
            sel.addRange(newRange);
            return;
          }
        }
        node = node.parentNode;
      }
    }

    function insertInline(tag) {
      const selection = window.getSelection();
      if (selection.toString().length > 0) {
        if (tag === 'code') {
          document.execCommand('formatBlock', false, 'code');
        } else {
          document.execCommand(tag, false, null);
        }
      }
      saveToHistory();
      editor.focus();
    }

    function insertList(type) {
      if (type === 'ul') {
        document.execCommand('insertUnorderedList', false, null);
      } else {
        document.execCommand('insertOrderedList', false, null);
      }
      saveToHistory();
      editor.focus();
    }

    function insertBlockquote() {
      document.execCommand('formatBlock', false, 'blockquote');
      saveToHistory();
      editor.focus();
    }

    function insertTable() {
      const rows = prompt('Number of rows:', '3');
      const cols = prompt('Number of columns:', '3');
      if (rows && cols) {
        const rowNum = parseInt(rows);
        const colNum = parseInt(cols);
        let table = '<table><thead><tr>';
        for (let i = 0; i < colNum; i++) {
          table += '<th>Header ' + (i + 1) + '</th>';
        }
        table += '</tr></thead><tbody>';
        for (let i = 0; i < rowNum - 1; i++) {
          table += '<tr>';
          for (let j = 0; j < colNum; j++) {
            table += '<td> </td>';
          }
          table += '</tr>';
        }
        table += '</tbody></table>';
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const fragment = document.createRange().createContextualFragment(table);
          range.insertNode(fragment);
        }
        saveToHistory();
      }
      editor.focus();
    }

    // Advanced table functions
    function getTableCellFromSelection() {
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return null;
      let node = selection.getRangeAt(0).startContainer;
      while (node && node !== editor) {
        if (node.tagName === 'TD' || node.tagName === 'TH') return node;
        node = node.parentNode;
      }
      return null;
    }

    // Helper to set cursor in a table cell
    function setCursorInTable(table) {
      if (!table) return;
      
      const selection = window.getSelection();
      
      // Use the last saved cell if it's still in this table
      if (lastTableCell && table.contains(lastTableCell)) {
        const range = document.createRange();
        range.setStart(lastTableCell, 0);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        // Otherwise go to first cell
        const firstCell = table.querySelector('td') || table.querySelector('th');
        if (firstCell) {
          const range = document.createRange();
          range.setStart(firstCell, 0);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    }

    function getTableFromCell(cell) {
      let node = cell;
      while (node && node !== editor) {
        if (node.tagName === 'TABLE') return node;
        node = node.parentNode;
      }
      return null;
    }

    function addTableColumnBefore() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
        newCell.textContent = ' ';
        row.insertBefore(newCell, row.cells[colIndex]);
      });
      saveToHistory();
    }

    function addTableColumnAfter() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        const newCell = document.createElement(row.querySelector('th') ? 'th' : 'td');
        newCell.textContent = ' ';
        row.insertBefore(newCell, row.cells[colIndex + 1]);
      });
      saveToHistory();
    }

    function deleteTableColumn() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const colIndex = cell.cellIndex;
      
      table.querySelectorAll('tr').forEach(row => {
        if (row.cells[colIndex]) row.deleteCell(colIndex);
      });
      saveToHistory();
    }

    function addTableRowBefore() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const row = cell.closest('tr');
      const newRow = document.createElement('tr');
      const colCount = table.querySelector('tr').cells.length;
      
      for (let i = 0; i < colCount; i++) {
        newRow.appendChild(document.createElement('td'));
      }
      row.parentNode.insertBefore(newRow, row);
      saveToHistory();
    }

    function addTableRowAfter() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      const row = cell.closest('tr');
      const newRow = document.createElement('tr');
      const colCount = table.querySelector('tr').cells.length;
      
      for (let i = 0; i < colCount; i++) {
        newRow.appendChild(document.createElement('td'));
      }
      row.parentNode.insertBefore(newRow, row.nextSibling);
      saveToHistory();
    }

    function deleteTableRow() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const row = cell.closest('tr');
      row.remove();
      saveToHistory();
    }

    function deleteTable() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const table = getTableFromCell(cell);
      table.remove();
      saveToHistory();
    }

    function mergeTableCells() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      
      const row = cell.closest('tr');
      if (!row) return alert('Позиционирай курсора в таблица');
      
      // Get current cell index and next cell
      const cellIndex = cell.cellIndex;
      const nextCell = row.cells[cellIndex + 1];
      
      if (!nextCell) return alert('Нямаш следваща клетка за мърджване');
      
      // Merge content
      cell.textContent = (cell.textContent + ' ' + nextCell.textContent).trim();
      
      // Add colspan if it doesn't exist
      const colspan = parseInt(cell.getAttribute('colspan')) || 1;
      cell.setAttribute('colspan', colspan + 1);
      
      // Remove next cell
      nextCell.remove();
      
      saveToHistory();
    }

    function setCellBackgroundColor() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      const color = prompt('Цвят (hex):', '#FAF594');
      if (color) {
        cell.style.backgroundColor = color;
        saveToHistory();
      }
    }

    function splitTableCell() {
      const cell = getTableCellFromSelection();
      if (!cell) return alert('Позиционирай курсора в таблица');
      
      const colspan = parseInt(cell.getAttribute('colspan')) || 1;
      
      if (colspan <= 1) return alert('Клетката няма colspan за разделяне');
      
      const row = cell.closest('tr');
      const cellIndex = cell.cellIndex;
      
      // Reduce colspan
      cell.setAttribute('colspan', colspan - 1);
      
      // Create new cell
      const newCell = document.createElement(cell.tagName);
      newCell.textContent = ' ';
      
      // Insert new cell after current
      const nextCell = row.cells[cellIndex + 1];
      if (nextCell) {
        row.insertBefore(newCell, nextCell);
      } else {
        row.appendChild(newCell);
      }
      
      saveToHistory();
    }

    function insertLink() {
      const url = prompt('Enter URL:', 'https://');
      const text = window.getSelection().toString() || 'Link';
      if (url) {
        document.execCommand('createLink', false, url);
      }
      saveToHistory();
      editor.focus();
    }

    function insertHR() {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const hr = document.createElement('hr');
      range.insertNode(hr);
      range.setStartAfter(hr);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
      saveToHistory();
      editor.focus();
    }

    // Toolbar button events
    // Format dropdown toggle
    const formatToggleBtn = document.getElementById('formatToggleBtn');
    if (formatToggleBtn) {
      formatToggleBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const formatOptions = document.getElementById('formatOptions');
        const isHidden = formatOptions.style.display === 'none' || formatOptions.style.display === '';
        formatOptions.style.display = isHidden ? 'block' : 'none';
      });
    }

    // Close format dropdown when clicking outside
    const formatOptions = document.getElementById('formatOptions');
    const formatToggleBtn2 = document.getElementById('formatToggleBtn');
    if (formatOptions && formatToggleBtn2) {
      document.addEventListener('click', (e) => {
        if (!formatOptions.contains(e.target) && !formatToggleBtn2.contains(e.target)) {
          formatOptions.style.display = 'none';
        }
      });
    }

    // Format option selection
    document.querySelectorAll('.format-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Focus editor first
        editor.focus();
        
        const format = option.dataset.format;
        insertFormat(format);
        saveToHistory();
        
        // Close dropdown
        document.getElementById('formatOptions').style.display = 'none';
      });
    });

    document.getElementById('boldBtn').addEventListener('click', () => {
      document.execCommand('bold', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('italicBtn').addEventListener('click', () => {
      document.execCommand('italic', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('underlineBtn').addEventListener('click', () => {
      document.execCommand('underline', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('strikeBtn').addEventListener('click', () => {
      document.execCommand('strikethrough', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('subscriptBtn').addEventListener('click', () => {
      document.execCommand('subscript', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('superscriptBtn').addEventListener('click', () => {
      document.execCommand('superscript', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignLeftBtn').addEventListener('click', () => {
      document.execCommand('justifyLeft', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignCenterBtn').addEventListener('click', () => {
      document.execCommand('justifyCenter', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('alignRightBtn').addEventListener('click', () => {
      document.execCommand('justifyRight', false, null);
      saveToHistory();
      editor.focus();
    });

    document.getElementById('indentBtn').addEventListener('click', () => {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      let node = range.startContainer;
      
      // Check if we're in a list item
      while (node && node !== editor) {
        if (node.nodeType === 1 && node.tagName === 'LI') {
          document.execCommand('indent', false, null);
          saveToHistory();
          editor.focus();
          return;
        }
        node = node.parentNode;
      }
      
      // If not in list, show notification
      const notification = document.createElement('div');
      notification.textContent = '⚠️ Indent works only in lists';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #f59e0b; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    document.getElementById('outdentBtn').addEventListener('click', () => {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      let node = range.startContainer;
      
      // Check if we're in a list item
      while (node && node !== editor) {
        if (node.nodeType === 1 && node.tagName === 'LI') {
          document.execCommand('outdent', false, null);
          saveToHistory();
          editor.focus();
          return;
        }
        node = node.parentNode;
      }
      
      // If not in list, show notification
      const notification = document.createElement('div');
      notification.textContent = '⚠️ Outdent works only in lists';
      notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #f59e0b; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    });

    document.getElementById('ulBtn').addEventListener('click', () => {
      insertList('ul');
    });

    document.getElementById('olBtn').addEventListener('click', () => {
      insertList('ol');
    });

    document.getElementById('quoteBtn').addEventListener('click', () => {
      insertBlockquote();
    });

    document.getElementById('editTableBtn').addEventListener('click', () => {
      editor.focus();
      
      const selection = window.getSelection();
      let table = null;
      
      // Try to find the table where cursor is
      if (selection.anchorNode) {
        const node = selection.anchorNode.nodeType === 3 ? selection.anchorNode.parentElement : selection.anchorNode;
        table = node.closest('table');
      }
      
      if (!table && selection.focusNode) {
        const node = selection.focusNode.nodeType === 3 ? selection.focusNode.parentElement : selection.focusNode;
        table = node.closest('table');
      }
      
      if (!table && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const node = range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentElement : range.commonAncestorContainer;
        table = node.closest('table');
      }
      
      if (!table) {
        const tables = editor.querySelectorAll('table');
        if (tables.length > 0) {
          table = tables[0];
        }
      }
      
      if (!table) {
        alert('No table found. Create a table first or click inside a table');
        return;
      }

      // Copy table HTML to clipboard
      const tableHtml = table.outerHTML;
      navigator.clipboard.writeText(tableHtml).then(() => {
        // Open Tables Generator
        alert('Table copied to clipboard!\n\nNow:\n1. Go to tablesgenerator.com\n2. Click "Import" or "Paste" button\n3. Paste your table (Ctrl+V)\n4. Edit it\n5. Copy the HTML\n6. Come back and paste here');
        window.open('https://www.tablesgenerator.com/html_tables', '_blank');
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy table. Please try again');
      });
    });

    // Table buttons
    // Table menu dropdown
    let lastTableContext = null; // Store last table context
    let lastTableCell = null; // Store last selected cell
    
    // Track when cursor enters/leaves table
    editor.addEventListener('click', () => {
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        while (node && node !== editor) {
          if (node.tagName === 'TABLE') {
            lastTableContext = node;
            // Also save the current cell
            let cellNode = range.startContainer;
            while (cellNode && cellNode !== node) {
              if (cellNode.tagName === 'TD' || cellNode.tagName === 'TH') {
                lastTableCell = cellNode;
                return;
              }
              cellNode = cellNode.parentNode;
            }
            return;
          }
          node = node.parentNode;
        }
      }
      lastTableContext = null;
      lastTableCell = null;
    });
    
    document.getElementById('tableBtn').addEventListener('click', () => {
      insertTable();
    });

    document.getElementById('tableOptionsBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Use stored table context
      if (!lastTableContext) {
        const notification = document.createElement('div');
        notification.textContent = '⚠️ Position cursor in a table first';
        notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #f59e0b; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.transition = 'opacity 0.3s';
          notification.style.opacity = '0';
          setTimeout(() => notification.remove(), 300);
        }, 2000);
        return;
      }
      
      const menu = document.getElementById('tableOptionsMenu');
      if (menu) {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      }
    });

    document.getElementById('linkBtn').addEventListener('click', () => {
      insertLink();
    });

    document.getElementById('hrBtn').addEventListener('click', () => {
      insertHR();
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        editor.innerHTML = history[historyIndex];
      }
    });

    // Close table options menu
    function closeTableMenu() {
      const menu = document.getElementById('tableOptionsMenu');
      if (menu) {
        menu.style.display = 'none';
      }
      editor.focus();
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      const menu = document.getElementById('tableOptionsMenu');
      const btn = document.getElementById('tableOptionsBtn');
      if (menu && !menu.contains(e.target) && !btn.contains(e.target)) {
        menu.style.display = 'none';
      }
    });

    document.getElementById('redoBtn').addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        editor.innerHTML = history[historyIndex];
      }
    });

    // Text Color Control - Toggle button
    document.getElementById('textColorToggleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const textColorOptions = document.getElementById('textColorOptions');
      const isHidden = textColorOptions.style.display === 'none' || !textColorOptions.style.display;
      textColorOptions.style.display = isHidden ? 'flex' : 'none';
    });

    // Close text color dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const textColorOptions = document.getElementById('textColorOptions');
      const textColorToggleBtn = document.getElementById('textColorToggleBtn');
      if (!textColorOptions.contains(e.target) && !textColorToggleBtn.contains(e.target)) {
        textColorOptions.style.display = 'none';
      }
    });

    // Text Color Control - Preset buttons
    document.querySelectorAll('.text-color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const color = btn.dataset.color;
        applyFormatting('color', color);
        
        // Update color picker value
        document.getElementById('textColorControl').value = color;
        
        // Update active button
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Close dropdown
        document.getElementById('textColorOptions').style.display = 'none';
        
        // Remove focus to hide hover state
        btn.blur();
      });
    });

    // Text Color Control - Custom color picker
    document.getElementById('textColorControl').addEventListener('input', (e) => {
      const color = e.target.value;
      applyFormatting('color', color);
      
      // Remove active class from preset buttons when using custom color
      document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
    });

    // Heading Color Toggle Button
    document.getElementById('headingColorToggleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const headingColorOptions = document.getElementById('headingColorOptions');
      const isHidden = headingColorOptions.style.display === 'none' || headingColorOptions.style.display === '';
      headingColorOptions.style.display = isHidden ? 'flex' : 'none';
    });

    // Close heading color dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const headingColorOptions = document.getElementById('headingColorOptions');
      const headingColorToggleBtn = document.getElementById('headingColorToggleBtn');
      if (headingColorOptions && headingColorToggleBtn && !headingColorOptions.contains(e.target) && !headingColorToggleBtn.contains(e.target)) {
        headingColorOptions.style.display = 'none';
      }
    });

    // Heading Color Control
    document.querySelectorAll('.heading-color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const color = btn.dataset.color;
        
        // Update CSS for all headings with higher specificity
        const style = document.createElement('style');
        style.id = 'heading-color-style';
        const existingStyle = document.getElementById('heading-color-style');
        if (existingStyle) existingStyle.remove();
        
        style.textContent = `
          #editor h1, 
          #editor h2, 
          #editor h3, 
          #editor h4 { 
            color: ${color} !important; 
          }
        `;
        document.head.appendChild(style);
        
        // Also apply directly to existing headers
        const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
        headers.forEach(h => {
          h.style.color = color;
        });
        
        // Update active button
        document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Save to localStorage
        localStorage.setItem('mdEditorHeadingColor', color);
        
        // Close dropdown
        document.getElementById('headingColorOptions').style.display = 'none';
        
        // Remove focus to hide hover state
        btn.blur();
      });
    });

    // Apply formatting to selected text
    function applyFormatting(property, value) {
      const selection = window.getSelection();
      
      // If no selection or selection is in editor
      if (!selection.toString() || !editor.contains(selection.anchorNode)) {
        alert('Моля, избери текст първо');
        return;
      }

      // Use document.execCommand for color - it preserves structure better
      if (property === 'color') {
        // Convert hex to RGB for execCommand
        const hex = value;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const rgb = `rgb(${r}, ${g}, ${b})`;
        document.execCommand('foreColor', false, rgb);
      } else if (property === 'fontSize') {
        document.execCommand('fontSize', false, value);
      }
      
      // Save to localStorage
      if (property === 'color') {
        localStorage.setItem('mdEditorTextColor', value);
      }
      
      // Mark as modified
      saveToHistory();
    }

    // Load saved default preferences on page load
    window.addEventListener('load', () => {
      const savedTextColor = localStorage.getItem('mdEditorTextColor');
      const savedHeadingColor = localStorage.getItem('mdEditorHeadingColor');

      if (savedTextColor) {
        document.getElementById('textColorControl').value = savedTextColor;
        // Clear all active classes first
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        // Activate corresponding button if it exists
        const btn = document.querySelector(`.text-color-btn[data-color="${savedTextColor}"]`);
        if (btn) {
          btn.classList.add('active');
        }
      } else {
        // If no saved color, activate the default (Dark Gray)
        document.querySelectorAll('.text-color-btn').forEach(b => b.classList.remove('active'));
        const defaultBtn = document.querySelector('.text-color-btn[data-color="#1f2937"]');
        if (defaultBtn) defaultBtn.classList.add('active');
      }

      if (savedHeadingColor) {
        // Apply saved heading color
        const btn = document.querySelector(`.heading-color-btn[data-color="${savedHeadingColor}"]`);
        if (btn) {
          const style = document.createElement('style');
          style.id = 'heading-color-style';
          style.textContent = `
            #editor h1, 
            #editor h2, 
            #editor h3, 
            #editor h4 { 
              color: ${savedHeadingColor} !important; 
            }
          `;
          document.head.appendChild(style);
          
          // Also apply directly to existing headers
          const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
          headers.forEach(h => {
            h.style.color = savedHeadingColor;
          });
          
          // Clear all active classes first
          document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
      } else {
        // If no saved color, activate the default (Black)
        document.querySelectorAll('.heading-color-btn').forEach(b => b.classList.remove('active'));
        const defaultBtn = document.querySelector('.heading-color-btn[data-color="#000000"]');
        if (defaultBtn) {
          defaultBtn.classList.add('active');
          // Apply default heading color
          const style = document.createElement('style');
          style.id = 'heading-color-style';
          style.textContent = `
            #editor h1, 
            #editor h2, 
            #editor h3, 
            #editor h4 { 
              color: #000000 !important; 
            }
          `;
          document.head.appendChild(style);
          
          // Also apply directly to existing headers
          const headers = document.querySelectorAll('#editor h1, #editor h2, #editor h3, #editor h4');
          headers.forEach(h => {
            h.style.color = '#000000';
          });
        }
      }
    });

    document.getElementById('downloadBtn').addEventListener('click', () => {
      // Populate modal with current file info
      document.getElementById('fileNumberInput').value = currentFileInfo.number || '';
      document.getElementById('fileNameInput').value = currentFileInfo.name || '';
      updateFileNamePreview();
      
      // Show modal
      document.getElementById('saveFileModal').style.display = 'flex';
      document.getElementById('fileNameInput').focus();
    });

    // Open local .md file from computer
    document.getElementById('openLocalBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        const markdownContent = event.target.result;
        
        // Set global base path for images (use file's directory)
        if (file.name) {
          // For local files, we can't reliably set base path, but we try
          globalImageBasePath = '';
        }
        
        // Convert markdown to HTML
        isLoadingFile = true;
        const html = markdownToHtml(markdownContent);
        editor.innerHTML = html;
        saveToHistory();
        setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
        
        // Extract file info for saving later
        const fileName = file.name.replace(/\.(md|txt)$/i, '');
        const numberMatch = fileName.match(/^(\d+(\.\d+)?)-/);
        const nameWithoutNumber = fileName.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '');
        
        currentFileInfo = {
          name: nameWithoutNumber,
          number: numberMatch ? numberMatch[1] : '',
          isFromCourses: false
        };
        
        // Update page title
        document.title = fileName + ' — Markdown Editor';
      };
      reader.readAsText(file);
      
      // Reset file input
      e.target.value = '';
    });

    // Open .md file from courses.generated.js
    document.getElementById('openCoursesBtn').addEventListener('click', () => {
      // Check if courses data is available
      if (typeof courses === 'undefined') {
        alert('Courses data not found. Please make sure you are running this from index.html or include courses.generated.js');
        return;
      }
      
      // Group files by course
      const filesByCourse = {};
      courses.forEach(course => {
        const courseName = course.title || course.name || 'Unknown';
        filesByCourse[courseName] = [];
        
        course.sections.forEach(section => {
          if (section.msgNotes) {
            section.msgNotes.forEach(note => {
              if (note.path && (/\.md$/i.test(note.path) && note.type === 'markdown') || (/\.html$/i.test(note.path) && note.type === 'html')) {
                filesByCourse[courseName].push({
                  name: note.name,
                  path: note.path,
                  content: note.content,
                  type: note.type,
                  courseName: courseName,
                  sectionName: section.name
                });
              }
            });
          }
        });
      });
      
      // Populate file list with course headers
      const fileList = document.getElementById('fileList');
      fileList.innerHTML = '';
      
      Object.keys(filesByCourse).forEach(courseName => {
        const files = filesByCourse[courseName];
        if (files.length === 0) return;
        
        // Add course header
        const courseHeader = document.createElement('div');
        courseHeader.className = 'course-header';
        courseHeader.textContent = courseName;
        courseHeader.setAttribute('data-course', courseName);
        fileList.appendChild(courseHeader);
        
        // Add files for this course
        files.forEach((file, idx) => {
          const fileItem = document.createElement('div');
          fileItem.className = 'file-item';
          fileItem.setAttribute('data-course', courseName);
          fileItem.setAttribute('data-type', file.type);
          fileItem.setAttribute('data-search-text', (file.courseName + ' ' + file.sectionName + ' ' + file.name).toLowerCase());
          
          // Clean up file name: remove msg-, number prefix (including decimals like 2.4), and extension
          const cleanName = file.name
            .replace(/^\d+(\.\d+)?-/, '')   // Remove number prefix (e.g., "1-", "2.4-")
            .replace(/^msg-/i, '')          // Remove "msg-" prefix
            .replace(/\.(md|txt|html)$/i, '');   // Remove .md, .txt, or .html extension
          
          fileItem.innerHTML = `
            <div class="file-item-name">${cleanName}</div>
            <div class="file-item-path">${file.sectionName}</div>
          `;
          
          fileItem.addEventListener('click', () => {
            loadFileFromCourses(file);
            document.getElementById('fileBrowserModal').style.display = 'none';
          });
          
          fileList.appendChild(fileItem);
        });
      });
      
      // Show modal
      document.getElementById('fileBrowserModal').style.display = 'flex';
      document.getElementById('fileSearchInput').value = '';
      document.getElementById('fileSearchInput').focus();
    });

    // File search functionality
    document.getElementById('fileSearchInput').addEventListener('input', (e) => {
      const searchText = e.target.value.toLowerCase();
      const fileItems = document.querySelectorAll('.file-item');
      const courseHeaders = document.querySelectorAll('.course-header');
      
      // Track which courses have visible files
      const visibleCourses = new Set();
      
      fileItems.forEach(item => {
        const itemText = item.getAttribute('data-search-text');
        if (itemText.includes(searchText)) {
          item.classList.remove('hidden');
          visibleCourses.add(item.getAttribute('data-course'));
        } else {
          item.classList.add('hidden');
        }
      });
      
      // Show/hide course headers based on whether they have visible files
      courseHeaders.forEach(header => {
        const courseName = header.getAttribute('data-course');
        if (visibleCourses.has(courseName)) {
          header.classList.remove('hidden');
        } else {
          header.classList.add('hidden');
        }
      });
    });

    // Function to load file from courses
    function loadFileFromCourses(file) {
      // Set global base path for images
      const basePath = file.path.substring(0, file.path.lastIndexOf('/') + 1);
      if (window.location.protocol === 'file:') {
        const currentPath = window.location.pathname;
        const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
        globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
      } else {
        const currentOrigin = window.location.origin;
        globalImageBasePath = currentOrigin + '/' + basePath;
      }
      
      // Convert markdown to HTML or use HTML directly
      isLoadingFile = true;
      let html;
      
      // If it's an HTML file, use content directly (extract body content)
      if (file.type === 'html') {
        const parser = new DOMParser();
        const doc = parser.parseFromString(file.content, 'text/html');
        // Get body content and trim whitespace
        html = doc.body.innerHTML.trim();
      } else {
        // Otherwise parse as Markdown
        html = markdownToHtml(file.content);
      }
      
      editor.innerHTML = html;
      saveToHistory();
      setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
      
      // Extract file info for saving later
      const numberMatch = file.name.match(/^(\d+(\.\d+)?)-/);
      const cleanName = file.name.replace(/^\d+(\.\d+)?-/, '').replace(/^msg-/i, '').replace(/\.(md|txt|html)$/i, '');
      
      currentFileInfo = {
        name: cleanName,
        number: numberMatch ? numberMatch[1] : '',
        isFromCourses: true
      };
      
      // Update page title
      document.title = cleanName + ' — Markdown Editor';
    }

    // Close file browser modal
    document.getElementById('closeFileBrowserBtn').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    document.getElementById('closeFileBrowserBtn2').addEventListener('click', () => {
      document.getElementById('fileBrowserModal').style.display = 'none';
    });

    // Close modal when clicking outside
    document.getElementById('fileBrowserModal').addEventListener('click', (e) => {
      if (e.target.id === 'fileBrowserModal') {
        document.getElementById('fileBrowserModal').style.display = 'none';
      }
    });

    // Save file modal functionality
    function updateFileNamePreview() {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      const preview = document.getElementById('fileNamePreview');
      
      let fileName = '';
      if (number) {
        fileName += number + '-msg-';
      }
      fileName += (name || 'document') + '.html';
      
      preview.textContent = fileName;
    }

    document.getElementById('fileNumberInput').addEventListener('input', updateFileNamePreview);
    document.getElementById('fileNameInput').addEventListener('input', updateFileNamePreview);

    document.getElementById('confirmSaveBtn').addEventListener('click', () => {
      const number = document.getElementById('fileNumberInput').value.trim();
      const name = document.getElementById('fileNameInput').value.trim();
      
      if (!name) {
        alert('Please enter a file name');
        return;
      }
      
      // Clean the name: remove .html, .md, .txt extensions
      const cleanName = name.replace(/\.(html|md|txt)$/i, '');
      
      // Convert absolute image paths to relative paths
      let editorContent = editor.innerHTML;
      
      // SAFE: Remove only EMPTY <p> tags (those with just whitespace or empty formatting)
      // This removes the empty paragraphs browser creates between list items
      let prevContent;
      let iterations = 0;
      do {
        prevContent = editorContent;
        iterations++;
        // Remove <p></p> tags with only whitespace or <br> inside
        editorContent = editorContent.replace(/<p>\s*<\/p>/g, '');
        editorContent = editorContent.replace(/<p><br\s*\/?><\/p>/g, '');
        editorContent = editorContent.replace(/<p>\s*<br\s*\/?>\s*<\/p>/g, '');
        
        // Remove <p> tags containing ONLY empty formatting tags + br (inside list items)
        // Matches: <p><b></b><br></p>, <p><strong></strong><br></p>, <p><b><br></b></p>, etc
        editorContent = editorContent.replace(/<p>\s*<(?:b|strong|em|i|u|span)[^>]*>\s*<\/(?:b|strong|em|i|u|span)>\s*<br\s*\/?>\s*<\/p>/g, '');
        editorContent = editorContent.replace(/<p>\s*<(?:b|strong|em|i|u|span)[^>]*>\s*<br\s*\/?>\s*<\/(?:b|strong|em|i|u|span)>\s*<\/p>/g, '');
        
      } while (editorContent !== prevContent && iterations < 5);
      
      // CRITICAL: Fix image src to use relative paths for export
      // Extract path starting from "assets/" and use it as the relative path
      // This handles both file:// and Windows absolute paths
      editorContent = editorContent.replace(/src="[^"]*?(assets\/[^"]*)"(?=[^>]*>)/g, 'src="$1"');
      
      // Ensure data-original-src matches src for consistency
      editorContent = editorContent.replace(/(<img[^>]*src="([^"]*?)"[^>]*)data-original-src="[^"]*?"(?=[^>]*>)/g, '$1data-original-src="$2"');
      // Also handle forward slashes in Windows paths
      editorContent = editorContent.replace(/file:\/\/\/.*?\/Filen\/Personal\/Website\//g, '');
      
      // Get heading color from localStorage
      const savedHeadingColor = localStorage.getItem('mdEditorHeadingColor') || '#000000';
      
      // Create standalone HTML file with embedded content
      const htmlDoc = `<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${cleanName}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  <style>
    body { 
      font-family: "Open Sans", Arial, sans-serif; 
      max-width: 1550px; 
      margin: 0.5rem auto; 
      padding: 0 1rem; 
      line-height: 1.8; 
      color: #1f2937; 
    }
    h1, h2, h3, h4 { 
      font-weight: 600; 
      margin-top: 0.8em;
      margin-bottom: 0.3em;
      color: ${savedHeadingColor};
    }
    h1 { font-size: 1.5em; }
    h2 { font-size: 1.3em; }
    h3 { font-size: 1.1em; }
    h4 { font-size: 1.05em; }
    h3 + h4 { margin-top: 0.3em; }
    p { 
      margin: 0.7em 0; 
      white-space: pre-wrap;
    }
    p + ul, p + ol { margin-top: -0.5em; }
    h1 + p, h2 + p, h3 + p, h4 + p,
    h1 + ul, h2 + ul, h3 + ul, h4 + ul,
    h1 + ol, h2 + ol, h3 + ol, h4 + ol { 
      margin-top: 0.1em; 
    }
    ul, ol { 
      margin: 0.3em 0; 
      padding-left: 1.5em; 
    }
    li { margin: 0.15em 0; }
    ul ul { list-style-type: circle; }
    ul ul ul { list-style-type: square; }
    strong { font-weight: 600; }
    em { font-style: italic; }
    code { 
      background: rgba(146, 64, 14, 0.1); 
      padding: 2px 6px; 
      border-radius: 3px; 
      font-family: "Courier New", monospace; 
      font-size: 0.9em; 
    }
    pre {
      background: rgba(255, 255, 255, 0.5);
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
      font-family: "Courier New", monospace;
    }
    pre code {
      background: none;
      padding: 0;
    }
    blockquote {
      border-left: 3px solid #f59e0b;
      padding-left: 1em;
      margin: 0.5em 0;
      font-style: italic;
      color: #78350f;
    }
    table { 
      border-collapse: collapse; 
      margin: 0.75em 0; 
      width: 100%; 
      table-layout: auto;
    }
    th, td { 
      border: 1px solid rgba(146, 64, 14, 0.35); 
      padding: 6px 10px; 
      text-align: left; 
      vertical-align: top;
      height: 24px;
      line-height: 1.2;
    }
    thead th { 
      background: rgba(196, 127, 9, 0.08); 
      font-weight: 600; 
    }
    tbody tr:nth-child(odd) { 
      background: rgba(146, 64, 14, 0.03); 
    }
    img { 
      max-width: 100%; 
      height: auto; 
    }
    a { 
      color: #f59e0b; 
      text-decoration: underline; 
    }
    a:hover {
      color: #d97706;
    }
    @media (max-width: 768px) {
      body {
        max-width: 100%;
        margin: 0.5rem 0;
        padding: 0 0.5rem;
        font-size: 16px;
      }
      h1 { font-size: 1.3em; }
      h2 { font-size: 1.1em; }
      h3 { font-size: 1em; }
      p { margin: 0.5em 0; }
      ul, ol { padding-left: 1.2em; }
      li { margin: 0.1em 0; }
      table { font-size: 0.9em; }
      th, td { padding: 4px 6px; }
    }
  </style>
</head>
<body>
${editorContent}
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"><\/script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"><\/script>
<script>
renderMathInElement(document.body, {
  delimiters: [
    {left: '$$', right: '$$', display: true},
    {left: '$', right: '$', display: false}
  ]
});
<\/script>
</body>
</html>`;
      
      const blob = new Blob([htmlDoc], { type: 'text/html;charset=utf-8' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      
      let fileName = '';
      if (number) {
        fileName = number + '-msg-' + name + '.html';
      } else {
        fileName = name + '.html';
      }
      
      link.download = fileName;
      link.click();
      URL.revokeObjectURL(link.href);
      
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('cancelSaveBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('closeSaveModalBtn').addEventListener('click', () => {
      document.getElementById('saveFileModal').style.display = 'none';
    });

    document.getElementById('saveFileModal').addEventListener('click', (e) => {
      if (e.target.id === 'saveFileModal') {
        document.getElementById('saveFileModal').style.display = 'none';
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all content?')) {
        editor.innerHTML = '<p></p>';
        saveToHistory();
        editor.focus();
      }
    });

    // Shortcuts modal
    shortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.add('open');
    });

    closeShortcutsBtn.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    closeShortcutsBtn2.addEventListener('click', () => {
      shortcutsModal.classList.remove('open');
    });

    shortcutsModal.addEventListener('click', (e) => {
      if (e.target === shortcutsModal) {
        shortcutsModal.classList.remove('open');
      }
    });

    // Raw code modal - TOGGLE MODE
    // Function to apply syntax highlighting to markdown
    function highlightMarkdown(text) {
      // Escape HTML to prevent code execution
      let highlighted = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Headers (h1-h4)
      highlighted = highlighted.replace(/^(#{1,4})\s+(.*)$/gm, '<span style="color: #92400e; font-weight: 600;">$1</span> <span style="color: #78350f; font-weight: 600;">$2</span>');
      
      // Bold **text**
      highlighted = highlighted.replace(/\*\*([^*]+)\*\*/g, '<span style="color: #1f2937; font-weight: 600;">**</span><span style="color: #374151; font-weight: 600;">$1</span><span style="color: #1f2937; font-weight: 600;">**</span>');
      
      // Italic *text*
      highlighted = highlighted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span style="color: #6b7280;">*</span><span style="color: #6b7280; font-style: italic;">$1</span><span style="color: #6b7280;">*</span>');
      
      // Underline __text__
      highlighted = highlighted.replace(/__([^_]+)__/g, '<span style="color: #9ca3af;">__</span><span style="color: #9ca3af; text-decoration: underline;">$1</span><span style="color: #9ca3af;">__</span>');
      
      // Inline code `code`
      highlighted = highlighted.replace(/`([^`]+)`/g, '<span style="color: #059669;">`</span><span style="color: #059669; background: rgba(5, 150, 105, 0.1);">$1</span><span style="color: #059669;">`</span>');
      
      // Links [text](url)
      highlighted = highlighted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<span style="color: #2563eb;">[</span><span style="color: #3b82f6;">$1</span><span style="color: #2563eb;">](</span><span style="color: #60a5fa; text-decoration: underline;">$2</span><span style="color: #2563eb;">)</span>');
      
      // Images ![alt](url)
      highlighted = highlighted.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<span style="color: #7c3aed;">![</span><span style="color: #8b5cf6;">$1</span><span style="color: #7c3aed;">](</span><span style="color: #a78bfa; text-decoration: underline;">$2</span><span style="color: #7c3aed;">)</span>');
      
      // Unordered list - keep original - or * marker
      highlighted = highlighted.replace(/^(\s*)([-*])\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2</span> <span style="color: #374151;">$3</span>');
      
      // Ordered list
      highlighted = highlighted.replace(/^(\s*)(\d+)\.\s+(.*)$/gm, '$1<span style="color: #f59e0b; font-weight: 600;">$2.</span> <span style="color: #374151;">$3</span>');
      
      // Blockquote
      highlighted = highlighted.replace(/^(&gt;)\s+(.*)$/gm, '<span style="color: #d97706; font-weight: 600;">$1</span> <span style="color: #92400e; font-style: italic;">$2</span>');
      
      // Horizontal rule
      highlighted = highlighted.replace(/^---+$/gm, '<span style="color: #6b7280;">---</span>');
      
      return highlighted;
    }

    // Flatten nested lists - remove unnecessary nesting
    function flattenNestedLists() {
      // Recursively flatten all nested lists
      let changed = true;
      while (changed) {
        changed = false;
        
        // Find all OL and UL elements
        const allLists = Array.from(editor.querySelectorAll('ol, ul'));
        
        for (let list of allLists) {
          // Check if this list is nested inside an LI
          const parentLi = list.parentElement;
          if (parentLi && parentLi.tagName === 'LI') {
            // This is a nested list
            const grandparentList = parentLi.parentElement;
            
            // Only flatten if both parent and child are same type or if parent is OL
            if (grandparentList && (grandparentList.tagName === 'OL' || grandparentList.tagName === 'UL')) {
              // Move all items from nested list to after the parent LI
              const items = Array.from(list.querySelectorAll(':scope > li'));
              
              for (let item of items) {
                // If this is an OL > LI > OL, move items to parent OL
                if (grandparentList.tagName === 'OL' && list.tagName === 'OL') {
                  const nextSibling = parentLi.nextElementSibling;
                  if (nextSibling) {
                    grandparentList.insertBefore(item.cloneNode(true), nextSibling);
                  } else {
                    grandparentList.appendChild(item.cloneNode(true));
                  }
                }
              }
              
              // Remove the nested list if we moved items
              if (items.length > 0 && list.tagName === 'OL' && grandparentList.tagName === 'OL') {
                list.remove();
                changed = true;
              }
            }
          }
        }
      }
      
      // Second pass: remove any remaining nested OL/UL that are direct children of LI
      const nestedLists = editor.querySelectorAll('ol ol, ol ul, ul ol, ul ul');
      nestedLists.forEach(nestedList => {
        const parent = nestedList.parentElement;
        if (parent && parent.tagName === 'LI') {
          // Move all items up
          const items = Array.from(nestedList.children);
          const grandparent = parent.parentElement;
          
          items.forEach((item, index) => {
            const clone = item.cloneNode(true);
            const nextSibling = parent.nextElementSibling;
            if (nextSibling) {
              grandparent.insertBefore(clone, nextSibling);
            } else {
              grandparent.appendChild(clone);
            }
          });
          
          nestedList.remove();
        }
      });
    }

    // Merge adjacent lists of the same type
    function mergeAdjacentLists() {
      const selection = window.getSelection();
      let currentNode = selection.focusNode;
      
      // Find the list item we're in
      while (currentNode && currentNode !== editor) {
        if (currentNode.nodeType === 1 && currentNode.tagName === 'LI') {
          const listItem = currentNode;
          const list = listItem.parentNode;
          
          if (list && (list.tagName === 'OL' || list.tagName === 'UL')) {
            // Check if there's an identical list immediately after this one
            let nextElement = list.nextElementSibling;
            while (nextElement && nextElement.nodeType === 8) {
              // Skip comment nodes
              nextElement = nextElement.nextElementSibling;
            }
            
            if (nextElement && nextElement.tagName === list.tagName) {
              // Move all items from next list to current list
              while (nextElement.firstChild) {
                list.appendChild(nextElement.firstChild);
              }
              // Remove the now-empty list
              nextElement.remove();
              
              // Show notification
              const notification = document.createElement('div');
              notification.textContent = '✓ Списъци обединени';
              notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
              document.body.appendChild(notification);
              
              setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
              }, 2000);
            } else {
              alert('Няма съседен списък за обединяване');
            }
          }
          return;
        }
        currentNode = currentNode.parentNode;
      }
      
      alert('Моля, позиционирай курсора в списък');
    }

    // Double-click to edit list item numbers
    editor.addEventListener('dblclick', (e) => {
      // Find if we're in an OL li
      let li = e.target.closest('li');
      
      if (li && li.parentNode && li.parentNode.tagName === 'OL') {
        e.preventDefault();
        
        // Find the current position in the list
        const ol = li.parentNode;
        const items = Array.from(ol.children);
        const currentIndex = items.indexOf(li);
        const currentNumber = currentIndex + 1;
        
        // Prompt user for new number
        const newNumber = prompt(`Промени номера на list item (текущо: ${currentNumber}):`, currentNumber.toString());
        
        if (newNumber !== null && newNumber.trim() !== '') {
          const num = parseInt(newNumber);
          if (!isNaN(num) && num > 0) {
            // Store the custom number as data attribute
            li.setAttribute('data-ol-number', num);
            
            // Apply custom CSS if not already applied
            if (!document.getElementById('custom-ol-numbers')) {
              const style = document.createElement('style');
              style.id = 'custom-ol-numbers';
              style.textContent = `
                ol li[data-ol-number] {
                  list-style: none;
                  counter-increment: none;
                }
                ol li[data-ol-number]::before {
                  content: attr(data-ol-number) ". ";
                  font-weight: inherit;
                }
              `;
              document.head.appendChild(style);
            }
            
            saveToHistory();
            
            // Show notification
            const notification = document.createElement('div');
            notification.textContent = `✓ Номер на list item промънен на ${num}`;
            notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.style.transition = 'opacity 0.3s';
              notification.style.opacity = '0';
              setTimeout(() => notification.remove(), 300);
            }, 2000);
          } else {
            alert('Моля, въведи положително число');
          }
        }
      }
    });

    // Keyboard shortcuts
    editor.addEventListener('keydown', (e) => {
      // CRITICAL: Handle Enter in list items to prevent <p> tag wrapping
      if (e.key === 'Enter') {
        const selection = window.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          
          // Check if we're inside a list item
          while (node && node !== editor) {
            if (node.nodeType === 1 && node.tagName === 'LI') {
              // We're in a list item - let browser handle it but don't prevent
              // The input event will clean up any stray <p> tags
              return;
            }
            node = node.parentNode;
          }
        }
      }
      
      // Handle Tab/Shift+Tab for list indentation
      if (e.key === 'Tab') {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        
        // Find if we're in a list item
        while (node && node !== editor) {
          if (node.nodeType === 1 && node.tagName === 'LI') {
            e.preventDefault();
            if (e.shiftKey) {
              document.execCommand('outdent', false, null);
            } else {
              document.execCommand('indent', false, null);
            }
            saveToHistory();
            return;
          }
          node = node.parentNode;
        }
      }
      
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'b') {
          e.preventDefault();
          document.execCommand('bold', false, null);
          saveToHistory();
        } else if (e.key === 'i') {
          e.preventDefault();
          document.execCommand('italic', false, null);
          saveToHistory();
        } else if (e.key === 's' || e.key === 'S' || e.key === 'С' || e.key === 'с') {
          e.preventDefault();
          // Open save modal (same as download button)
          document.getElementById('saveFileModal').style.display = 'block';
        } else if (e.key === '`') {
          e.preventDefault();
          document.execCommand('formatBlock', false, 'code');
          saveToHistory();
        } else if (e.key === '1') {
          e.preventDefault();
          insertFormat('h1');
          saveToHistory();
        } else if (e.key === '2') {
          e.preventDefault();
          insertFormat('h2');
          saveToHistory();
        } else if (e.key === '3') {
          e.preventDefault();
          insertFormat('h3');
          saveToHistory();
        } else if (e.key === '4') {
          e.preventDefault();
          insertFormat('h4');
          saveToHistory();
        } else if (e.key === '0') {
          e.preventDefault();
          insertFormat('p');
          saveToHistory();
        } else if (e.key === 'g' || e.key === 'G' || e.key === 'Г' || e.key === 'г') {
          e.preventDefault();
          document.execCommand('insertUnorderedList', false, null);
          saveToHistory();
        } else if ((e.key === 'o' || e.key === 'O'|| e.key === 'О' || e.key === 'о') && e.shiftKey) {
          e.preventDefault();
          document.execCommand('insertOrderedList', false, null);
          saveToHistory();
        } else if (e.key === 't' || e.key === 'T' || e.key === 'т' || e.key === 'Т') {
          e.preventDefault();
          insertTable();
        } else if (e.key === 'k' || e.key === 'K'|| e.key === 'К' || e.key === 'к') {
          e.preventDefault();
          insertLink();
        } else if (e.key === 'q' || e.key === 'Q' || e.key === 'я' || e.key === 'Я') {
          e.preventDefault();
          insertBlockquote();
        } else if ((e.key === 'z' || e.key === 'Z'|| e.key === 'З' || e.key === 'з') && !e.shiftKey) {
          e.preventDefault();
          if (historyIndex > 0) {
            historyIndex--;
            editor.innerHTML = history[historyIndex];
          }
        } else if (((e.key === 'z' || e.key === 'Z') && e.shiftKey) || (e.key === 'y' || e.key === 'Y')) {
          e.preventDefault();
          if (historyIndex < history.length - 1) {
            historyIndex++;
            editor.innerHTML = history[historyIndex];
          }
        } else if (e.key === 'm' || e.key === 'M' || e.key === 'М' || e.key === 'м') {
          e.preventDefault();
          mergeAdjacentLists();
          saveToHistory();
        } else if ((e.key === 'c' || e.key === 'C' || e.key === 'С' || e.key === 'с') && e.altKey) {
          e.preventDefault();
          // Apply last used text color
          const lastColor = localStorage.getItem('mdEditorTextColor') || '#1f2937';
          applyFormatting('color', lastColor);
          saveToHistory();
        }
      }
    });

    // CRITICAL: Prevent browser from wrapping list content in <p> tags
    // This event fires BEFORE the change is made, allowing us to prevent it
    editor.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph') {
        // Check if we're in a list item
        const selection = window.getSelection();
        if (selection.rangeCount) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          
          while (node && node !== editor) {
            if (node.nodeType === 1 && node.tagName === 'LI') {
              // We're in a list item - don't prevent, let browser handle it
              // But the input event will clean up any unwanted tags
              return;
            }
            node = node.parentNode;
          }
        }
      }
    });

    // Save to history on input and detect "---" for horizontal rule
    editor.addEventListener('input', () => {
      // SAFE: Only remove completely empty <p> tags
      let cleanedHtml = editor.innerHTML;
      cleanedHtml = cleanedHtml.replace(/<p>\s*<\/p>/g, '');
      
      // If HTML changed, update editor (preserve cursor position)
      if (cleanedHtml !== editor.innerHTML) {
        const sel = window.getSelection();
        const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        const offset = range ? range.startOffset : 0;
        const container = range ? range.startContainer : null;
        
        editor.innerHTML = cleanedHtml;
        
        // Try to restore cursor position
        if (container && editor.contains(container)) {
          try {
            const newRange = document.createRange();
            newRange.setStart(container, Math.min(offset, container.length || 0));
            newRange.collapse(true);
            sel.removeAllRanges();
            sel.addRange(newRange);
          } catch (e) {
            // Ignore cursor restoration errors
          }
        }
      }
      
      if (editor.textContent.trim().length > 0) {
        // Debounce history saving
        clearTimeout(editor.historyTimeout);
        editor.historyTimeout = setTimeout(() => {
          saveToHistory();
        }, 1000);
      }
      
      // Auto-convert "---" to horizontal rule
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        let node = range.startContainer;
        
        // Find parent paragraph
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'P' || node.tagName === 'DIV')) {
            const text = node.textContent.trim();
            if (text === '---' && node.tagName === 'P') {
              // Replace this paragraph with <hr>
              const hr = document.createElement('hr');
              node.parentNode.replaceChild(hr, node);
              
              // Create new paragraph after hr and focus there
              const newP = document.createElement('p');
              newP.innerHTML = '<br>';
              hr.parentNode.insertBefore(newP, hr.nextSibling);
              
              const newRange = document.createRange();
              newRange.setStart(newP, 0);
              newRange.collapse(true);
              selection.removeAllRanges();
              selection.addRange(newRange);
              
              saveToHistory();
            }
            break;
          }
          node = node.parentNode;
        }
      }
    });

    // Handle copy events - preserve formatting
    editor.addEventListener('copy', (e) => {
      const selection = window.getSelection();
      if (selection.toString().length === 0) return;
      
      // Get the HTML content
      const range = selection.getRangeAt(0);
      const fragment = range.cloneContents();
      const div = document.createElement('div');
      div.appendChild(fragment);
      
      // Convert HTML to markdown
      const markdown = htmlToMarkdown(div.innerHTML);
      
      // Set both plain text and HTML in clipboard
      e.clipboardData.setData('text/plain', markdown);
      e.clipboardData.setData('text/html', div.innerHTML);
      e.preventDefault();
    });

    // Handle paste events - convert markdown to HTML and insert
    editor.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text/plain');
      
      // Get current selection
      const selection = window.getSelection();
      if (selection.rangeCount === 0) return;
      
      const range = selection.getRangeAt(0);
      
      // Convert markdown to HTML
      const html = markdownToHtml(text);
      
      // Create temporary container with the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Delete current selection
      range.deleteContents();
      
      // Insert HTML nodes directly - preserves list structure including nested lists
      let lastNode = null;
      while (tempDiv.firstChild) {
        const node = tempDiv.firstChild;
        range.insertNode(node);
        lastNode = node;
        range.setStartAfter(node);
      }
      
      // Move cursor after all inserted content
      if (lastNode) {
        range.setStartAfter(lastNode);
        range.collapse(true);
      }
      
      selection.removeAllRanges();
      selection.addRange(range);
      
      // Trigger input event to save history
      editor.dispatchEvent(new Event('input', { bubbles: true }));
    });
    // Click handler for links (Ctrl+Click to open)
    editor.addEventListener('click', (e) => {
      // Check if clicking on a link
      let target = e.target;
      
      // Find parent link if clicking on child element
      while (target && target !== editor) {
        if (target.tagName === 'A') {
          // Ctrl+Click or Cmd+Click to open link
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              window.open(href, '_blank');
              
              // Show notification
              const notification = document.createElement('div');
              notification.textContent = `🔗 Opening: ${href}`;
              notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #2563eb; color: white; padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px;';
              document.body.appendChild(notification);
              
              setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
              }, 2000);
            }
          } else {
            // Regular click - show tooltip
            e.preventDefault();
            const href = target.getAttribute('href');
            if (href && href !== '#') {
              const tooltip = document.createElement('div');
              tooltip.textContent = `Ctrl+Click to open: ${href}`;
              tooltip.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #374151; color: white; padding: 8px 14px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 12px;';
              document.body.appendChild(tooltip);
              
              setTimeout(() => {
                tooltip.style.transition = 'opacity 0.3s';
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
              }, 1500);
            }
          }
          break;
        }
        target = target.parentElement;
      }
    });

    // Drag and drop for images
    editor.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fef3c7';
    });

    editor.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fff';
    });

    editor.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editor.style.background = '#fff';
      
      const files = e.dataTransfer.files;
      if (files.length === 0) return;
      
      // Get drop position
      let range;
      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(e.clientX, e.clientY);
      } else if (e.rangeParent) {
        range = document.createRange();
        range.setStart(e.rangeParent, e.rangeOffset);
      }
      
      // Process each dropped file
      Array.from(files).forEach(file => {
        if (file.type.startsWith('image/')) {
          console.log('Image dropped:', file.name);
          
          // Create FileReader to get base64 for preview
          const reader = new FileReader();
          reader.onload = (event) => {
            const base64 = event.target.result;
            const fileName = file.name;
            
            console.log('Image loaded, creating element...');
            
            // Create img element with base64 for preview
            const img = document.createElement('img');
            img.src = base64;
            img.alt = fileName.replace(/\.[^.]+$/, ''); // Remove extension for alt
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            
            // Store the relative path in data attribute
            img.setAttribute('data-original-src', 'assets/' + fileName);
            
            // Insert at drop position
            if (range) {
              range.insertNode(img);
              
              // Add a line break after image
              const br = document.createElement('br');
              range.setStartAfter(img);
              range.insertNode(br);
              
              // Move cursor after br
              range.setStartAfter(br);
              range.collapse(true);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            } else {
              // Fallback: append to editor
              editor.appendChild(img);
              editor.appendChild(document.createElement('br'));
            }
            
            saveToHistory();
            console.log('Image inserted successfully');
            
            // Show notification
            const notification = document.createElement('div');
            notification.textContent = `✓ Image added: assets/${fileName}`;
            notification.style.cssText = 'position: fixed; top: 70px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px; max-width: 400px;';
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.style.transition = 'opacity 0.3s';
              notification.style.opacity = '0';
              setTimeout(() => notification.remove(), 300);
            }, 3000);
          };
          reader.readAsDataURL(file);
        }
      });
    });

    // Prevent default drag & drop behavior on the whole page
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    // Escape HTML special characters
    function escapeHtml(text) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, m => map[m]);
    }

    // HTML to Markdown conversion
    function htmlToMarkdown(html) {
      let markdown = '';
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + html + '</div>', 'text/html');
      
      const processNode = (node) => {
        if (node.nodeType === 3) {
          // Text node
          return node.textContent;
        } else if (node.nodeType === 1) {
          const tag = node.tagName.toLowerCase();
          
          if (tag === 'h1') {
            return '# ' + processChildren(node) + '\n';
          } else if (tag === 'h2') {
            return '## ' + processChildren(node) + '\n';
          } else if (tag === 'h3') {
            return '### ' + processChildren(node) + '\n';
          } else if (tag === 'h4') {
            return '#### ' + processChildren(node) + '\n';
          } else if (tag === 'p') {
            return processChildren(node) + '\n';
          } else if (tag === 'strong' || tag === 'b') {
            return '**' + processChildren(node) + '**';
          } else if (tag === 'em' || tag === 'i') {
            return '*' + processChildren(node) + '*';
          } else if (tag === 'u') {
            return '__' + processChildren(node) + '__';
          } else if (tag === 'code') {
            return '`' + processChildren(node) + '`';
          } else if (tag === 'a') {
            return '[' + processChildren(node) + '](' + (node.href || '#') + ')';
          } else if (tag === 'img') {
            // ALWAYS use data-original-src for relative path (e.g., assets/image.png)
            // Never use the absolute src attribute which may contain file:// or http://
            const src = node.getAttribute('data-original-src') || '';
            const alt = node.getAttribute('alt') || '';
            // Skip if no original source (broken image)
            if (!src) return '';
            return '![' + alt + '](' + src + ')';
          } else if (tag === 'blockquote') {
            return '> ' + processChildren(node).trim() + '\n';
          } else if (tag === 'ul') {
            let items = '';
            node.querySelectorAll(':scope > li').forEach(li => {
              // Get only direct text content, excluding nested lists
              let textContent = '';
              for (let child of li.childNodes) {
                if (child.nodeType === 3) {
                  textContent += child.textContent;
                } else if (child.nodeType === 1) {
                  const childTag = child.tagName.toLowerCase();
                  if (childTag !== 'ul' && childTag !== 'ol') {
                    textContent += processNode(child);
                  }
                }
              }
              items += '- ' + textContent.trim() + '\n';
              
              // Process nested lists with indent
              const nestedUl = li.querySelector(':scope > ul');
              const nestedOl = li.querySelector(':scope > ol');
              if (nestedUl) {
                const nestedItems = processNode(nestedUl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
              if (nestedOl) {
                const nestedItems = processNode(nestedOl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
            });
            return items;
          } else if (tag === 'ol') {
            let items = '';
            let counter = 1;
            node.querySelectorAll(':scope > li').forEach(li => {
              // Get only direct text content, excluding nested lists
              let textContent = '';
              for (let child of li.childNodes) {
                if (child.nodeType === 3) {
                  textContent += child.textContent;
                } else if (child.nodeType === 1) {
                  const childTag = child.tagName.toLowerCase();
                  if (childTag !== 'ul' && childTag !== 'ol') {
                    textContent += processNode(child);
                  }
                }
              }
              items += counter + '. ' + textContent.trim() + '\n';
              counter++;
              
              // Process nested lists with indent
              const nestedUl = li.querySelector(':scope > ul');
              const nestedOl = li.querySelector(':scope > ol');
              if (nestedUl) {
                const nestedItems = processNode(nestedUl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
              if (nestedOl) {
                const nestedItems = processNode(nestedOl);
                items += nestedItems.split('\n').map(line => line ? '  ' + line : '').join('\n');
              }
            });
            return items;
          } else if (tag === 'hr') {
            return '---\n';
          } else if (tag === 'table') {
            return processTable(node) + '\n';
          } else if (tag === 'br') {
            return '\n';
          } else if (tag === 'pre') {
            return '```\n' + node.textContent + '\n```\n';
          } else {
            return processChildren(node);
          }
        }
        return '';
      };
      
      const processChildren = (node) => {
        let result = '';
        for (let child of node.childNodes) {
          result += processNode(child);
        }
        return result;
      };
      
      const processTable = (table) => {
        let markdown = '';
        const rows = table.querySelectorAll('tr');
        
        rows.forEach((row, rowIdx) => {
          const cells = row.querySelectorAll('td, th');
          markdown += '| ';
          cells.forEach(cell => {
            // Process cell content and replace newlines with <br>
            let cellContent = processChildren(cell).replace(/\n/g, '<br>').trim();
            markdown += cellContent + ' | ';
          });
          markdown += '\n';
          
          if (rowIdx === 0) {
            markdown += '| ';
            for (let i = 0; i < cells.length; i++) {
              markdown += '--- | ';
            }
            markdown += '\n';
          }
        });
        
        return markdown;
      };
      
      markdown = processChildren(doc.querySelector('div'));
      
      // Clean up multiple consecutive newlines and trim
      return markdown.replace(/\n\n+/g, '\n').trim();
    }

    // Markdown to HTML conversion with proper nested lists
    function markdownToHtml(markdown) {
      let html = '';
      const lines = markdown.split(/\r?\n/);
      let i = 0;
      let iterations = 0;
      const MAX_ITERATIONS = 10000; // Safety limit
      
      while (i < lines.length && iterations < MAX_ITERATIONS) {
        iterations++;
        const line = lines[i];
        
        // Skip empty lines
        if (!line.trim()) {
          i++;
          continue;
        }
        
        // Headings
        if (line.startsWith('#### ')) {
          html += '<h4>' + applyInlineFormatting(line.substring(5)) + '</h4>';
          i++;
        } else if (line.startsWith('### ')) {
          html += '<h3>' + applyInlineFormatting(line.substring(4)) + '</h3>';
          i++;
        } else if (line.startsWith('## ')) {
          html += '<h2>' + applyInlineFormatting(line.substring(3)) + '</h2>';
          i++;
        } else if (line.startsWith('# ')) {
          html += '<h1>' + applyInlineFormatting(line.substring(2)) + '</h1>';
          i++;
        }
        // Blockquote
        else if (line.startsWith('> ')) {
          html += '<blockquote>' + applyInlineFormatting(line.substring(2)) + '</blockquote>';
          i++;
        }
        // Horizontal rule
        else if (line.trim() === '---' || line.trim() === '***' || line.trim() === '___') {
          html += '<hr>';
          i++;
        }
        // Lists - use processListBlock for proper nesting
        else if (line.match(/^\s*[-*]\s+/) || line.match(/^\s*\d+\.\s+/)) {
          const oldI = i;
          const listResult = processListBlock(lines, i);
          html += listResult.html;
          i = listResult.nextIndex;
          
          // Safety check: make sure i moved forward
          if (i <= oldI) {
            console.error('processListBlock did not advance! Breaking to prevent infinite loop.');
            i = oldI + 1; // Force advance
          }
        }
        // Tables
        else if (line.includes('|')) {
          let tableHtml = '<table><tbody>';
          let tableIterations = 0;
          while (i < lines.length && lines[i].includes('|') && tableIterations < 1000) {
            tableIterations++;
            const cells = lines[i].split('|').map(c => c.trim()).filter(c => c && !c.match(/^:?-+:?$/));
            if (cells.length > 0) {
              tableHtml += '<tr>';
              cells.forEach(cell => {
                tableHtml += '<td>' + applyInlineFormatting(cell) + '</td>';
              });
              tableHtml += '</tr>';
            }
            i++;
          }
          tableHtml += '</tbody></table>';
          html += tableHtml;
        }
        // Paragraphs
        else {
          html += '<p>' + applyInlineFormatting(line) + '</p>';
          i++;
        }
      }
      
      if (iterations >= MAX_ITERATIONS) {
        console.error('markdownToHtml: MAX_ITERATIONS reached! Returning partial HTML.');
      }
      
      return html;
    }
    
    // Process a block of list lines and create proper nested HTML
    function processListBlock(lines, startIndex) {
      let i = startIndex;
      let html = '';
      let iterations = 0;
      const MAX_ITERATIONS = 1000;
      
      // Simple approach: build list recursively by level
      function processListAtLevel(startIdx, minLevel) {
        let idx = startIdx;
        let result = '';
        let currentTag = null;
        
        while (idx < lines.length && iterations < MAX_ITERATIONS) {
          iterations++;
          const line = lines[idx];
          
          if (!line.trim()) {
            idx++;
            continue;
          }
          
          const match = line.match(/^(\s*)([-*]|\d+\.)\s+(.*)$/);
          if (!match) break;
          
          const indent = match[1].length;
          const level = Math.floor(indent / 2);
          const marker = match[2];
          const content = match[3];
          const tag = /^\d+\.$/.test(marker) ? 'ol' : 'ul';
          
          // If level is less than minLevel, stop and return
          if (level < minLevel) break;
          
          // If level is greater than minLevel, recursively process nested list
          if (level > minLevel) {
            const nested = processListAtLevel(idx, level);
            result += nested.html;
            idx = nested.nextIdx;
            continue;
          }
          
          // Same level
          if (currentTag !== tag) {
            if (currentTag) result += '</' + currentTag + '>';
            currentTag = tag;
            result += '<' + tag + '>';
          }
          
          result += '<li>' + applyInlineFormatting(content) + '</li>';
          idx++;
        }
        
        if (currentTag) result += '</' + currentTag + '>';
        return { html: result, nextIdx: idx };
      }
      
      const listResult = processListAtLevel(startIndex, 0);
      return { html: listResult.html, nextIndex: listResult.nextIdx };
    }

    // Apply inline formatting (bold, italic, code, links, images)
    function applyInlineFormatting(text) {
      // Images must be processed before links
      text = text.replace(/!\[(.*?)\]\((.*?)\)/g, (match, alt, src) => {
        // If we have a base path and src is relative, create absolute path for display
        if (globalImageBasePath && !src.startsWith('http://') && !src.startsWith('https://') && !src.startsWith('data:') && !src.startsWith('file://')) {
          const absoluteSrc = globalImageBasePath + src;
          return `<img src="${absoluteSrc}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
        }
        // Always preserve the original src in data-original-src
        return `<img src="${src}" alt="${alt}" data-original-src="${src}" style="max-width:100%; height:auto;">`;
      });
      text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/__(.*?)__/g, '<u>$1</u>');
      text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
      text = text.replace(/`(.*?)`/g, '<code>$1</code>');
      text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
      // Handle <br> tags
      text = text.replace(/<br\s*\/?>/gi, '<br>');
      return text;
    }

    // Load saved content from localStorage OR from URL parameter
    window.addEventListener('load', () => {
      // Check if there's a path parameter (coming from md-viewer)
      const urlParams = new URLSearchParams(window.location.search);
      const filePath = urlParams.get('path');
      const loadFromHash = urlParams.get('loadFromHash');
      
      if (loadFromHash === 'true' && window.location.hash) {
        // Load from URL hash (content passed from index.html)
        try {
          const markdownContent = decodeURIComponent(window.location.hash.substring(1));
          
          // Set global base path for images
          if (filePath) {
            const basePath = filePath.substring(0, filePath.lastIndexOf('/') + 1);
            
            // For file:// protocol, construct path differently
            if (window.location.protocol === 'file:') {
              // Get the directory of the current HTML file
              const currentPath = window.location.pathname;
              const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
              globalImageBasePath = window.location.protocol + '//' + currentDir + basePath;
            } else {
              // For http:// or https://
              const currentOrigin = window.location.origin;
              globalImageBasePath = currentOrigin + '/' + basePath;
            }
            
            console.log('Global Image Base Path:', globalImageBasePath);
          }
          
          // Convert markdown to HTML (now with absolute image paths built-in)
          isLoadingFile = true;
          const html = markdownToHtml(markdownContent);
          editor.innerHTML = html;
          setTimeout(() => { isLoadingFile = false; }, 100); // Reset after load
          
          history = [editor.innerHTML];
          historyIndex = 0;
          
          // Update page title
          if (filePath) {
            const fileName = filePath.split('/').pop();
            document.title = fileName.replace(/\.(md|txt)$/i, '').replace(/^\d+-/, '').replace(/^msg-/i, '') + ' — Markdown Editor';
          }
          
          // Clear URL parameters to prevent auto-reload on refresh
          window.history.replaceState({}, document.title, window.location.pathname);
        } catch (err) {
          alert('Грешка при зареждане на съдържанието: ' + err.message);
          console.error('Load error:', err);
        }
      } else if (filePath) {
        // Original fetch-based loading (kept for backward compatibility)
        const decodedPath = decodeURIComponent(filePath);
        const encodedPath = decodedPath.split('/').map(encodeURIComponent).join('/');
        const absoluteUrl = (window.location.origin && window.location.origin !== 'null')
          ? new URL(encodedPath, window.location.origin).href
          : encodedPath;
        
        // Load file from path
        fetch(absoluteUrl)
          .then(r => {
            if (!r.ok) throw new Error('HTTP ' + r.status);
            return r.text();
          })
          .then(content => {
            // Determine if it's HTML or Markdown based on file extension
            const fileName = decodedPath.split('/').pop();
            const isHtmlFile = fileName.endsWith('.html');
            
            isLoadingFile = true;
            let html = '';
            
            if (isHtmlFile) {
              // It's HTML - extract ONLY what's between <body> tags, NOT the <head>
              const bodyMatch = content.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
              if (bodyMatch) {
                html = bodyMatch[1];
              } else {
                // Fallback: if no body tags, this is probably a corrupted file
                // Try to extract everything after </head> or <body> markers
                const headEndMatch = content.match(/<\/head\s*>/i);
                if (headEndMatch) {
                  // Find everything after </head>
                  const headEndIndex = headEndMatch.index + headEndMatch[0].length;
                  let afterHead = content.substring(headEndIndex);
                  // Remove opening <body> tag if present
                  afterHead = afterHead.replace(/^<body[^>]*>/i, '');
                  // Remove closing tags
                  afterHead = afterHead.replace(/<\/body\s*>[\s\S]*$/i, '');
                  html = afterHead;
                } else {
                  // Last resort - use empty content
                  html = '';
                }
              }
              
              // REMOVE ALL <br> tags between list items - this fixes the indent list problem
              // Loop until no more <br> tags found between list elements
              let prevHtml;
              do {
                prevHtml = html;
                // Remove <br> between any list-related closing and opening tags
                html = html.replace(/<\/(li|ul|ol)>\s*<br\s*\/?>\s*</gi, '</$1><');
              } while (html !== prevHtml);
              
              // Also remove leading empty <br> and whitespace
              html = html.replace(/^\s*<br\s*\/?>\s*/i, '');
              // CRITICAL: Remove all block-level tags that shouldn't be in contenteditable
              // Keep only formatting tags: strong, em, u, code, a, img, li, ul, ol, h1-h4, blockquote, table
              // Remove: p, div, span, style, meta, script, head, body, html, link, etc.
              
              // First, unwrap <p> tags - keep content but remove the tag itself
              html = html.replace(/<\/?p[^>]*>/gi, '');
              
              // Remove <div> tags but keep content
              html = html.replace(/<\/?div[^>]*>/gi, '');
              
              // Remove <span> tags but keep content
              html = html.replace(/<\/?span[^>]*>/gi, '');
              
              // Remove ALL <style> blocks
              html = html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
              
              // Remove ALL <script> blocks
              html = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
              
              // Remove <meta> tags
              html = html.replace(/<meta[^>]*>/gi, '');
              
              // Remove <link> tags
              html = html.replace(/<link[^>]*>/gi, '');
              
              // Remove <title> tags
              html = html.replace(/<title[^>]*>[\s\S]*?<\/title>/gi, '');
              
              // Remove <head> tags
              html = html.replace(/<\/?head[^>]*>/gi, '');
              
              // Remove <html> tags
              html = html.replace(/<\/?html[^>]*>/gi, '');
            } else {
              // It's Markdown - convert to HTML
              html = markdownToHtml(content);
            }
            
            editor.innerHTML = html;
            
            // CRITICAL: After setting innerHTML, remove all <br> tags that are between list items
            // This prevents visual empty lines that appear when editing
            let editorHtml = editor.innerHTML;
            let prevEditorHtml;
            do {
              prevEditorHtml = editorHtml;
              // Remove <br> between list-related tags
              editorHtml = editorHtml.replace(/<\/(li|ul|ol)>\s*<br\s*\/?>\s*</gi, '</$1><');
            } while (editorHtml !== prevEditorHtml);
            
            editor.innerHTML = editorHtml;
            
            setTimeout(() => { isLoadingFile = false; }, 100);
            history = [editorHtml];
            historyIndex = 0;
            
            // Update page title
            document.title = fileName.replace(/\.(md|txt|html)$/i, '') + ' — Markdown Editor';
          })
          .catch(err => {
            const isFile = window.location.protocol === 'file:';
            const hint = isFile
              ? '\n\nСъвет: Отвори сайта през локален HTTP сървър (напр. VS Code Live Server), тъй като браузърите блокират fetch от file://'
              : '';
            alert('Грешка при зареждане на файла: ' + err.message + hint);
            console.error('Load error:', err);
          });
      } else {
        // Load from localStorage if no path parameter
        const saved = localStorage.getItem('mdEditorContent');
        if (saved) {
          editor.innerHTML = saved;
          history = [saved];
          historyIndex = 0;
        }
      }
    });

    // Auto-save to localStorage (only when user is actually editing, not loading files)
    editor.addEventListener('input', () => {
      if (isLoadingFile) return; // Don't save during file load
      
      clearTimeout(editor.saveTimeout);
      editor.saveTimeout = setTimeout(() => {
        localStorage.setItem('mdEditorContent', editor.innerHTML);
      }, 2000);
    });

    // Table context menu
    // Edit table button - copy table and open Tables Generator

    // Function to import table from clipboard
    function importTableFromClipboard() {
      navigator.clipboard.readText().then(html => {
        // Check if it's a table
        if (html.includes('<table')) {
          const fragment = document.createRange().createContextualFragment(html);
          const range = window.getSelection().getRangeAt(0);
          range.insertNode(fragment);
          saveToHistory();
          alert('Table imported successfully!');
        } else {
          alert('Clipboard does not contain a table. Please copy HTML table from tablesgenerator.com');
        }
      }).catch(err => {
        console.error('Failed to read clipboard:', err);
      });
    }

    // Add keyboard shortcut for importing: Ctrl+Shift+V
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'V') {
        e.preventDefault();
        importTableFromClipboard();
      }
    });

    // Table column resizing functionality
    let resizingColumn = null;
    let resizingTable = null;
    let startX = 0;
    let startWidth = 0;
    let originalTableWidth = 0;

    editor.addEventListener('mousedown', (e) => {
      // Check if clicking on column resize handle
      if (e.target.tagName === 'TD' || e.target.tagName === 'TH') {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        if (isAtRightEdge && e.clientX > rect.left + 10) {
          const row = cell.closest('tr');
          const table = cell.closest('table');
          const isLastCell = cell.cellIndex === row.cells.length - 1;
          
          // Set fixed widths for all cells in all rows
          const allRows = table.querySelectorAll('tr');
          allRows.forEach(r => {
            for (let i = 0; i < r.cells.length; i++) {
              const c = r.cells[i];
              c.style.width = c.offsetWidth + 'px';
            }
          });
          table.style.tableLayout = 'fixed';
          originalTableWidth = table.offsetWidth;
          
          if (isLastCell) {
            resizingTable = table;
            startWidth = table.offsetWidth;
          } else {
            resizingColumn = cell;
            startWidth = cell.offsetWidth;
          }
          startX = e.clientX;
          document.body.style.cursor = isLastCell ? 'ew-resize' : 'col-resize';
          e.preventDefault();
        }
      }
    });

    document.addEventListener('mousemove', (e) => {
      // Handle table resize (when dragging last column edge)
      if (resizingTable) {
        const diff = e.clientX - startX;
        const newWidth = Math.max(100, startWidth + diff);
        resizingTable.style.width = newWidth + 'px';
        document.body.style.cursor = 'ew-resize';
      }
      // Handle column resize - ONLY change the dragged column
      else if (resizingColumn) {
        const diff = e.clientX - startX;
        const newWidth = Math.max(30, startWidth + diff);
        const colIndex = resizingColumn.cellIndex;
        const table = resizingColumn.closest('table');
        
        if (table) {
          // Update ONLY the dragged column width
          const allRows = table.querySelectorAll('tr');
          allRows.forEach(r => {
            if (r.cells[colIndex]) {
              r.cells[colIndex].style.width = newWidth + 'px';
            }
          });
          // Adjust table width to maintain layout
          table.style.width = (originalTableWidth + diff) + 'px';
        }
        document.body.style.cursor = 'col-resize';
      }
    });

    document.addEventListener('mouseup', () => {
      if (resizingTable || resizingColumn) {
        saveToHistory();
        resizingTable = null;
        resizingColumn = null;
        document.body.style.cursor = 'default';
      }
    });

    // Update cursor style for column resize hover
    editor.addEventListener('mouseover', (e) => {
      if ((e.target.tagName === 'TD' || e.target.tagName === 'TH') && !resizingColumn) {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        
        if (isAtRightEdge && e.clientX > rect.left + 50) {
          document.body.style.cursor = 'col-resize';
        } else {
          document.body.style.cursor = 'default';
        }
      }
    });

    editor.addEventListener('mousemove', (e) => {
      if (!resizingColumn && (e.target.tagName === 'TD' || e.target.tagName === 'TH')) {
        const cell = e.target;
        const rect = cell.getBoundingClientRect();
        const isAtRightEdge = Math.abs(e.clientX - rect.right) < 5;
        
        if (isAtRightEdge && e.clientX > rect.left + 50) {
          document.body.style.cursor = 'col-resize';
        } else {
          document.body.style.cursor = 'default';
        }
      }
    });

    editor.addEventListener('mouseout', (e) => {
      if (!resizingColumn && (e.target.tagName === 'TD' || e.target.tagName === 'TH')) {
        document.body.style.cursor = 'default';
      }
    });
  </script>
</body>
</html>
